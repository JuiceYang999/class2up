
emqx_statsd_api {

  get_statsd_config_api {
    desc {
      en: """List the configuration of StatsD metrics collection and push service."""
      zh: """列出 StatsD 指标采集和推送服务的的配置。"""
    }
  }

  update_statsd_config_api {
    desc {
      en: """Update the configuration of StatsD metrics collection and push service."""
      zh: """更新 StatsD 指标采集和推送服务的配置。"""
    }
  }
}

emqx_statsd_schema {

  get_statsd_config_api {
    desc {
      en: """List the configuration of StatsD metrics collection and push service."""
      zh: """列出 StatsD 指标采集和推送服务的的配置。"""
    }
  }

  update_statsd_config_api {
    desc {
      en: """Update the configuration of StatsD metrics collection and push service."""
      zh: """更新 StatsD 指标采集和推送服务的配置。"""
    }
  }

  statsd {
    desc {
      en: """StatsD metrics collection and push configuration."""
      zh: """StatsD 指标采集与推送配置。"""
    }
    label {
      en: """StatsD"""
      zh: """StatsD"""
    }
  }

  server {
    desc {
      en: """StatsD server address."""
      zh: """StatsD 服务器地址。"""
    }
  }

  sample_interval {
    desc {
      en: """The sampling interval for metrics."""
      zh: """指标的采样间隔。"""
    }
  }

  flush_interval {
    desc {
      en: """The push interval for metrics."""
      zh: """指标的推送间隔。"""
    }
  }
  tags {
    desc {
      en: """The tags for metrics."""
      zh: """指标的标签。"""
    }
  }

  enable {
    desc {
      en: """Enable or disable StatsD metrics collection and push service."""
      zh: """启用或禁用 StatsD 指标采集和推送服务。"""
    }
  }
}

emqx_slow_subs_api {

  clear_records_api {
    desc {
      en: "Clear current data and re count slow topic"
      zh: "清除当前记录，然后重新开始统计"
    }
  }

  get_records_api {
    desc {
      en: "View slow topics statistics record data"
      zh: "查看慢订阅的统计数据"
    }
  }

  get_setting_api {
    desc {
      en: "View slow subs settings"
      zh: "查看配置"
    }
  }

  update_setting_api {
    desc {
      en: "Update slow subs settings"
      zh: "更新配置"
    }
  }

  clientid {
    desc {
      en: "Message clientid"
      zh: "消息的客户端 ID"
    }
  }

  node {
    desc {
      en: "Message node name"
      zh: "消息的节点名称"
    }
  }

  topic {
    desc {
      en: "Message topic"
      zh: "消息的主题"
    }
  }

  timespan {
    desc {
      en: "Timespan for message transmission"
      zh: "消息的传输耗时"
    }
  }

  last_update_time {
    desc {
      en: "The timestamp of last update"
      zh: "记录的更新时间戳"
    }
  }

}

emqx_slow_subs_schema {

  enable {
    desc {
      en: "Enable this feature"
      zh: "开启慢订阅"
    }
  }

  threshold {
    desc {
      en: "The latency threshold for statistics"
      zh: "慢订阅统计的阈值"
    }
  }

  expire_interval {
    desc {
      en: "The eviction time of the record, which in the statistics record table"
      zh: "慢订阅记录的有效时间"
    }
  }

  top_k_num {
    desc {
      en: "The maximum number of records in the slow subscription statistics record table"
      zh: "慢订阅统计表的记录数量上限"
    }
  }

  stats_type {
    desc {
      en: "The method to calculate the latency"
      zh: "慢订阅的统计类型"
    }
  }

}

emqx_rule_api_schema {

    event_event_type {
                   desc {
                         en: "Event Type"
                         zh: "事件类型"
                        }
                   label: {
                           en: "Event Type"
                           zh: "事件类型"
                          }
                  }

    event_id {
                   desc {
                         en: "Message ID"
                         zh: "消息 ID"
                        }
                   label: {
                           en: "Message ID"
                           zh: "消息 ID"
                          }
                  }

    event_clientid {
                   desc {
                         en: "The Client ID"
                         zh: "客户端 ID"
                        }
                   label: {
                           en: "Client ID"
                           zh: "客户端 ID"
                          }
                  }

    event_username {
                   desc {
                         en: "The User Name"
                         zh: ""
                        }
                   label: {
                           en: "Username"
                           zh: "用户名"
                          }
                  }

    event_payload {
                   desc {
                         en: "The Message Payload"
                         zh: "消息负载"
                        }
                   label: {
                           en: "Message Payload"
                           zh: "消息负载"
                          }
                  }

    event_peerhost {
                   desc {
                         en: "The IP Address of the Peer Client"
                         zh: "对等客户端的 IP 地址"
                        }
                   label: {
                           en: "Peer IP Address"
                           zh: "对等客户端的 IP"
                          }
                  }

    event_topic {
                   desc {
                         en: "Message Topic"
                         zh: "消息主题"
                        }
                   label: {
                           en: "Message Topic"
                           zh: "消息主题"
                          }
                  }

    event_publish_received_at {
                   desc {
                         en: "The Time that this Message is Received"
                         zh: "消息被接受的时间"
                        }
                   label: {
                           en: "Message Received Time"
                           zh: "消息被接受的时间"
                          }
                  }

    event_qos {
                   desc {
                         en: "The Message QoS"
                         zh: "消息的 QoS"
                        }
                   label: {
                           en: "Message QoS"
                           zh: "消息 QoS"
                          }
                  }

    event_from_clientid {
                   desc {
                         en: "The Client ID"
                         zh: "事件来源客户端的 ID"
                        }
                   label: {
                           en: "Client ID"
                           zh: "客户端 ID"
                          }
                  }

    event_from_username {
                   desc {
                         en: "The User Name"
                         zh: "事件来源客户端的用户名"
                        }
                   label: {
                           en: "Username"
                           zh: "用户名"
                          }
                  }

    event_mountpoint {
                   desc {
                         en: "The Mountpoint"
                         zh: "挂载点"
                        }
                   label: {
                           en: "Mountpoint"
                           zh: "挂载点"
                          }
                  }

    event_peername {
                   desc {
                         en: "The IP Address and Port of the Peer Client"
                         zh: "对等客户端的 IP 地址和端口"
                        }
                   label: {
                           en: "IP Address And Port"
                           zh: "IP 地址和端口"
                          }
                  }

    event_sockname {
                   desc {
                         en: "The IP Address and Port of the Local Listener"
                         zh: "本地监听的 IP 地址和端口"
                        }
                   label: {
                           en: "IP Address And Port"
                           zh: "IP 地址和端口"
                          }
                  }

    event_proto_name {
                   desc {
                         en: "Protocol Name"
                         zh: "协议名称"
                        }
                   label: {
                           en: "Protocol Name"
                           zh: "协议名称"
                          }
                  }

    event_proto_ver {
                   desc {
                         en: "Protocol Version"
                         zh: "协议版本"
                        }
                   label: {
                           en: "Protocol Version"
                           zh: "协议版本"
                          }
                  }

    event_keepalive {
                   desc {
                         en: "KeepAlive"
                         zh: "保持连接"
                        }
                   label: {
                           en: "KeepAlive"
                           zh: "保持连接"
                          }
                  }

    event_clean_start {
                   desc {
                         en: "Clean Start"
                         zh: "清除会话"
                        }
                   label: {
                           en: "Clean Start"
                           zh: "清除会话"
                          }
                  }

    event_expiry_interval {
                   desc {
                         en: "Expiry Interval"
                         zh: "到期间隔"
                        }
                   label: {
                           en: "Expiry Interval"
                           zh: "到期间隔"
                          }
                  }

    event_is_bridge {
                   desc {
                         en: "Is Bridge"
                         zh: "是否桥接"
                        }
                   label: {
                           en: "Is Bridge"
                           zh: "是否桥接"
                          }
                  }

    event_connected_at {
                   desc {
                         en: "The Time that this Client is Connected"
                         zh: "客户端连接完成时的时刻"
                        }
                   label: {
                           en: "Connected Time"
                           zh: "连接完成时的时刻"
                          }
                  }

    event_action {
                   desc {
                         en: "Publish or Subscribe"
                         zh: "订阅或发布"
                        }
                   label: {
                           en: "Publish or Subscribe"
                           zh: "订阅或发布"
                          }
                  }

    event_authz_source {
                   desc {
                         en: "Cache, Plugs or Default"
                         zh: "缓存，插件或者默认值"
                        }
                   label: {
                           en: "Auth Source"
                           zh: "认证源"
                          }
                  }

    event_result {
                   desc {
                         en: "Allow or Deny"
                         zh: "允许或禁止"
                        }
                   label: {
                           en: "Auth Result"
                           zh: "认证结果"
                          }
                  }

    event_server {
                   desc {
                         en: "The IP address (or hostname) and port of the MQTT broker, in IP:Port format"
                         zh: "MQTT broker的 IP 地址（或主机名）和端口，采用 IP:Port 格式"
                        }
                   label: {
                           en: "Server IP And Port"
                           zh: "服务器 IP 地址和端口"
                          }
                  }

    event_dup {
                   desc {
                         en: "The DUP flag of the MQTT message"
                         zh: "MQTT 消息的 DUP 标志"
                        }
                   label: {
                           en: "DUP Flag"
                           zh: "DUP 标志"
                          }
                  }

    event_retain {
                   desc {
                         en: "If is a retain message"
                         zh: "是否是保留消息"
                        }
                   label: {
                           en: "Retain Message"
                           zh: "保留消息"
                          }
                  }

    event_ctx_dropped {
                   desc {
                         en: "The Reason for Dropping"
                         zh: "消息被丢弃的原因"
                        }
                   label: {
                           en: "Dropped Reason"
                           zh: "丢弃原因"
                          }
                  }

    event_ctx_disconnected_reason {
                   desc {
                         en: "The Reason for Disconnect"
                         zh: "断开连接的原因"
                        }
                   label: {
                           en: "Disconnect Reason"
                           zh: "断开连接原因"
                          }
                  }

    event_ctx_disconnected_da {
                   desc {
                         en: "The Time that this Client is Disconnected"
                         zh: "客户端断开连接的时刻"
                        }
                   label: {
                           en: "Disconnected Time"
                           zh: "客户端断开连接时刻"
                          }
                  }

    event_ctx_connack_reason_code {
                   desc {
                         en: "The reason code"
                         zh: "错误码"
                        }
                   label: {
                           en: "Reason Code"
                           zh: "错误码"
                          }
                  }

    rule_id {
                   desc {
                         en: "The ID of the rule"
                         zh: "规则的 ID "
                        }
                   label: {
                           en: "Rule ID"
                           zh: "规则 ID "
                          }
                  }

    node_node {
                   desc {
                         en: "The node name"
                         zh: "节点名字"
                        }
                   label: {
                           en: "Node Name"
                           zh: "节点名字"
                          }
                  }

    metrics_sql_matched {
                   desc {
                         en: "How much times the FROM clause of the SQL is matched."
                         zh: "SQL 的 FROM 子句匹配的次数。"
                        }
                   label: {
                           en: "Matched"
                           zh: "命中数"
                          }
                  }

    metrics_sql_matched_rate {
                   desc {
                         en: "The rate of matched, times/second"
                         zh: "命中速率，次/秒"
                        }
                   label: {
                           en: "命中速率"
                           zh: "Matched Rate"
                          }
                  }

    metrics_sql_matched_rate_max {
                   desc {
                         en: "The max rate of matched, times/second"
                         zh: "最大命中速率，次/秒"
                        }
                   label: {
                           en: "Max Matched Rate"
                           zh: "最大命中速率"
                          }
                  }

    metrics_sql_matched_rate_last5m {
                   desc {
                         en: "The average rate of matched in last 5 minutes, times/second"
                         zh: "5分钟平均命中速率，次/秒"
                        }
                   label: {
                           en: "Average Matched Rate"
                           zh: "平均命中速率"
                          }
                  }

    metrics_sql_passed {
                   desc {
                         en: "How much times the SQL is passed"
                         zh: "SQL 通过的次数"
                        }
                   label: {
                           en: "SQL Passed"
                           zh: "SQL 通过"
                          }
                  }

    metrics_sql_failed {
                   desc {
                         en: "How much times the SQL is failed"
                         zh: "SQL 失败的次数"
                        }
                   label: {
                           en: "SQL Failed"
                           zh: "SQL 失败"
                          }
                  }

    metrics_sql_failed_exception {
                   desc {
                         en: "How much times the SQL is failed due to exceptions. This may because of a crash when calling a SQL function, or trying to do arithmetic operation on undefined variables"
                         zh: "SQL 由于执行异常而失败的次数。 这可能是因为调用 SQL 函数时崩溃，或者试图对未定义的变量进行算术运算"
                        }
                   label: {
                           en: "SQL Exception"
                           zh: "SQL 执行异常"
                          }
                  }

    metrics_sql_failed_unknown {
                   desc {
                         en: "How much times the SQL is failed due to an unknown error."
                         zh: "由于未知错误导致 SQL 失败的次数。"
                        }
                   label: {
                           en: "SQL Unknown Error"
                           zh: "SQL 未知错误"
                          }
                  }

    metrics_actions_total {
                   desc {
                         en: "How much times the actions are called by the rule. This value may several times of 'matched', depending on the number of the actions of the rule."
                         zh: "规则调用输出的次数。 该值可能是“sql.matched”的几倍，具体取决于规则输出的数量。"
                        }
                   label: {
                           en: "Action Total"
                           zh: "调用输出次数"
                          }
                  }

    metrics_actions_success {
                   desc {
                         en: "How much times the rule success to call the actions."
                         zh: "规则成功调用输出的次数。"
                        }
                   label: {
                           en: "Success Action"
                           zh: "成功调用输出次数"
                          }
                  }

    metrics_actions_failed {
                   desc {
                         en: "How much times the rule failed to call the actions."
                         zh: "规则调用输出失败的次数。"
                        }
                   label: {
                           en: "Failed Action"
                           zh: "调用输出失败次数"
                          }
                  }

    metrics_actions_failed_out_of_service {
                   desc {
                         en: "How much times the rule failed to call actions due to the action is out of service. For example, a bridge is disabled or stopped."
                         zh: "由于输出停止服务而导致规则调用输出失败的次数。 例如，桥接被禁用或停止。"
                        }
                   label: {
                           en: "Fail Action"
                           zh: "调用输出失败次数"
                          }
                  }

    metrics_actions_failed_unknown {
                   desc {
                         en: "How much times the rule failed to call actions due to to an unknown error."
                         zh: "由于未知错误，规则调用输出失败的次数。"
                        }
                   label: {
                           en: "Fail Action"
                           zh: "调用输出失败次数"
                          }
                  }

    test_context {
                   desc {
                         en: "The context of the event for testing"
                         zh: "测试事件的上下文"
                        }
                   label: {
                           en: "Event Conetxt"
                           zh: "事件上下文"
                          }
                  }

    test_sql {
                   desc {
                         en: "The SQL of the rule for testing"
                         zh: "测试的 SQL"
                        }
                   label: {
                           en: "Test SQL"
                           zh: "测试 SQL"
                          }
                  }

    rs_event {
                   desc {
                         en: "The event topics"
                         zh: "事件主题"
                        }
                   label: {
                           en: "Event Topics"
                           zh: "事件主题"
                          }
                  }

    rs_title {
                   desc {
                         en: "The title"
                         zh: "标题"
                        }
                   label: {
                           en: "Title"
                           zh: "标题"
                          }
                  }

    rs_description {
                   desc {
                         en: "The description"
                         zh: "描述"
                        }
                   label: {
                           en: "Description"
                           zh: "描述"
                          }
                  }

    rs_columns {
                   desc {
                         en: "The columns"
                         zh: "列"
                        }
                   label: {
                           en: "Column"
                           zh: "列"
                          }
                  }

    rs_test_columns {
                   desc {
                         en: "The test columns"
                         zh: "测试列"
                        }
                   label: {
                           en: "Test Columns"
                           zh: "测试列"
                          }
                  }

    rs_sql_example {
                   desc {
                         en: "The sql_example"
                         zh: "SQL 例子"
                        }
                   label: {
                           en: "SQL Example"
                           zh: "SQL 例子"
                          }
                  }

    ri_metrics {
                   desc {
                         en: "The metrics of the rule"
                         zh: "规则的计数器"
                        }
                   label: {
                           en: "Rule Metrics"
                           zh: "规则计数器"
                          }
                  }

    ri_node_metrics {
                   desc {
                         en: "The metrics of the rule for each node"
                         zh: "每个节点的规则计数器"
                        }
                   label: {
                           en: "Each Node Rule Metrics"
                           zh: "每个节点规则计数器"
                          }
                  }

    ri_from {
                   desc {
                         en: "The topics of the rule"
                         zh: "规则指定的主题"
                        }
                   label: {
                           en: "Topics of Rule"
                           zh: "规则指定的主题"
                          }
                  }

    ri_created_at {
                   desc {
                         en: "The created time of the rule"
                         zh: "规则创建时间"
                        }
                   label: {
                           en: "Rule Create Time"
                           zh: "规则创建时间"
                          }
                  }

    root_rule_creation {
                   desc {
                         en: "Schema for creating rules"
                         zh: "用于创建规则的 Schema"
                        }
                   label: {
                           en: "Create Schema"
                           zh: "用于创建规则的 Schema"
                          }
                  }

    root_rule_info {
                   desc {
                         en: "Schema for rule info"
                         zh: "用于规则信息的 Schema"
                        }
                   label: {
                           en: "Info Schema"
                           zh: "用于规则信息的 Schema"
                          }
                  }

    root_rule_events {
                   desc {
                         en: "Schema for rule events"
                         zh: "用于事件的 Schema"
                        }
                   label: {
                           en: "Rule Events Schema"
                           zh: "用于规则事件的 Schema"
                          }
                  }

    root_rule_test {
                   desc {
                         en: "Schema for testing rules"
                         zh: "用于规则测试的 Schema"
                        }
                   label: {
                           en: "Rule Test Schema"
                           zh: "用于规则测试的 Schema"
                          }
                  }

}

emqx_rule_engine_api {

    api1 {
                   desc {
                         en: "List all rules"
                         zh: "列出所有规则"
                        }
                   label: {
                           en: "List All Rules"
                           zh: "列出所有规则"
                          }
                  }
   api1_enable {
                   desc {
                         en: "Filter enable/disable rules"
                         zh: "根据规则是否开启条件过滤"
                        }
                  }

   api1_from {
                   desc {
                         en: "Filter rules by from(topic), exact match"
                         zh: "根据规则来源 Topic 过滤, 需要完全匹配"
                        }
                  }

   api1_like_id {
                   desc {
                         en: "Filter rules by id, Substring matching"
                         zh: "根据规则 id 过滤, 使用子串模糊匹配"
                        }
                  }

   api1_like_from {
                   desc {
                         en: "Filter rules by from(topic), Substring matching"
                         zh: "根据规则来源 Topic 过滤, 使用子串模糊匹配"
                        }
                  }

   api1_like_description {
                   desc {
                         en: "Filter rules by description, Substring matching"
                         zh: "根据规则描述过滤, 使用子串模糊匹配"
                        }
                  }
   api1_match_from {
                   desc {
                         en: "Filter rules by from(topic), Mqtt topic matching"
                         zh: "根据规则来源 Topic 过滤, 使用 MQTT Topic 匹配"
                        }
                  }

    api2 {
                   desc {
                         en: "Create a new rule using given Id"
                         zh: "通过指定 ID 创建规则"
                        }
                   label: {
                           en: "Create Rule By ID"
                           zh: "通过指定 ID 创建规则"
                          }
                  }

    api3 {
                   desc {
                         en: "List all events can be used in rules"
                         zh: "列出所有能被规则使用的事件"
                        }
                   label: {
                           en: "List All Events Can Be Used In Rule"
                           zh: "列出所有能被规则使用的事件"
                          }
                  }

    api4 {
                   desc {
                         en: "Get a rule by given Id"
                         zh: "通过 ID 查询规则"
                        }
                   label: {
                           en: "Get Rule"
                           zh: "查询规则"
                          }
                  }

    api5 {
                   desc {
                         en: "Update a rule by given Id to all nodes in the cluster"
                         zh: "通过 ID 更新集群里所有节点上的规则"
                        }
                   label: {
                           en: "Update Cluster Rule"
                           zh: "更新集群规则"
                          }
                  }

    api6 {
                   desc {
                         en: "Delete a rule by given Id from all nodes in the cluster"
                         zh: "通过 ID 删除集群里所有节点上的规则"
                        }
                   label: {
                           en: "Delete Cluster Rule"
                           zh: "删除集群规则"
                          }
                  }

    api7 {
                   desc {
                         en: "Reset a rule metrics"
                         zh: "重置规则计数"
                        }
                   label: {
                           en: "Reset Rule Metrics"
                           zh: "重置规则计数"
                          }
                  }

    api8 {
                   desc {
                         en: "Test a rule"
                         zh: "测试一个规则"
                        }
                   label: {
                           en: "Test Rule"
                           zh: "测试规则"
                          }
                  }
    desc9 {
                   desc {
                         en: "List of rules"
                         zh: "列出所有规则"
                        }
                   label: {
                           en: "List Rules"
                           zh: "列出所有规则"
                          }
                  }
}

emqx_rule_engine_schema {

    rules_name {
                   desc {
                         en: "The name of the rule"
                         zh: "规则名字"
                        }
                   label: {
                           en: "Rule Name"
                           zh: "规则名字"
                          }
                  }

    rules_sql {
                   desc {
                         en: """
SQL query to transform the messages.
Example: <code>SELECT * FROM "test/topic" WHERE payload.x = 1</code>
"""
                         zh: """
用于处理消息的 SQL 。
示例：<code>SELECT * FROM "test/topic" WHERE payload.x = 1</code>
"""
                        }
                   label: {
                           en: "Rule SQL"
                           zh: "规则 SQL"
                          }
                  }

    rules_actions {
                   desc {
                         en: """
A list of actions of the rule.
An action can be a string that refers to the channel ID of an EMQX bridge, or an object
that refers to a function.
There a some built-in functions like "republish" and "console", and we also support user
provided functions in the format: "{module}:{function}".
The actions in the list are executed sequentially.
This means that if one of the action is executing slowly, all the following actions will not
be executed until it returns.
If one of the action crashed, all other actions come after it will still be executed, in the
original order.
If there's any error when running an action, there will be an error message, and the 'failure'
counter of the function action or the bridge channel will increase.
"""
                         zh: """
规则的动作列表。
动作可以是指向 EMQX bridge 的引用，也可以是一个指向函数的对象。
我们支持一些内置函数，如“republish”和“console”，我们还支持用户提供的函数，它的格式为：“{module}:{function}”。
列表中的动作按顺序执行。这意味着如果其中一个动作执行缓慢，则以下所有动作都不会被执行直到它返回。
如果其中一个动作崩溃，在它之后的所有动作仍然会被按照原始顺序执行。
如果运行动作时出现任何错误，则会出现错误消息，并且相应的计数器会增加。
"""
                        }
                   label: {
                           en: "Rule Action List"
                           zh: "动作列表"
                          }
                  }

    rules_enable {
                   desc {
                         en: "Enable or disable the rule"
                         zh: "启用或禁用规则引擎"
                        }
                   label: {
                           en: "Enable Or Disable Rule"
                           zh: "启用或禁用规则引擎"
                          }
                  }

    rules_metadata {
                   desc {
                         en: "Rule metadata, do not change manually"
                         zh: "规则的元数据，不要手动修改"
                        }
                   label: {
                           en: "Rule metadata"
                           zh: "规则的元数据"
                          }
                  }

    rules_description {
                   desc {
                         en: "The description of the rule"
                         zh: "规则的描述"
                        }
                   label: {
                           en: "Rule Description"
                           zh: "规则描述"
                          }
                  }

    republish_function {
                   desc {
                         en: """Republish the message as a new MQTT message"""
                         zh: """将消息重新发布为新的 MQTT 消息"""
                        }
                   label: {
                           en: "Republish Function"
                           zh: "重新发布函数"
                          }
                  }

    console_function {
                   desc {
                         en: """Print the actions to the console"""
                         zh: "将输出打印到控制台"
                        }
                   label: {
                           en: "Console Function"
                           zh: "控制台函数"
                          }
                  }

    user_provided_function_function {
                   desc {
                         en: """
The user provided function. Should be in the format: '{module}:{function}'.
Where {module} is the Erlang callback module and {function} is the Erlang function.

To write your own function, checkout the function <code>console</code> and
<code>republish</code> in the source file:
<code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example.
"""
                         zh: """
用户提供的函数。 格式应为：'{module}:{function}'。
其中 {module} 是 Erlang 回调模块， {function} 是 Erlang 函数。
要编写自己的函数，请检查源文件：<code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> 中的示例函数 <code>console</code> 和<code>republish</code> 。
"""
                        }
                   label: {
                           en: "User Provided Function"
                           zh: "用户提供的函数"
                          }
                  }

    user_provided_function_args {
                   desc {
                         en: """
The args will be passed as the 3rd argument to module:function/3,
checkout the function <code>console</code> and <code>republish</code> in the source file:
<code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example.
"""
                         zh: """
用户提供的参数将作为函数 module:function/3 的第三个参数，
请检查源文件：<code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> 中的示例函数 <code>console</code> 和<code>republish</code> 。
"""
                        }
                   label: {
                           en: "User Provided Function Args"
                           zh: "用户提供函数的参数"
                          }
                  }

    republish_args_topic {
                   desc {
                         en: """
The target topic of message to be re-published.
Template with variables is allowed, see description of the 'republish_args'.
"""
                         zh: """
重新发布消息的目标主题。
允许使用带有变量的模板，请参阅“republish_args”的描述。
"""
                        }
                   label: {
                           en: "Target Topic"
                           zh: "目标主题"
                          }
                  }

    republish_args_qos {
                   desc {
                         en: """
The qos of the message to be re-published.
Template with variables is allowed, see description of the 'republish_args'.
Defaults to ${qos}. If variable ${qos} is not found from the selected result of the rule,
0 is used.
"""
                         zh: """
要重新发布的消息的 qos。允许使用带有变量的模板，请参阅“republish_args”的描述。
默认为 ${qos}。 如果从规则的选择结果中没有找到变量 ${qos}，则使用 0。
"""
                        }
                   label: {
                           en: "Message QoS"
                           zh: "消息 QoS 等级"
                          }
                  }

    republish_args_retain {
                   desc {
                         en: """
The 'retain' flag of the message to be re-published.
Template with variables is allowed, see description of the 'republish_args'.
Defaults to ${retain}. If variable ${retain} is not found from the selected result
of the rule, false is used.
"""
                         zh: """
要重新发布的消息的“保留”标志。允许使用带有变量的模板，请参阅“republish_args”的描述。
默认为 ${retain}。 如果从所选结果中未找到变量 ${retain}，则使用 false。
"""
                        }
                   label: {
                           en: "Retain Flag"
                           zh: "保留消息标志"
                          }
                  }

    republish_args_payload {
                   desc {
                         en: """
The payload of the message to be re-published.
Template with variables is allowed, see description of the 'republish_args'.
Defaults to ${payload}. If variable ${payload} is not found from the selected result
of the rule, then the string "undefined" is used.
"""
                         zh: """
要重新发布的消息的有效负载。允许使用带有变量的模板，请参阅“republish_args”的描述。
默认为 ${payload}。 如果从所选结果中未找到变量 ${payload}，则使用字符串 "undefined"。
"""
                        }
                   label: {
                           en: "Message Payload"
                           zh: "消息负载"
                          }
                  }
    republish_args_user_properties {
        desc {
            en: """
From which variable should the MQTT message's User-Property pairs be taken from.
The value must be a map.
You may configure it to <code>${pub_props.'User-Property'}</code> or
use <code>SELECT *,pub_props.'User-Property' as user_properties</code>
to forward the original user properties to the republished message.
You may also call <code>map_put</code> function like
<code>map_put('my-prop-name', 'my-prop-value', user_properties) as user_properties</code>
to inject user properties.
NOTE: MQTT spec allows duplicated user property names, but EMQX Rule-Engine does not.
"""
            zh: """
指定使用哪个变量来填充 MQTT 消息的 User-Property 列表。这个变量的值必须是一个 map 类型。
可以设置成 <code>${pub_props.'User-Property'}</code> 或者
使用 <code>SELECT *,pub_props.'User-Property' as user_properties</code> 来把源 MQTT 消息
的 User-Property 列表用于填充。
也可以使用 <code>map_put</code> 函数来添加新的 User-Property，
<code>map_put('my-prop-name', 'my-prop-value', user_properties) as user_properties</code>
注意：MQTT 协议允许一个消息中出现多次同一个 property 名，但是 EMQX 的规则引擎不允许。
"""
        }
    }

    rule_engine_ignore_sys_message {
                   desc {
                         en: "When set to 'true' (default), rule-engine will ignore messages published to $SYS topics."
                         zh: "当设置为“true”（默认）时，规则引擎将忽略发布到 $SYS 主题的消息。"
                        }
                   label: {
                           en: "Ignore Sys Message"
                           zh: "忽略系统消息"
                          }
                  }

    rule_engine_rules {
                   desc {
                         en: """The rules"""
                         zh: "规则"
                        }
                   label: {
                           en: "Rules"
                           zh: "规则"
                          }
                  }

    rule_engine_jq_function_default_timeout {
      desc {
          en: "Default timeout for the `jq` rule engine function"
          zh: "规则引擎内建函数 `jq` 默认时间限制"
      }
      label: {
          en: "Rule engine jq function default timeout"
          zh: "规则引擎 jq 函数时间限制"
      }
    }

    rule_engine_jq_implementation_module {
      desc {
          en: "The implementation module for the jq rule engine function. The two options are jq_nif and jq_port. With the jq_nif option an Erlang NIF library is used while with the jq_port option an implementation based on Erlang port programs is used. The jq_nif option (the default option) is the fastest implementation of the two but jq_port is safer as the jq programs will not execute in the same process as the Erlang VM."
          zh: "jq 规则引擎功能的实现模块。可用的两个选项是 jq_nif 和 jq_port。jq_nif 使用 Erlang NIF 库访问 jq 库，而 jq_port 使用基于 Erlang Port 的实现。jq_nif 方式（默认选项）是这两个选项中最快的实现，但 jq_port 方式更安全，因为这种情况下 jq 程序不会在 Erlang VM 进程中执行。"
      }
      label: {
          en: "JQ Implementation Module"
          zh: "JQ 实现模块"
      }
    }

    desc_rule_engine {
                   desc {
                         en: """Configuration for the EMQX Rule Engine."""
                         zh: """配置 EMQX 规则引擎。"""
                        }
                   label: {
                           en: "Rule Engine Configuration"
                           zh: "配置规则引擎"
                          }
                  }

    desc_rules {
                   desc {
                         en: """Configuration for a rule."""
                         zh: """配置规则"""
                        }
                   label: {
                           en: "Rule Configuration"
                           zh: "配置规则"
                          }
                  }

    desc_builtin_action_republish {
                   desc {
                         en: """Configuration for a built-in action."""
                         zh: """配置重新发布。"""
                        }
                   label: {
                           en: "Republish Configuration"
                           zh: "配置重新发布"
                          }
                  }

    desc_builtin_action_console {
                   desc {
                         en: """Configuration for a built-in action."""
                         zh: """配置打印到控制台"""
                        }
                   label: {
                           en: "Action Console Configuration"
                           zh: "配置打印到控制台"
                          }
                  }

    desc_user_provided_function {
                   desc {
                         en: """Configuration for a built-in action."""
                         zh: """配置用户函数"""
                        }
                   label: {
                           en: "User Provid Function Configuration"
                           zh: "配置用户函数"
                          }
                  }

    desc_republish_args {
                   desc {
                         en: """The arguments of the built-in 'republish' action.One can use variables in the args.
The variables are selected by the rule. For example, if the rule SQL is defined as following:
<code>
    SELECT clientid, qos, payload FROM "t/1"
</code>
Then there are 3 variables available: <code>clientid</code>, <code>qos</code> and
<code>payload</code>. And if we've set the args to:
<code>
    {
        topic = "t/${clientid}"
        qos = "${qos}"
        payload = "msg: ${payload}"
    }
</code>
When the rule is triggered by an MQTT message with payload = `hello`, qos = 1,
clientid = `Steve`, the rule will republish a new MQTT message to topic `t/Steve`,
payload = `msg: hello`, and `qos = 1`."""
                         zh: """
内置 'republish' 动作的参数。
可以在参数中使用变量。
变量是规则中选择的字段。 例如规则 SQL 定义如下：
<code>
    SELECT clientid, qos, payload FROM "t/1"
</code>
然后有 3 个变量可用：<code>clientid</code>、<code>qos</code> 和 <code>payload</code>。 如果我们将参数设置为：
<code>
    {
        topic = "t/${clientid}"
        qos = "${qos}"
        payload = "msg: ${payload}"
    }
</code>
当收到一条消息 payload = `hello`, qos = 1, clientid = `Steve` 时，将重新发布一条新的 MQTT 消息到主题 `t/Steve`
消息内容为 payload = `msg: hello`, and `qos = 1"""
                        }
                   label: {
                           en: "Republish Args"
                           zh: "重新发布参数"
                          }
                  }

}

emqx_retainer_api {

  get_config_api {
    desc {
      en: "View config"
      zh: "查看配置内容"
      }
    }

  config_content {
    desc {
      en: "The config content"
      zh: "配置内容"
      }
    }

  config_not_found {
    desc {
      en: "Config not found."
      zh: "配置不存在"
      }
    }

  update_retainer_api {
    desc {
      en: "Update retainer config."
      zh: "更新配置"
      }
    }

  update_config_success {
    desc {
      en: "Update configs successfully."
      zh: "配置更新成功"
      }
    }

  update_config_failed {
    desc {
      en: "Update config failed"
      zh: "配置更新失败"
      }
    }

  list_retained_api {
    desc {
      en: "List retained messages."
      zh: "查看保留消息列表"
      }
    }

  retained_list {
    desc {
      en: "Retained messages list."
      zh: "保留消息列表"
      }
    }

  unsupported_backend {
    desc {
      en: "Unsupported backend."
      zh: "不支持的后端"
      }
    }

  lookup_api {
    desc {
      en: "Lookup a message by a topic without wildcards."
      zh: "通过不带通配符的主题查看对应的保留消息"
      }
    }

  message_detail {
    desc {
      en: "Details of the message."
      zh: "消息详情"
      }
    }

  message_not_exist {
    desc {
      en: "Viewed message doesn't exist."
      zh: "消息不存在"
      }
    }

  delete_matching_api {
    desc {
      en: "Delete matching messages."
      zh: "删除对应的消息"
      }
    }

  topic {
    desc {
      en: "Topic."
      zh: "主题"
      }
    }

  msgid {
    desc {
      en: "Message ID."
      zh: "消息 ID"
      }
    }

  qos {
    desc {
      en: "QoS."
      zh: "QoS"
      }
    }

  publish_at {
    desc {
      en: "Message publish time, RFC 3339 format."
      zh: "消息发送时间, RFC 3339 格式"
      }
    }

  from_clientid {
    desc {
      en: "The clientid of publisher."
      zh: "发布者的 ClientID"
      }
    }

  from_username {
    desc {
      en: "The username of publisher."
      zh: "发布者的用户名"
      }
    }

  payload {
    desc {
      en: "Payload."
      zh: "消息内容"
      }
    }

}

emqx_retainer_schema {

  enable {
    desc {
      en: "Enable retainer feature"
      zh: "是否开启消息保留功能"
      }
    }

  msg_expiry_interval {
    desc {
      en: "Message retention time. 0 means message will never be expired."
      zh: "消息保留时间。0 代表永久保留"
      }
    }

  flow_control {
    desc {
      en: "Flow control."
      zh: "流控设置"
      }
    }

  msg_clear_interval {
    desc {
      en: """Periodic interval for cleaning up expired messages.
Never clear if the value is 0.
      """
      zh: "消息清理间隔。0 代表不进行清理"
      }
    }

  max_payload_size {
    desc {
      en: "Maximum retained message size."
      zh: "消息大小最大值"
      }
    }

  stop_publish_clear_msg {
    desc {
      en: """When the retained flag of the `PUBLISH` message is set and Payload is empty,
whether to continue to publish the message.
See:
http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038"""
      zh: """是否不发送保留消息的清理消息，在 MQTT 5.0 中如果一条保留消息的消息体为空，则会清除掉之前存储
的对应的保留消息，通过这个值控制是否停止发送清理消息"""
      }
    }

  backend {
    desc {
      en: "Settings for the database storing the retained messages."
      zh: "保留消息的存储后端"
      }
    }

  mnesia_config_type {
    desc {
      en: "Backend type."
      zh: "后端类型"
      }
    }

  mnesia_config_storage_type {
    desc {
      en: "Specifies whether the messages are stored in RAM or persisted on disc."
      zh: "选择消息是存放在磁盘还是内存中"
      }
    }

  max_retained_messages {
    desc {
      en: "Maximum number of retained messages. 0 means no limit."
      zh: "消息保留的数量上限。0 表示无限"
      }
    }

  batch_read_number {
    desc {
      en: "Size of the batch when reading messages from storage. 0 means no limit."
      zh: "从存储后端批量加载时的每批数量上限，0 代表一次性读取"
      }
    }

  batch_deliver_number {
    desc {
      en: "The number of retained messages can be delivered per batch."
      zh: "批量派发时每批的数量。0 代表一次性全部派发"
      }
    }

  batch_deliver_limiter {
    desc {
      en: """The rate limiter name for retained messages' delivery.
Limiter helps to avoid delivering too many messages to the client at once, which may cause the client to block or crash, or drop messages due to exceeding the size of the message queue.
The names of the available rate limiters are taken from the existing rate limiters under `limiter.batch`.
If this field is empty, limiter is not used."""
      zh: """批量发送的限流器的名称。
限流器可以用来防止短时间内向客户端发送太多的消息，从而避免过多的消息导致客户端队列堵塞甚至崩溃。
这个名称需要是指向 `limiter.batch` 下的一个真实存在的限流器。
如果这个字段为空，则不使用限流器。
      """
      }
    }

}

emqx_psk_schema {

  psk_authentication {
    desc {
      en: """PSK stands for 'Pre-Shared Keys'.
This config to enable TLS-PSK authentication.

Important! Make sure the SSL listener with only <code>tlsv1.2</code> enabled, and also PSK cipher suites
configured, such as <code>RSA-PSK-AES256-GCM-SHA384</code>.

See listener SSL options config for more details.

The IDs and secrets can be provided from a file which is configurable by the <code>init_file</code> field.
"""
      zh: """此配置用于启用 TLS-PSK 身份验证。

PSK 是 “Pre-Shared-Keys” 的缩写。

注意: 确保 SSL 监听器仅启用了 'tlsv1.2'，并且配置了PSK 密码套件，例如 'RSA-PSK-AES256-GCM-SHA384'。

可以通过查看监听器中的 SSL 选项，了解更多详细信息。

可以通过配置 'init_file' 来设置初始化的 ID 和 密钥"""
      }
    }

  enable {
    desc {
      en: "Whether to enable TLS PSK support"
      zh: "是否开启 TLS PSK 支持"
      }
    }

  init_file {
    desc {
      en: """If init_file is specified, EMQX will import PSKs from the file into the built-in database at startup for use by the runtime.
The file has to be structured line-by-line, each line must be in the format of <code>PSKIdentity:SharedSecret</code>.
For example: <code>mydevice1:c2VjcmV0</code>"""
      zh: """如果设置了初始化文件，EMQX 将在启动时从初始化文件中导入 PSK 信息到内建数据库中。
这个文件需要按行进行组织，每一行必须遵守如下格式: <code>PSKIdentity:SharedSecret</code>
例如: <code>mydevice1:c2VjcmV0</code>"""
      }
    }

  separator {
    desc {
      en: "The separator between <code>PSKIdentity</code> and <code>SharedSecret</code> in the PSK file"

      zh: "PSK 文件中 <code>PSKIdentity</code> 和 <code>SharedSecret</code> 之间的分隔符"
      }
    }

  chunk_size {
    desc {
      en: "The size of each chunk used to import to the built-in database from PSK file"
      zh: "将 PSK 文件导入到内建数据时每个块的大小"
      }
    }

}

emqx_prometheus_schema {

  prometheus {
    desc {
      en: """Settings for reporting metrics to Prometheus"""
      zh: """Prometheus 监控数据推送"""
    }
    label {
      en: """Prometheus"""
      zh: """Prometheus"""
    }
  }

  push_gateway_server {
    desc {
      en: """URL of Prometheus server"""
      zh: """Prometheus 服务器地址"""
    }
  }

  interval {
    desc {
      en: """Data reporting interval"""
      zh: """数据推送间隔"""
    }
  }
  enable {
    desc {
      en: """Turn Prometheus data pushing on or off"""
      zh: """开启或关闭 Prometheus 数据推送"""
    }
  }
  vm_dist_collector {
    desc {
      en: """Enable or disable VM distribution collector, collects information about the sockets and processes involved in the Erlang distribution mechanism."""
      zh: """开启或关闭 VM 分布采集器，收集 Erlang 分布机制中涉及的套接字和进程的信息。"""
    }
  }
  mnesia_collector {
    desc {
      en: """Enable or disable Mnesia collector, collects Mnesia metrics mainly using mnesia:system_info/1 ."""
      zh: """开启或关闭 Mnesia 采集器, 使用 mnesia:system_info/1 收集 Mnesia 相关指标"""
    }
  }
  vm_statistics_collector {
    desc {
      en: """Enable or disable VM statistics collector, collects Erlang VM metrics using erlang:statistics/1 ."""
      zh: """开启或关闭 VM 统计采集器, 使用 erlang:statistics/1 收集 Erlang VM 相关指标"""
    }
  }

  vm_system_info_collector {
    desc {
      en: """Enable or disable VM system info collector, collects Erlang VM metrics using erlang:system_info/1 ."""
      zh: """开启或关闭 VM 系统信息采集器, 使用 erlang:system_info/1 收集 Erlang VM 相关指标"""
    }
  }
  vm_memory_collector {
    desc {
      en: """Enable or disable VM memory collector, collects information about memory dynamically allocated by the Erlang emulator using erlang:memory/0 , also provides basic (D)ETS statistics ."""
      zh: """开启或关闭 VM 内存采集器, 使用 erlang:memory/0 收集 Erlang 虚拟机动态分配的内存信息，同时提供基本的 (D)ETS 统计信息"""
    }
    }
  vm_msacc_collector {
    desc {
      en: """Enable or disable VM msacc collector, collects microstate accounting metrics using erlang:statistics(microstate_accounting) ."""
      zh: """开启或关闭 VM msacc 采集器, 使用 erlang:statistics(microstate_accounting) 收集微状态计数指标"""
    }
  }
}

emqx_plugins_schema {
  plugins {
    desc {
      en: """
Manage EMQX plugins.<br/>
Plugins can be pre-built as a part of EMQX package,
or installed as a standalone package in a location specified by
<code>install_dir</code> config key<br/>
The standalone-installed plugins are referred to as 'external' plugins.
"""
      zh: """管理EMQX插件。<br/>
插件可以是EMQX安装包中的一部分，也可以是一个独立的安装包。<br/>
独立安装的插件称为“外部插件”。
           """
    }
    label {
      en: "Plugins"
      zh: "插件"
    }
  }
  state {
    desc {
      en: "A per-plugin config to describe the desired state of the plugin."
      zh: "描述插件的状态"
    }
    label {
      en: "State"
      zh: "插件状态"
    }
  }
  name_vsn {
    desc {
      en: """The {name}-{version} of the plugin.<br/>
It should match the plugin application name-version as the for the plugin release package name<br/>
For example: my_plugin-0.1.0.
"""
      zh: """插件的名称{name}-{version}。<br/>
它应该与插件的发布包名称一致，如my_plugin-0.1.0。"""
    }
    label {
      en: "Name-Version"
      zh: "名称-版本"
    }
  }
  enable {
    desc {
      en: "Set to 'true' to enable this plugin"
      zh: "设置为“true”以启用此插件"
    }
    label {
      en: "Enable"
      zh: "启用"
    }
  }
  states {
    desc {
      en: """An array of plugins in the desired states.<br/>
The plugins are started in the defined order"""
      zh: """一组插件的状态。插件将按照定义的顺序启动"""
    }
    label {
      en: "States"
      zh: "插件启动顺序及状态"
    }
  }
  install_dir {
    desc {
      en: """
The installation directory for the external plugins.
The plugin beam files and configuration files should reside in
the subdirectory named as <code>emqx_foo_bar-0.1.0</code>.
<br/>
NOTE: For security reasons, this directory should **NOT** be writable
by anyone except <code>emqx</code> (or any user which runs EMQX).
"""
      zh: "插件安装包的目录，出于安全考虑，该目录应该值允许 <code>emqx</code>，或用于运行 EMQX 服务的用户拥有写入权限。"
    }
    label {
      en: "Install Directory"
      zh: "安装目录"
    }
  }
  check_interval {
    desc {
      en: """Check interval: check if the status of the plugins in the cluster is consistent, <br/>
if the results of 3 consecutive checks are not consistent, then alarm.
"""
      zh: """检查间隔：检查集群中插件的状态是否一致，<br/>
如果连续3次检查结果不一致，则报警。
"""
    }
  }
}

emqx_delayed_api {

  view_status_api {
    desc {
      en: "Get delayed status"
      zh: "查看慢订阅状态"
    }
  }

  update_api {
    desc {
      en: "Enable or disable delayed, set max delayed messages"
      zh: "开启或者关闭功能，或者设置延迟消息数量上限"
    }
  }

  update_success {
    desc {
      en: "Enable or disable delayed successfully"
      zh: "开启或者关闭功能操作成功"
    }
  }

  illegality_limit {
    desc {
      en: "Max limit illegality"
      zh: "数量上限不合法"
    }
  }

  get_message_api {
    desc {
      en: "View delayed message"
      zh: "查看延迟消息"
    }
  }

  node {
    desc {
      en: "The node where message from"
      zh: "消息的来源节点"
    }
  }

  msgid {
    desc {
      en: "Delayed Message ID"
      zh: "延迟消息 ID"
    }
  }

  bad_msgid_format {
    desc {
      en: "Bad Message ID format"
      zh: "消息 ID 格式错误"
    }
  }

  msgid_not_found {
    desc {
      en: "Message ID not found"
      zh: "未找到对应消息"
    }
  }

  delete_api {
    desc {
      en: "Delete delayed message"
      zh: "删除延迟消息"
    }
  }

  list_api {
    desc {
      en: "List delayed messages"
      zh: "查看延迟消息列表"
    }
  }

  view_page {
    desc {
      en: "View page"
      zh: "查看的页数"
    }
  }

  view_limit {
    desc {
      en: "Page limit"
      zh: "每页数量"
    }
  }

  count {
    desc {
      en: "Count of delayed messages"
      zh: "延迟消息总数"
    }
  }

  publish_at {
    desc {
      en: "Clinet publish message time, in RFC 3339 format"
      zh: "客户端发送时间, RFC 3339 格式"
    }
  }

  delayed_interval {
    desc {
      en: "Delayed interval(second)"
      zh: "延迟时间(秒)"
    }
  }

  delayed_remaining {
    desc {
      en: "Delayed remaining(second)"
      zh: "剩余时间(秒)"
    }
  }

  expected_at {
    desc {
      en: "Expect publish time, in RFC 3339 format"
      zh: "期望的发送时间, RFC 3339 格式"
    }
  }

  topic {
    desc {
      en: "Topic"
      zh: "主题"
    }
  }

  qos {
    desc {
      en: "QoS"
      zh: "QoS"
    }
  }

  from_clientid {
    desc {
      en: "From ClientID"
      zh: "消息的 ClientID"
    }
  }

  from_username {
    desc {
      en: "From Username"
      zh: "消息的 Username"
    }
  }

  payload {
    desc {
      en: "Payload, base64 encoded. Payload will be set to 'PAYLOAD_TO_LARGE' if its length is larger than 2048 bytes"
      zh: "消息内容, base64 格式。如果消息的大小超过 2048 字节，则消息内容会被设置为 'PAYLOAD_TO_LARGE'"
    }
  }

}

emqx_modules_schema {

  rewrite {
    desc {
      en: """The topic rewriting function of EMQX supports rewriting topic A to topic B when the client subscribes to topics, publishes messages, and cancels subscriptions according to user-configured rules.
Each rewrite rule consists of three parts: subject filter, regular expression, and target expression.
Under the premise that the subject rewriting function is enabled, when EMQX receives a subject-based MQTT message such as a `PUBLISH` message,
it will use the subject of the message to sequentially match the subject filter part of the rule in the configuration file. If the match is successful,
the regular expression is used to extract the information in the subject, and then replaced with the target expression to form a new subject.
Variables in the format of `$N` can be used in the target expression to match the elements extracted from the regular expression.
The value of `$N` is the Nth element extracted from the regular expression. For example, `$1` is the regular expression. The first element extracted by the expression.
It should be noted that EMQX uses reverse order to read the rewrite rules in the configuration file.
When a topic can match the topic filter of multiple topic rewrite rules at the same time, EMQX will only use the first rule it matches. Rewrite.
If the regular expression in this rule does not match the subject of the MQTT message, the rewriting will fail, and no other rules will be attempted for rewriting.
Therefore, users need to carefully design MQTT message topics and topic rewriting rules when using them."""
      zh: """EMQX 的主题重写功能支持根据用户配置的规则在客户端订阅主题、发布消息、取消订阅的时候将 A 主题重写为 B 主题。
重写规则分为 Pub 规则和 Sub 规则，Pub 规则匹配 PUSHLISH 报文携带的主题，Sub 规则匹配 SUBSCRIBE、UNSUBSCRIBE 报文携带的主题。
每条重写规则都由主题过滤器、正则表达式、目标表达式三部分组成。
在主题重写功能开启的前提下，EMQX 在收到诸如 PUBLISH 报文等带有主题的 MQTT 报文时，将使用报文中的主题去依次匹配配置文件中规则的主题过滤器部分，一旦成功匹配，则使用正则表达式提取主题中的信息，然后替换至目标表达式以构成新的主题。
目标表达式中可以使用 `$N` 这种格式的变量匹配正则表达中提取出来的元素，`$N` 的值为正则表达式中提取出来的第 N 个元素，比如 `$1` 即为正则表达式提取的第一个元素。
需要注意的是，EMQX 使用倒序读取配置文件中的重写规则，当一条主题可以同时匹配多条主题重写规则的主题过滤器时，EMQX 仅会使用它匹配到的第一条规则进行重写，如果该条规则中的正则表达式与 MQTT 报文主题不匹配，则重写失败，不会再尝试使用其他的规则进行重写。
因此用户在使用时需要谨慎的设计 MQTT 报文主题以及主题重写规则。"""
    }
    label {
      en: """Topic Rewrite"""
      zh: """主题重写"""
    }
  }

  tr_source_topic {
    desc {
      en: """Source topic, specified by the client."""
      zh: """源主题，客户端业务指定的主题"""
    }
    label {
      en: """Source Topic"""
      zh: """源主题"""
    }
  }

  tr_action {
    desc {
      en: """Topic rewriting takes effect on the type of operation:
  - `subscribe`: Rewrite topic when client do subscribe.
  - `publish`: Rewrite topic when client do publish.
  - `all`: Both"""

      zh: """主题重写在哪种操作上生效：
  - `subscribe`：订阅时重写主题；
  - `publish`：发布时重写主题；
  -`all`：全部重写主题"""
    }
    label {
      en: """Action"""
      zh: """Action"""
    }
  }

  tr_re {
    desc {
      en: """Regular expressions"""
      zh: """正则表达式"""
    }
  }

  tr_dest_topic {
    desc {
      en: """Destination topic."""
      zh: """目标主题。"""
    }
    label {
      en: """Destination Topic"""
      zh: """目标主题"""
    }
  }

  enable {
    desc {
      en: "Enable this feature"
      zh: "是否开启该功能"
    }
  }

  max_delayed_messages {
    desc {
      en: "Maximum number of delayed messages (0 is no limit)."
      zh: "延迟消息的数量上限(0 代表无限)"
    }
  }
}

emqx_rewrite_api {

  list_topic_rewrite_api {
    desc {
      en: """List all rewrite rules"""
      zh: """列出全部主题重写规则"""
    }
  }

  update_topic_rewrite_api {
    desc {
      en: """Update all rewrite rules"""
      zh: """更新全部主题重写规则"""
    }
  }


  update_topic_rewrite_api_response413 {
    desc {
      en: """Rules count exceed max limit"""
      zh: """超出主题重写规则数量上限"""
    }
  }

}

emqx_telemetry_api {

  get_telemetry_status_api {
    desc {
      en: """Get telemetry status"""
      zh: """获取遥测状态"""
    }
  }

  update_telemetry_status_api {
    desc {
      en: """Enable or disable telemetry"""
      zh: """更新遥测状态"""
    }
  }

  get_telemetry_data_api {
    desc {
      en: """Get telemetry data"""
      zh: """获取遥测数据"""
    }
  }

  enable {
    desc {
      en: """Enable telemetry"""
      zh: """启用遥测"""
    }
  }

  emqx_version {
    desc {
      en: """Get emqx version"""
      zh: """获取 emqx 版本"""
    }
  }

  license {
    desc {
      en: """Get license information"""
      zh: """获取 license 信息"""
    }
  }

  os_name {
    desc {
      en: """Get OS name"""
      zh: """获取操作系统名称"""
    }
  }

    os_version {
        desc {
        en: """Get OS version"""
        zh: """获取操作系统版本"""
        }
    }

    otp_version {
        desc {
        en: """Get Erlang OTP version"""
        zh: """获取 OTP 版本"""
        }
    }

    up_time {
        desc {
        en: """Get uptime"""
        zh: """获取运行时间"""
        }
    }

    uuid {
        desc {
        en: """Get UUID"""
        zh: """获取 UUID"""
        }
    }

    nodes_uuid {
        desc {
        en: """Get nodes UUID"""
        zh: """获取节点 UUID"""
        }
    }

    active_plugins {
        desc {
        en: """Get active plugins"""
        zh: """获取活跃插件"""
        }
    }

    active_modules {
        desc {
        en: """Get active modules"""
        zh: """获取活跃模块"""
        }
    }

    num_clients {
        desc {
        en: """Get number of clients"""
        zh: """获取客户端数量"""
        }
    }

    messages_received {
        desc {
        en: """Get number of messages received"""
        zh: """获取接收到的消息数量"""
        }
    }

    messages_sent {
        desc {
        en: """Get number of messages sent"""
        zh: """获取发送的消息数量"""
        }
    }
}

emqx_topic_metrics_api {
  get_topic_metrics_api {
    desc {
      en: """List Topic metrics"""
      zh: """获取主题监控数据"""
    }
  }

  reset_topic_metrics_api{
    desc {
      en: """Reset telemetry status"""
      zh: """重置主题监控状态"""
    }
  }

  post_topic_metrics_api {
    desc {
      en: """Create Topic metrics"""
      zh: """创建主题监控数据"""
    }
  }

  gat_topic_metrics_data_api {
    desc {
      en: """Get Topic metrics"""
      zh: """获取主题监控数据"""
    }
  }

  delete_topic_metrics_data_api {
    desc {
      en: """Delete Topic metrics"""
      zh: """删除主题监控数据"""
    }
  }

  topic_metrics_api_response409 {
    desc {
      en: """Conflict. Topic metrics exceeded max limit 512"""
      zh: """冲突。主题监控数据超过最大限制512"""
    }
  }

  topic_metrics_api_response400 {
    desc {
      en: """Bad Request. Already exists or bad topic name"""
      zh: """错误请求。已存在或错误的主题名称"""
    }
  }

   topic_metrics_api_response404 {
    desc {
      en: """Not Found. Topic metrics not found"""
      zh: """未找到。主题监控数据未找到"""
    }
   }

  reset_topic_desc {
      en: """Topic Name. If this parameter is not present,all created topic metrics will be reset."""
      zh: """主题名称。如果此参数不存在，则所有创建的主题监控数据都将重置。"""
    }

  topic {
      desc {
        en: """Topic"""
        zh: """主题"""
      }
  }

  topic_in_body {
    desc {
      en: """Raw topic string"""
      zh: """主题字符串"""
    }
  }

  topic_in_path {
    desc {
      en: """Topic string. Notice: Topic string in url path must be encoded"""
      zh: """主题字符串。注意：主题字符串在url路径中必须编码"""
    }
  }

  action {
      desc {
        en: """Action. Only support reset"""
        zh: """操作，仅支持 reset"""
      }
  }

  create_time {
      desc {
        en: """Create time"""
        zh: """创建时间。标准 rfc3339 时间格式，例如：2018-01-01T12:00:00Z"""
      }
  }

  reset_time {
      desc {
        en: """Reset time. In rfc3339. Nullable if never reset"""
        zh: """重置时间。标准 rfc3339 时间格式，例如：2018-01-01T12:00:00Z。如果从未重置则为空"""
      }
  }

  metrics {
      desc {
        en: """Metrics"""
        zh: """监控数据"""
      }
  }

  message_dropped_count {
      desc {
          en: """Dropped messages count"""
          zh: """丢弃消息数量"""
      }
    }

  message_dropped_rate {
      desc {
          en: """Dropped messages rate"""
          zh: """丢弃消息速率"""
      }
    }

  message_in_count {
      desc {
          en: """In messages count"""
          zh: """接收消息数量"""
      }
    }

    message_in_rate {
        desc {
            en: """In messages rate"""
            zh: """接收消息速率"""
        }
    }

    message_out_count {
        desc {
            en: """Out messages count"""
            zh: """发送消息数量"""
        }
    }

    message_out_rate {
        desc {
            en: """Out messages rate"""
            zh: """发送消息速率"""
        }
    }

    message_qos0_in_count {
        desc {
            en: """QoS0 in messages count"""
            zh: """QoS0 接收消息数量"""
        }
    }

    message_qos0_in_rate {
        desc {
            en: """QoS0 in messages rate"""
            zh: """QoS0 接收消息速率"""
        }
    }

    message_qos0_out_count {
        desc {
            en: """QoS0 out messages count"""
            zh: """QoS0 发送消息数量"""
        }
    }

    message_qos0_out_rate {
        desc {
            en: """QoS0 out messages rate"""
            zh: """QoS0 发送消息速率"""
        }
    }

    message_qos1_in_count {
        desc {
            en: """QoS1 in messages count"""
            zh: """QoS1 接收消息数量"""
        }
    }

    message_qos1_in_rate {
        desc {
            en: """QoS1 in messages rate"""
            zh: """QoS1 接收消息速率"""
        }
    }

    message_qos1_out_count {
        desc {
            en: """QoS1 out messages count"""
            zh: """QoS1 发送消息数量"""
        }
    }

    message_qos1_out_rate {
        desc {
            en: """QoS1 out messages rate"""
            zh: """QoS1 发送消息速率"""
        }
    }

    message_qos2_in_count {
        desc {
            en: """QoS2 in messages count"""
            zh: """QoS2 接收消息数量"""
        }
    }

    message_qos2_in_rate {
        desc {
            en: """QoS2 in messages rate"""
            zh: """QoS2 接收消息速率"""
        }
    }

    message_qos2_out_count {
        desc {
            en: """QoS2 out messages count"""
            zh: """QoS2 发送消息数量"""
        }
    }

    message_qos2_out_rate {
        desc {
            en: """QoS2 out messages rate"""
            zh: """QoS2 发送消息速率"""
        }
    }

}

emqx_mgmt_api_alarms {

    list_alarms_api {
        desc {
            en: """List currently activated alarms or historical alarms, determined by query parameters."""
            zh: """列出当前激活的告警或历史告警，由查询参数决定。"""
        }
    }

    delete_alarms_api {
        desc {
            en: """Remove all historical alarms."""
            zh: """删除所有历史告警。"""
        }
    }

    delete_alarms_api_response204 {
        desc {
            en: """Historical alarms have been cleared successfully."""
            zh: """历史告警已成功清除。"""
        }
    }

    get_alarms_qs_activated {
        desc {
            en: """It is used to specify the alarm type of the query.
When true, it returns the currently activated alarm,
and when it is false, it returns the historical alarm.
The default is false."""
            zh: """用于指定查询的告警类型，
为 true 时返回当前激活的告警，为 false 时返回历史告警，默认为 false。"""
        }
    }

    node {
        desc {
            en: """The name of the node that triggered this alarm."""
            zh: """触发此告警的节点名称。"""
        }
    }

    name {
        desc {
            en: """Alarm name, used to distinguish different alarms."""
            zh: """告警名称，用于区分不同的告警。"""
        }
    }

    message {
        desc {
            en: """Alarm message, which describes the alarm content in a human-readable format."""
            zh: """告警消息，以人类可读的方式描述告警内容。"""
        }
    }

    details {
        desc {
            en: """Alarm details, provides more alarm information, mainly for program processing."""
            zh: """告警详情，提供了更多的告警信息，主要提供给程序处理。"""
        }
    }

    duration {
        desc {
            en: """Indicates how long the alarm has lasted, in milliseconds."""
            zh: """表明告警已经持续了多久，单位：毫秒。"""
        }
    }

    activate_at {
        desc {
            en: """Alarm start time, using rfc3339 standard time format."""
            zh: """告警开始时间，使用 rfc3339 标准时间格式。"""
        }
    }

    deactivate_at {
        desc {
            en: """Alarm end time, using rfc3339 standard time format."""
            zh: """告警结束时间，使用 rfc3339 标准时间格式。"""
        }
    }

}

emqx_mgmt_api_banned {

    list_banned_api {
        desc {
            en: """List all currently banned client IDs, usernames and IP addresses."""
            zh: """列出目前所有被封禁的客户端 ID、用户名和 IP 地址。"""
        }
    }

    create_banned_api {
        desc {
            en: """Add a client ID, username or IP address to the blacklist."""
            zh: """添加一个客户端 ID、用户名或者 IP 地址到黑名单。"""
        }
    }

    create_banned_api_response400 {
        desc {
            en: """Bad request, possibly due to wrong parameters or the existence of a banned object."""
            zh: """错误的请求，可能是参数错误或封禁对象已存在等原因。"""
        }
    }

    delete_banned_api {
        desc {
            en: """Remove a client ID, username or IP address from the blacklist."""
            zh: """将一个客户端 ID、用户名或者 IP 地址从黑名单中删除。"""
        }
    }

    delete_banned_api_response404 {
        desc {
            en: """The banned object was not found in the blacklist."""
            zh: """未在黑名单中找到该封禁对象。"""
        }
    }

    as {
        desc {
            en: """Ban method, which can be client ID, username or IP address."""
            zh: """封禁方式，可以通过客户端 ID、用户名或者 IP 地址等方式进行封禁。"""
        }
        label {
            en: """Ban Method"""
            zh: """封禁方式"""
        }
    }
    who {
        desc {
            en: """Ban object, specific client ID, username or IP address."""
            zh: """封禁对象，具体的客户端 ID、用户名或者 IP 地址。"""
        }
        label {
            en: """Ban Object"""
            zh: """封禁对象"""
        }
    }
    by {
        desc {
            en: """Initiator of the ban."""
            zh: """封禁的发起者。"""
        }
        label {
            en: """Ban Initiator"""
            zh: """封禁发起者"""
        }
    }
    reason {
        desc {
            en: """Ban reason, record the reason why the current object was banned."""
            zh: """封禁原因，记录当前对象被封禁的原因。"""
        }
        label {
            en: """Ban Reason"""
            zh: """封禁原因"""
        }
    }
    at {
        desc {
            en: """The start time of the ban, the format is rfc3339, the default is the time when the operation was initiated."""
            zh: """封禁的起始时间，格式为 rfc3339，默认为发起操作的时间。"""
        }
        label {
            en: """Ban Time"""
            zh: """封禁时间"""
        }
    }
    until {
        desc {
            en: """The end time of the ban, the format is rfc3339, the default is the time when the operation was initiated + 5 minutes."""
            zh: """封禁的结束时间，式为 rfc3339，默认为发起操作的时间 + 5 分钟。"""
        }
        label {
            en: """Ban End Time"""
            zh: """封禁结束时间"""
        }
    }
}


emqx_mgmt_api_publish {
    publish_api {
        desc {
            en: """
Publish one message.<br/>
Possible HTTP status response codes are:<br/>
<code>200</code>: The message is delivered to at least one subscriber;<br/>
<code>202</code>: No matched subscribers;<br/>
<code>400</code>: Message is invalid. for example bad topic name, or QoS is out of range;<br/>
<code>503</code>: Failed to deliver the message to subscriber(s);<br/>
"""
            zh: """
发布一个消息。<br/>
可能的 HTTP 状态码如下：<br/>
200: 消息被成功发送到至少一个订阅。<br/>
202: 没有匹配到任何订阅。<br/>
400: 消息编码错误，如非法主题，或 QoS 超出范围等。<br/>
503: 服务重启等过程中导致转发失败。<br/><br/>
"""
        }
    }
    publish_bulk_api {
        desc {
            en: """
Publish a batch of messages.<br/>
Possible HTTP response status code are:<br/>
200: All messages are delivered to at least one subscriber;<br/>
202: At least one message was not delivered to any subscriber;<br/>
400: At least one message is invalid. For example bad topic name, or QoS is out of range;<br/>
503: Failed to deliver at least one of the messages;<br/>

In case there is at lest one invalid message in the batch, the HTTP response body
is the same as for <code>/publish</code> API.<br/>
Otherwise the HTTP response body is an array of JSON objects indicating the publish
result of each individual message in the batch.
"""
            zh: """
批量发布一组消息。<br/>
可能的 HTTP 状态码如下：<br/>
200: 所有的消息都被成功发送到至少一个订阅。<br/>
202: 至少有一个消息没有匹配到任何订阅。<br/>
400: 至少有一个消息编码错误，如非法主题，或 QoS 超出范围等。<br/>
503: 至少有一个小因为服务重启的原因导致转发失败。<br/>

请求的 Body 或者 Body 中包含的某个消息无法通过 API 规范的类型检查时，HTTP 响应的消息与发布单个消息的 API
 <code>/publish</code> 是一样的。
如果所有的消息都是合法的，那么 HTTP 返回的内容是一个 JSON 数组，每个元素代表了该消息转发的状态。

"""
        }
    }

    topic_name {
        desc {
            en: "Topic Name"
            zh: "主题名称"
        }
    }
    qos {
        desc {
            en: "MQTT message QoS"
            zh: "MQTT 消息的 QoS"
        }
    }
    clientid {
        desc {
            en: "Each message can be published as if it is done on behalf of an MQTT client whos ID can be specified in this field."
            zh: "每个消息都可以带上一个 MQTT 客户端 ID，用于模拟 MQTT 客户端的发布行为。"
        }
    }
    payload {
        desc {
            en: "The MQTT message payload."
            zh: "MQTT 消息体。"
        }
    }
    retain {
        desc {
            en: "A boolean field to indicate if this message should be retained."
            zh: "布尔型字段，用于表示该消息是否保留消息。"
        }
    }
    payload_encoding {
        desc {
            en: "MQTT Payload Encoding, <code>base64</code> or <code>plain</code>. When set to <code>base64</code>, the message is decoded before it is published."
            zh: "MQTT 消息体的编码方式，可以是 <code>base64</code> 或 <code>plain</code>。当设置为 <code>base64</code> 时，消息在发布前会先被解码。"
        }
    }
    message_id {
        desc {
            en: "A globally unique message ID for correlation/tracing."
            zh: "全局唯一的一个消息 ID，方便用于关联和追踪。"
        }
    }
    reason_code {
        desc {
            en: """
The MQTT reason code, as the same ones used in PUBACK packet.<br/>
Currently supported codes are:<br/>

16(0x10): No matching subscribers;<br/>
131(0x81): Error happened when dispatching the message. e.g. during EMQX restart;<br/>
144(0x90): Topic name invalid;<br/>
151(0x97): Publish rate limited, or message size exceeded limit. The global size limit can be configured with <code>mqtt.max_packet_size</code><br/>
NOTE: The message size is estimated with the received topic and payload size, meaning the actual size of serialized bytes (when sent to MQTT subscriber)
might be slightly over the limit.
"""
            zh: """
MQTT 消息发布的错误码，这些错误码也是 MQTT 规范中 PUBACK 消息可能携带的错误码。<br/>
当前支持如下错误码：<br/>

16(0x10)：没能匹配到任何订阅；<br/>
131(0x81)：消息转发时发生错误，例如 EMQX 服务重启；<br/>
144(0x90)：主题名称非法；<br/>
151(0x97)：受到了速率限制，或者消息尺寸过大。全局消息大小限制可以通过配置项 <code>mqtt.max_packet_size</code> 来进行修改。<br/>
注意：消息尺寸的是通过主题和消息体的字节数进行估算的。具体发布时所占用的字节数可能会稍大于这个估算的值。
"""
        }
    }
    error_message {
        desc {
            en: "Describes the failure reason in detail."
            zh: "失败的详细原因。"
        }
    }
    message_properties {
        desc {
             en: "The Properties of the PUBLISH message."
             zh: "PUBLISH 消息里的 Property 字段。"
        }
    }
    msg_payload_format_indicator {
        desc {
             en: """0 (0x00) Byte Indicates that the Payload is unspecified bytes, which is equivalent to not sending a Payload Format Indicator.

1 (0x01) Byte Indicates that the Payload is UTF-8 Encoded Character Data. The UTF-8 data in the Payload MUST be well-formed UTF-8 as defined by the Unicode specification and restated in RFC 3629.
"""
             zh: "载荷格式指示标识符，0 表示载荷是未指定格式的数据，相当于没有发送载荷格式指示；1 表示载荷是 UTF-8 编码的字符数据，载荷中的 UTF-8 数据必须是按照 Unicode 的规范和 RFC 3629 的标准要求进行编码的。"
        }
    }
    msg_message_expiry_interval {
        desc {
             en: "Identifier of the Message Expiry Interval. If the Message Expiry Interval has passed and the Server has not managed to start onward delivery to a matching subscriber, then it MUST delete the copy of the message for that subscriber."
             zh: "消息过期间隔标识符，以秒为单位。当消失已经过期时，如果服务端还没有开始向匹配的订阅者投递该消息，则服务端会删除该订阅者的消息副本。如果不设置，则消息永远不会过期"
        }
    }
    msg_response_topic {
        desc {
             en: "Identifier of the Response Topic.The Response Topic MUST be a UTF-8 Encoded, It MUST NOT contain wildcard characters."
             zh: "响应主题标识符， UTF-8 编码的字符串，用作响应消息的主题名。响应主题不能包含通配符，也不能包含多个主题，否则将造成协议错误。当存在响应主题时，消息将被视作请求报文。服务端在收到应用消息时必须将响应主题原封不动的发送给所有的订阅者。"
        }
    }
    msg_correlation_data {
        desc {
             en: "Identifier of the Correlation Data. The Server MUST send the Correlation Data unaltered to all subscribers receiving the Application Message."
             zh: "对比数据标识符，服务端在收到应用消息时必须原封不动的把对比数据发送给所有的订阅者。对比数据只对请求消息(Request Message)的发送端和响应消息(Response Message)的接收端有意义。"
        }
    }
    msg_user_properties {
        desc {
             en: "The User-Property key-value pairs. Note: in case there are duplicated keys, only the last one will be used."
             zh: "指定 MQTT 消息的 User Property 键值对。注意，如果出现重复的键，只有最后一个会保留。"
        }
    }
    msg_content_type {
        desc {
             en: "The Content Type MUST be a UTF-8 Encoded String."
             zh: "内容类型标识符，以 UTF-8 格式编码的字符串，用来描述应用消息的内容，服务端必须把收到的应用消息中的内容类型原封不动的发送给所有的订阅者。"
        }
    }
}

emqx_mgmt_api_status {
  get_status_api {
    desc {
      en: "Serves as a health check for the node.  Returns a plain text response"
          " describing the status of the node.  This endpoint requires no"
          " authentication.\n"
          "\n"
          "Returns status code 200 if the EMQX application is up and running, "
          "503 otherwise."
          "\n"
          "This API was introduced in v5.0.10."
          "\n"
          "The GET `/status` endpoint (without the `/api/...` prefix) is also an alias"
          " to this endpoint and works in the same way.  This alias has been available since"
          " v5.0.0."
      zh: "作为节点的健康检查。 返回一个纯文本的响应，描述节点的状态。\n"
          "\n"
          "如果 EMQX 应用程序已经启动并运行，返回状态代码 200，否则返回 503。\n"
          "\n"
          "这个API是在v5.0.10中引入的。"
          "\n"
          "GET `/status`端点（没有`/api/...`前缀）也是这个端点的一个别名，工作方式相同。"
          " 这个别名从v5.0.0开始就有了。"
    }
  }

  get_status_response200 {
    desc {
      en: "Node emqx@127.0.0.1 is started\n"
          "emqx is running"
      zh: "Node emqx@127.0.0.1 is started\n"
          "emqx is running"
    }
  }

  get_status_response503 {
    desc {
      en: "Node emqx@127.0.0.1 is stopped\n"
          "emqx is not_running"
      zh: "Node emqx@127.0.0.1 is stopped\n"
          "emqx is not_running"
    }
  }
}

emqx_coap_api {

    send_coap_request {
        desc {
            en: """Send a CoAP request message to the client"""
            zh: """发送 CoAP 消息到指定客户端"""
        }
    }

   token {
        desc {
            en: """Message token, can be empty"""
            zh: """消息 Token, 可以为空"""
        }
    }

    method {
        desc {
            en: """Request method type"""
            zh: """请求 Method 类型"""
        }
    }

    timeout {
        desc {
            en: """Timespan for response"""
            zh: """请求超时时间"""
        }
    }

    content_type {
        desc {
            en: """Payload type"""
            zh: """Payload 类型"""
        }
    }

    payload {
        desc {
            en: """The content of the payload"""
            zh: """Payload 内容"""
        }
    }

    message_id {
        desc {
            en: """Message ID"""
            zh: """消息 ID"""
        }
    }

    response_code {
        desc {
            en: """Response code"""
            zh: """应答码"""
        }
    }
}

emqx_gateway_api_authn {

    get_authn {
        desc {
            en: """Gets the configuration of the specified gateway authenticator.<br/>
Returns 404 when gateway or authentication is not enabled."""
            zh: """获取指定网关认证器的配置
当网关或认证未启用时，返回 404。"""
        }
    }

    update_authn {
        desc {
            en: """Update the configuration of the specified gateway authenticator, or disable the authenticator."""
            zh: """更新指定网关认证器的配置，或停用认证器。"""
        }
    }

    add_authn {
        desc {
            en: """Enables the authenticator for client authentication for the specified gateway. <br/>
When the authenticator is not configured or turned off, all client connections are assumed to be allowed. <br/>
Note: Only one authenticator is allowed to be enabled at a time in the gateway, rather than allowing multiple authenticators to be configured to form an authentication chain as in MQTT."""
            zh: """为指定网关开启认证器实现客户端认证的功能。<br/>
当未配置认证器或关闭认证器时，则认为允许所有客户端的连接。<br/>
注：在网关中仅支持添加一个认证器，而不是像 MQTT 一样允许配置多个认证器构成认证链。"""
        }
    }

    delete_authn {
        desc {
            en: """Delete the authenticator of the specified gateway."""
            zh: """删除指定网关的认证器。"""
        }
    }

    list_users {
        desc {
            en: """Get the users for the authenticator (only supported by <code>built_in_database</code>)."""
            zh: """获取用户列表（仅支持 built_in_database 类型的认证器）"""
        }
    }

    add_user {
        desc {
            en: """Add user for the authenticator (only supports built_in_database)."""
            zh: """添加用户（仅支持 built_in_database 类型的认证器）"""
        }
    }

    get_user {
        desc {
            en: """Get user info from the gateway authenticator (only supports built_in_database)"""
            zh: """获取用户信息（仅支持 built_in_database 类型的认证器）"""
        }
    }

    update_user {
        desc {
            en: """Update the user info for the gateway authenticator (only supports built_in_database)"""
            zh: """更新用户信息（仅支持 built_in_database 类型的认证器）"""
        }
    }

    delete_user {
        desc {
            en: """Delete the user for the gateway authenticator (only supports built_in_database)"""
            zh: """删除用户（仅支持 built_in_database 类型的认证器）"""
        }
    }

    import_users {
        desc {
            en: """Import users into the gateway authenticator (only supports built_in_database)"""
            zh: """导入用户（仅支持 built_in_database 类型的认证器）"""
        }
    }

    user_id {
        desc {
            en: """User ID"""
            zh: """用户 ID"""
        }
    }

    like_user_id {
        desc {
            en: """Fuzzy search using user ID (username or clientid), only supports search by substring."""
            zh: """使用用户 ID （username 或 clientid）模糊搜索，仅支持按子串的方式进行搜索。"""
        }
    }

    is_superuser {
        desc {
            en: """Is superuser"""
            zh: """是否是超级用户"""
        }
    }
}

emqx_gateway_api_clients {

    list_clients {
        desc {
            en: """Get the gateway client list"""
            zh: """获取指定网关的客户端列表"""
        }
    }

    get_client {
        desc {
            en: """Get the gateway client information"""
            zh: """获取客户端信息"""
        }
    }

    kick_client {
        desc {
            en: """Kick out the gateway client"""
            zh: """踢出指定客户端"""
        }
    }

    list_subscriptions {
        desc {
            en: """Get the gateway client subscriptions"""
            zh: """获取某客户端的主题订阅列表"""
        }
    }

    add_subscription {
        desc {
            en: """Create a subscription membership"""
            zh: """为某客户端新增订阅关系"""
        }
    }

    delete_subscription {
        desc {
            en: """Delete a subscriptions membership"""
            zh: """为某客户端删除某订阅关系"""
        }
    }

    param_node {
        desc {
            en: """Match the client's node name"""
            zh: """匹配客户端的节点名称"""
        }
    }

    param_clientid {
        desc {
            en: """Match the client's ID"""
            zh: """匹配客户端 ID"""
        }
    }

    param_username {
        desc {
            en: """Match the client's Username"""
            zh: """匹配客户端 Username"""
        }
    }

    param_ip_address {
        desc {
            en: """Match the client's ip address"""
            zh: """匹配客户端 IP 地址"""
        }
    }

    param_conn_state {
        desc {
            en: """Match the client's connection state"""
            zh: """匹配客户端连接状态"""
        }
    }

    param_proto_ver {
        desc {
            en: """Match the client's protocol version"""
            zh: """匹配客户端协议版本"""
        }
    }

    param_clean_start {
        desc {
            en: """Match the client's clean start flag"""
            zh: """匹配客户端 `clean_start` 标记"""
        }
    }

    param_like_clientid {
        desc {
            en: """Use sub-string to match client's ID"""
            zh: """子串匹配客户端 ID"""
        }
    }

    param_like_username {
        desc {
            en: """Use sub-string to match client's username"""
            zh: """子串匹配 客户端 Username"""
        }
    }

    param_gte_created_at {
        desc {
            en: """Match the session created datetime greater than a certain value"""
            zh: """匹配会话创建时间大于等于指定值的客户端"""
        }
    }

    param_lte_created_at {
        desc {
            en: """Match the session created datetime less than a certain value"""
            zh: """匹配会话创建时间小于等于指定值的客户端"""
        }
    }

    param_gte_connected_at{
        desc {
            en: """Match the client socket connected datetime greater than a certain value"""
            zh: """匹配连接创建时间大于等于指定值的客户端"""
        }
    }

    param_lte_connected_at {
        desc {
            en: """Match the client socket connected datatime less than a certain value"""
            zh: """匹配连接创建时间小于等于指定值的客户端"""
        }
    }

    param_endpoint_name {
        desc {
            en: """Match the lwm2m client's endpoint name"""
            zh: """匹配 LwM2M 客户端 Endpoint Name"""
        }
    }

    param_like_endpoint_name {
        desc {
            en: """Use sub-string to match lwm2m client's endpoint name"""
            zh: """子串匹配 LwM2M 客户端 Endpoint Name"""
        }
    }

    param_gte_lifetime {
        desc {
            en: """Match the lwm2m client registered lifetime greater than a certain value"""
            zh: """匹配心跳时间大于等于指定值的 LwM2M 客户端"""
        }
    }

    param_lte_lifetime {
        desc {
            en: """Match the lwm2m client registered lifetime less than a certain value"""
            zh: """匹配心跳时间小于等于指定值的 LwM2M 客户端"""
        }
    }

    clientid {
        desc {
            en: """Client ID"""
            zh: """客户端 ID"""
        }
    }

    topic {
        desc {
            en: """Topic Filter/Name"""
            zh: """主题过滤器或主题名称"""
        }
    }

    endpoint_name {
        desc {
            en: """The LwM2M client endpoint name"""
            zh: """LwM2M 客户端 Endpoint Name"""
        }
    }

    lifetime {
        desc {
            en: """LwM2M Life time"""
            zh: """LwM2M 客户端心跳周期"""
        }
    }

    qos {
        desc {
            en: """QoS level, enum: 0, 1, 2"""
            zh: """QoS 等级，枚举：0，1，2"""
        }
    }

    nl {
        desc {
            en: """No Local option, enum: 0, 1"""
            zh: """No Local 选项，枚举：0，1"""
        }
    }

    rap {
        desc {
            en: """Retain as Published option, enum: 0, 1"""
            zh: """Retain as Published 选项，枚举：0，1"""
        }
    }

    rh {
        desc {
            en: """Retain Handling option, enum: 0, 1, 2"""
            zh: """Retain Handling 选项，枚举：0，1，2"""
        }
    }

    sub_props {
        desc {
            en: """Subscription properties"""
            zh: """订阅属性"""
        }
    }

    subid {
        desc {
            en: """Only stomp protocol, a unique identity for the subscription. range: 1-65535."""
            zh: """订阅ID，仅用于 Stomp 网关。用于创建订阅关系时指定订阅 ID。取值范围 1-65535。"""
        }
    }

    node {
        desc {
            en: """Name of the node to which the client is connected"""
            zh: """客户端连接到的节点名称"""
        }
    }

    username {
        desc {
            en: """Username of client when connecting"""
            zh: """客户端连接的用户名"""
        }
    }

    mountpoint {
        desc {
            en: """Topic mountpoint"""
            zh: """主题固定前缀"""
        }
    }

    proto_name {
        desc {
            en: """Client protocol name"""
            zh: """客户端使用的协议名称"""
        }
    }

    proto_ver {
        desc {
            en: """Protocol version used by the client"""
            zh: """客户端使用的协议版本"""
        }
    }

    ip_address {
        desc {
            en: """Client's IP address"""
            zh: """客户端 IP 地址"""
        }
    }

    port {
        desc {
            en: """Client's port"""
            zh: """客户端端口"""
        }
    }

    is_bridge {
        desc {
            en: """Indicates whether the client is connected via bridge"""
            zh: """标识客户端是否通过 is_bridge 标志连接"""
        }
    }

    connected_at {
        desc {
            en: """Client connection time"""
            zh: """客户端连接时间"""
        }
    }

    disconnected_at {
        desc {
            en: """Client offline time, This field is only valid and returned when connected is false"""
            zh: """客户端连接断开时间"""
        }
    }

    connected {
        desc {
            en: """Whether the client is connected"""
            zh: """标识客户端是否已连接到网关"""
        }
    }

    keepalive {
        desc {
            en: """Keepalive time, with the unit of second"""
            zh: """Keepalive 时间，单位：秒"""
        }
    }

    clean_start {
        desc {
            en: """Indicate whether the client is using a brand new session"""
            zh: """标识客户端是否以 clean_start 的标志连接到网关"""
        }
    }

    expiry_interval {
        desc {
            en: """Session expiration interval, with the unit of second"""
            zh: """会话超期时间，单位：秒"""
        }
    }

    created_at {
        desc {
            en: """Session creation time"""
            zh: """会话创建时间"""
        }
    }

    subscriptions_cnt {
        desc {
            en: """Number of subscriptions established by this client"""
            zh: """客户端已订阅主题数"""
        }
    }

    subscriptions_max {
        desc {
            en: """Maximum number of subscriptions allowed by this client"""
            zh: """客户端允许订阅的最大主题数"""
        }
    }

    inflight_cnt {
        desc {
            en: """Current length of inflight"""
            zh: """客户端当前飞行窗口大小"""
        }
    }

    inflight_max {
        desc {
            en: """Maximum length of inflight"""
            zh: """客户端允许的飞行窗口最大值"""
        }
    }

    mqueue_len {
        desc {
            en: """Current length of message queue"""
            zh: """客户端当前消息队列长度"""
        }
    }

    mqueue_max {
        desc {
            en: """Maximum length of message queue"""
            zh: """客户端允许的最大消息队列长度"""
        }
    }

    mqueue_dropped {
        desc {
            en: """Number of messages dropped by the message queue due to exceeding the length"""
            zh: """由于消息队列过程，客户端消息队列丢弃消息条数"""
        }
    }

    awaiting_rel_cnt {
        desc {
            en: """Number of awaiting acknowledge packet"""
            zh: """客户端当前等待 PUBREL 确认的 PUBREC 消息的条数"""
        }
    }

    awaiting_rel_max {
        desc {
            en: """Maximum allowed number of awaiting PUBREC packet"""
            zh: """客户端允许的最大 PUBREC 等待队列长度"""
        }
    }

    recv_oct {
        desc {
            en: """Number of bytes received"""
            zh: """已接收的字节数"""
        }
    }

    recv_cnt {
        desc {
            en: """Number of socket packets received"""
            zh: """已接收 Socket 报文次数"""
        }
    }

    recv_pkt {
        desc {
            en: """Number of protocol packets received"""
            zh: """已接收应用层协议控制报文数"""
        }
    }

    recv_msg {
        desc {
            en: """Number of message packets received"""
            zh: """已接收上行的消息条数"""
        }
    }

    send_oct {
        desc {
            en: """Number of bytes sent"""
            zh: """已发送字节数"""
        }
    }

    send_cnt {
        desc {
            en: """Number of socket packets sent"""
            zh: """已发送 Socket 报文次数"""
        }
    }

    send_pkt {
        desc {
            en: """Number of protocol packets sent"""
            zh: """已发送应用层协议控制报文数"""
        }
    }

    send_msg {
        desc {
            en: """Number of message packets sent"""
            zh: """已发送下行消息数条数"""
        }
    }

    mailbox_len {
        desc {
            en: """Process mailbox size"""
            zh: """进程邮箱大小"""
        }
    }

    heap_size {
        desc {
            en: """Process heap size with the unit of byte"""
            zh: """进程堆内存大小，单位：字节"""
        }
    }

    reductions {
        desc {
            en: """Erlang reduction"""
            zh: """进程已消耗 Reduction 数"""
        }
    }
}

emqx_gateway_api {

    list_gateway {
        desc {
            en: """This API returns an overview info for the specified or all gateways.
including current running status, number of connections, listener status, etc."""
            zh: """该接口会返回指定或所有网关的概览状态，
包括当前状态、连接数、监听器状态等。"""
        }
    }

    enable_gateway {
        desc {
            en: """Enable a gateway by confs."""
            zh: """使用配置启动某一网关。"""
        }
    }

    get_gateway {
        desc {
            en: """Get the gateway configurations"""
            zh: """获取网关配置详情"""
        }
    }

    delete_gateway {
        desc {
            en: """Unload the specified gateway"""
            zh: """停用指定网关"""
        }
    }

    update_gateway {
        desc {
            en: """Update the gateway basic configurations and running status.<br/>
Note: The Authentication and Listener configurations should be updated by other special APIs. """
            zh: """更新指定网关的基础配置、和启用的状态。<br/>
注：认证、和监听器的配置更新需参考对应的 API 接口。"""
        }
    }

    gateway_name {
        desc {
            en: """Gateway Name"""
            zh: """网关名称"""
        }
    }

    gateway_name_in_qs {
        desc {
            en: """Gateway Name.<br/>
It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`
"""
            zh: """网关名称.<br/>
可取值为 `stomp`、`mqttsn`、`coap`、`lwm2m`、`exproto`
"""
        }
    }

    gateway_enable_in_path {
        desc {
            en: """Whether or not gateway is enabled"""

            zh: """是否开启此网关"""
        }
    }

    gateway_status {
        desc {
            en: """Gateway status"""
            zh: """网关启用状态"""
        }
    }

    gateway_status_in_qs {
        desc {
            en: """Filter gateways by status.<br/>
It is enum with `running`, `stopped`, `unloaded`"""
            zh: """通过网关状态筛选<br/>
可选值为 `running`、`stopped`、`unloaded`"""
        }
    }

    gateway_created_at {
        desc {
            en: """The Gateway created datetime"""
            zh: """网关创建时间"""
        }
    }

    gateway_started_at {
        desc {
            en: """The Gateway started datetime"""
            zh: """网关启用时间"""
        }
    }

    gateway_stopped_at {
        desc {
            en: """The Gateway stopped datetime"""
            zh: """网关停用时间"""
        }
    }

    gateway_max_connections {
        desc {
            en: """The Gateway allowed maximum connections/clients"""
            zh: """最大连接数"""
        }
    }

    gateway_current_connections {
        desc {
            en: """The Gateway current connected connections/clients"""
            zh: """当前连接数"""
        }
    }

    gateway_listeners {
        desc {
            en: """The Gateway listeners overview"""
            zh: """网关监听器列表"""
        }
    }

    gateway_listener_id {
        desc {
            en: """Listener ID"""
            zh: """监听器 ID"""
        }
    }

    gateway_listener_name {
        desc {
            en: """Listener Name"""
            zh: """监听器名称"""
        }
    }

    gateway_listener_running {
        desc {
            en: """Listener Running status"""
            zh: """监听器运行状态"""
        }
    }

    gateway_listener_type {
        desc {
            en: """Listener Type"""
            zh: """监听器类型"""
        }
    }

    gateway_node_status {
        desc {
            en: """The status of the gateway on each node in the cluster"""
            zh: """网关在集群中每个节点上的状态"""
        }
    }

    node {
        desc {
            en: """Node Name"""
            zh: """节点名称"""
        }
    }

}

emqx_gateway_api_listeners {

    list_listeners {
        desc {
            en: """Gets a list of gateway listeners. This interface returns all the configs of the listener (including the authenticator on that listener), as well as the status of that listener running in the cluster."""
            zh: """获取网关监听器列表。该接口会返回监听器所有的配置（包括该监听器上的认证器），同时也会返回该监听器在集群中运行的状态。"""
        }
    }

    add_listener {
        desc {
            en: """Create the gateway listener.<br/>
Note: For listener types not supported by a gateway, this API returns `400: BAD_REQUEST`."""
            zh: """为指定网关添加监听器。<br/>
注：对于某网关不支持的监听器类型，该接口会返回 `400: BAD_REQUEST`。"""
        }
    }

    get_listener {
        desc {
            en: """Get the gateway listener configs"""
            zh: """获取指定网关监听器的配置。"""
        }
    }

    delete_listener {
        desc {
            en: """Delete the gateway listener. All connected clients under the deleted listener will be disconnected."""
            zh: """删除指定监听器。被删除的监听器下所有已连接的客户端都会离线。"""
        }
    }

    update_listener {
        desc {
            en: """Update the gateway listener. The listener being updated performs a restart and all clients connected to that listener will be disconnected."""
            zh: """更新某网关监听器的配置。被更新的监听器会执行重启，所有已连接到该监听器上的客户端都会被断开。"""
        }
    }

    get_listener_authn {
        desc {
            en: """Get the listener's authenticator configs."""
            zh: """获取监听器的认证器配置。"""
        }
    }

    add_listener_authn {
        desc {
            en: """Enable authenticator for specified listener for client authentication.<br/>
When authenticator is enabled for a listener, all clients connecting to that listener will use that authenticator for authentication."""
            zh: """为指定监听器开启认证器以实现客户端认证的能力。<br/>
当某一监听器开启认证后，所有连接到该监听器的客户端会使用该认证器进行认证。"""
        }
    }

    update_listener_authn {
        desc {
            en: """Update authenticator configs for the listener, or disable/enable it."""
            zh: """更新指定监听器的认证器配置，或停用/启用该认证器。"""
        }
    }

    delete_listener_authn {
        desc {
            en: """Remove authenticator for the listener."""
            zh: """移除指定监听器的认证器。"""
        }
    }

    list_users {
        desc {
            en: """Get the users for the authenticator (only supported by <code>built_in_database</code>)"""
            zh: """获取用户列表（仅支持 built_in_database 类型的认证器）"""
        }
    }

    add_user {
        desc {
            en: """Add user for the authenticator (only supports built_in_database)"""
            zh: """添加用户（仅支持 built_in_database 类型的认证器）"""
        }
    }

    get_user {
        desc {
            en: """Get user info from the gateway authenticator (only supports built_in_database)"""
            zh: """获取用户信息（仅支持 built_in_database 类型的认证器）"""
        }
    }

    update_user {
        desc {
            en: """Update the user info for the gateway authenticator (only supports built_in_database)"""
            zh: """更新用户信息（仅支持 built_in_database 类型的认证器）"""
        }
    }

    delete_user {
        desc {
            en: """Delete the user for the gateway authenticator (only supports built_in_database)"""
            zh: """删除用户（仅支持 built_in_database 类型的认证器）"""
        }
    }

    import_users {
        desc {
            en: """Import users into the gateway authenticator (only supports built_in_database)"""
            zh: """导入用户（仅支持 built_in_database 类型的认证器）"""
        }
    }

    listener_id {
        desc {
            en: """Listener ID"""
            zh: """监听器 ID"""
        }
    }

    listener_status {
        desc {
            en: """listener status """
            zh: """监听器状态"""
        }
    }

    listener_node_status {
        desc {
            en: """listener status of each node in the cluster"""
            zh: """监听器在集群中每个节点上的状态"""
        }
    }

    node {
        desc {
            en: """Node Name"""
            zh: """节点名称"""
        }
    }

    current_connections {
        desc {
            en: """Current Connections"""
            zh: """当前连接数"""
        }
    }
}

emqx_gateway_schema {

    stomp {
        desc {
            en: """The Stomp Gateway configuration.
This gateway supports v1.2/1.1/1.0"""
            zh: """Stomp 网关配置。当前实现支持 v1.2/1.1/1.0 协议版本"""
        }
    }

    stom_frame_max_headers {
        desc {
            en: """The maximum number of Header"""
            zh: """允许的 Header 最大数量"""
        }
    }

    stomp_frame_max_headers_length {
        desc {
            en: """The maximum string length of the Header Value"""
            zh: """允许的 Header 字符串的最大长度"""
        }
    }

    stom_frame_max_body_length {
        desc {
            en: """Maximum number of bytes of Body allowed per Stomp packet"""
            zh: """允许的 Stomp 报文 Body 的最大字节数"""
        }
    }

    mqttsn {
        desc {
            en: """The MQTT-SN Gateway configuration.
This gateway only supports the v1.2 protocol"""
            zh: """MQTT-SN 网关配置。当前实现仅支持 v1.2 版本"""
        }
    }

    mqttsn_gateway_id {
        desc {
            en: """MQTT-SN Gateway ID.
When the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value"""
            zh: """MQTT-SN 网关 ID。
当 <code>broadcast</code> 打开时，MQTT-SN 网关会使用该 ID 来广播 ADVERTISE 消息"""
        }
    }

    mqttsn_broadcast {
        desc {
            en: """Whether to periodically broadcast ADVERTISE messages"""
            zh: """是否周期性广播 ADVERTISE 消息 """
        }
    }

    mqttsn_enable_qos3 {
        desc {
            en: """Allows connectionless clients to publish messages with a Qos of -1.
This feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW"""
            zh: """是否允许无连接的客户端发送 QoS 等于 -1 的消息。
该功能主要用于支持轻量的 MQTT-SN 客户端实现，它不会向网关建立连接，注册主题，也不会发起订阅；它只使用 QoS 为 -1 来发布消息"""
        }
    }

    mqttsn_subs_resume {
        desc {
            en: """Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel"""
            zh: """在会话被重用后，网关是否主动向客户端注册对已订阅主题名称"""
        }
    }

    mqttsn_predefined {
        desc {
            en: """The pre-defined topic IDs and topic names.
A 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway"""
            zh: """预定义主题列表。
预定义的主题列表，是一组 主题 ID 和 主题名称 的映射关系。使用预先定义的主题列表，可以减少 MQTT-SN 客户端和网关对于固定主题的注册请求"""
        }
    }

    mqttsn_predefined_id {
        desc {
            en: """Topic ID. Range: 1-65535"""
            zh: """主题 ID。范围：1-65535 """
        }
    }

    mqttsn_predefined_topic {
        desc {
            en: """Topic Name"""
            zh: """主题名称。注：不支持通配符"""
        }
    }

    coap {
        desc {
            en: """The CoAP Gateway configuration.
This gateway is implemented based on RFC-7252 and https://core-wg.github.io/coap-pubsub/draft-ietf-core-pubsub.html"""
            zh: """CoAP 网关配置。
该网关的实现基于 RFC-7252 和 https://core-wg.github.io/coap-pubsub/draft-ietf-core-pubsub.html"""
        }
    }

    coap_heartbeat {
        desc {
            en: """The gateway server required minimum heartbeat interval.
When connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive"""
            zh: """CoAP 网关要求客户端的最小心跳间隔时间。
当 <code>connection_required</code> 开启后，该参数用于检查客户端连接是否存活"""
        }
    }

    coap_connection_required {
        desc {
            en: """Enable or disable connection mode.
Connection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources"""
            zh: """是否开启连接模式。
连接模式是非标准协议的功能。它维护 CoAP 客户端上线、认证、和连接状态的保持"""
        }
    }

    coap_notify_type {
        desc {
            en: """The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.
The type of delivered coap message can be set to:
  - non: Non-confirmable;
  - con: Confirmable;
  - qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con
"""
            zh: """投递给 CoAP 客户端的通知消息类型。当客户端 Observe 一个资源（或订阅某个主题）时，网关会向客户端推送新产生的消息。其消息类型可设置为：
  - non: 不需要客户端返回确认消息;
  - con: 需要客户端返回一个确认消息;
  - qos: 取决于消息的 QoS 等级; QoS 0 会以 `non` 类型下发，QoS 1/2 会以 `con` 类型下发
"""
        }
    }

    coap_subscribe_qos {
        desc {
            en: """The Default QoS Level indicator for subscribe request.
This option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:
  - qos0, qos1, qos2: Fixed default QoS level
  - coap: Dynamic QoS level by the message type of subscribe request
    * qos0: If the subscribe request is non-confirmable
    * qos1: If the subscribe request is confirmable
"""
            zh: """客户端订阅请求的默认 QoS 等级。
当 CoAP 客户端发起订阅请求时，如果未携带 `qos` 参数则会使用该默认值。默认值可设置为：
  - qos0、 qos1、qos2: 设置为固定的 QoS 等级
  - coap: 依据订阅操作的 CoAP 报文类型来动态决定
    * 当订阅请求为 `non-confirmable` 类型时，取值为 qos0
    * 当订阅请求为 `confirmable` 类型时，取值为 qos1
"""
        }
    }

    coap_publish_qos {
        desc {
            en: """The Default QoS Level indicator for publish request.
This option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:
  - qos0, qos1, qos2: Fixed default QoS level
  - coap: Dynamic QoS level by the message type of publish request
    * qos0: If the publish request is non-confirmable
    * qos1: If the publish request is confirmable"""

            zh: """客户端发布请求的默认 QoS 等级。
当 CoAP 客户端发起发布请求时，如果未携带 `qos` 参数则会使用该默认值。默认值可设置为：
  - qos0、qos1、qos2: 设置为固定的 QoS 等级
  - coap: 依据发布操作的 CoAP 报文类型来动态决定
    * 当发布请求为 `non-confirmable` 类型时，取值为 qos0
    * 当发布请求为 `confirmable` 类型时，取值为 qos1
 """
        }
    }

    lwm2m {
        desc {
            en: """The LwM2M Gateway configuration. This gateway only supports the v1.0.1 protocol."""
            zh: """LwM2M 网关配置。仅支持 v1.0.1 协议。"""
        }
    }

    lwm2m_xml_dir {
        desc {
            en: """The Directory for LwM2M Resource definition."""
            zh: """LwM2M Resource 定义的 XML 文件目录路径。"""
        }
    }

    lwm2m_lifetime_min {
        desc {
            en: """Minimum value of lifetime allowed to be set by the LwM2M client."""
            zh: """允许 LwM2M 客户端允许设置的心跳最小值。"""
        }
    }

    lwm2m_lifetime_max {
        desc {
            en: """Maximum value of lifetime allowed to be set by the LwM2M client."""
            zh: """允许 LwM2M 客户端允许设置的心跳最大值。"""
        }
    }

    lwm2m_qmode_time_window {
        desc {
            en: """The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.
For example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory."""

            zh: """在QMode模式下，LwM2M网关认为网络链接有效的时间窗口的值。
例如，在收到客户端的更新信息后，在这个时间窗口内的任何信息都会直接发送到LwM2M客户端，而超过这个时间窗口的所有信息都会暂时储存在内存中。"""
        }
    }

    lwm2m_auto_observe {
        desc {
            en: """Automatically observe the object list of REGISTER packet."""
            zh: """自动 Observe REGISTER 数据包的 Object 列表。"""
        }
    }

    lwm2m_update_msg_publish_condition {
        desc {
            en: """Policy for publishing UPDATE event message.
  - always: send update events as long as the UPDATE request is received.
  - contains_object_list: send update events only if the UPDATE request carries any Object List
"""
            zh: """发布UPDATE事件消息的策略。
  - always: 只要收到 UPDATE 请求，就发送更新事件。
  - contains_object_list: 仅当 UPDATE 请求携带 Object 列表时才发送更新事件。
"""
        }
    }

    lwm2m_translators {
        desc {
            en: """Topic configuration for LwM2M's gateway publishing and subscription."""
            zh: """LwM2M 网关订阅/发布消息的主题映射配置。"""
        }
    }

    lwm2m_translators_command {
        desc {
            en: """The topic for receiving downstream commands.
For each new LwM2M client that succeeds in going online, the gateway creates a subscription relationship to receive downstream commands and send it to the LwM2M client"""

            zh: """下行命令主题。
对于每个成功上线的新 LwM2M 客户端，网关会创建一个订阅关系来接收下行消息并将其发送给客户端。"""
        }
    }

    lwm2m_translators_response {
        desc {
            en: """The topic for gateway to publish the acknowledge events from LwM2M client"""
            zh: """用于网关发布来自 LwM2M 客户端的确认事件的主题。"""
        }
    }

    lwm2m_translators_notify {
        desc {
            en: """The topic for gateway to publish the notify events from LwM2M client.
After succeed observe a resource of LwM2M client, Gateway will send the notify events via this topic, if the client reports any resource changes"""

            zh: """用于发布来自 LwM2M 客户端的通知事件的主题。
在成功 Observe 到 LwM2M 客户端的资源后，如果客户端报告任何资源状态的变化，网关将通过该主题发送通知事件。"""
        }
    }

    lwm2m_translators_register {
        desc {
            en: """The topic for gateway to publish the register events from LwM2M client."""
            zh: """用于发布来自 LwM2M 客户端的注册事件的主题。"""
        }
    }

    lwm2m_translators_update {
        desc {
            en: """The topic for gateway to publish the update events from LwM2M client"""
            zh: """用于发布来自LwM2M客户端的更新事件的主题。"""
        }
    }

    translator {
        desc {
            en: """MQTT topic that corresponds to a particular type of event."""
            zh: """配置某网关客户端对于发布消息或订阅的主题和 QoS 等级。"""
        }
    }

    translator_topic {
        desc {
            en: """Topic Name"""
            zh: """主题名称"""
        }
    }

    translator_qos {
        desc {
            en: """QoS Level"""
            zh: """QoS 等级"""
        }
    }

    exproto {
        desc {
            en: """The Extension Protocol configuration"""
            zh: """ExProto 网关"""
        }
    }

    exproto_server {
        desc {
            en: """Configurations for starting the <code>ConnectionAdapter</code> service"""
            zh: """配置 ExProto 网关需要启动的 <code>ConnectionAdapter</code> 服务。
该服务用于提供客户端的认证、发布、订阅和数据下行等功能。"""
        }
    }

    exproto_grpc_server_bind {
        desc {
            en: """Listening address and port for the gRPC server."""
            zh: """服务监听地址和端口。"""
        }
    }

    exproto_grpc_server_ssl {
        desc {
            en: """SSL configuration for the gRPC server."""
            zh: """服务 SSL 配置。"""
        }
    }

    exproto_handler {
        desc {
            en: """Configurations for request to <code>ConnectionHandler</code> service"""
            zh: """配置 ExProto 网关需要请求的 <code>ConnectionHandler</code> 服务地址。
该服务用于给 ExProto 提供客户端的 Socket 事件处理、字节解码、订阅消息接收等功能。"""
        }
    }

    exproto_grpc_handler_address {
        desc {
            en: """gRPC server address."""
            zh: """对端 gRPC 服务器地址。"""
        }
    }

    exproto_grpc_handler_ssl {
        desc {
            en: """SSL configuration for the gRPC client."""
            zh: """gRPC 客户端的 SSL 配置。"""
        }
    }

    gateway_common_enable {
        desc {
            en: """Whether to enable this gateway"""
            zh: """是否启用该网关"""
        }
    }

    gateway_common_enable_stats {
        desc {
            en: """Whether to enable client process statistic"""
            zh: """是否开启客户端统计"""
        }
    }

    gateway_common_idle_timeout {
        desc {
            en: """The idle time of the client connection process. It has two purposes:
  1. A newly created client process that does not receive any client requests after that time will be closed directly.
  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources."""
            zh: """客户端连接过程的空闲时间。该配置用于：
  1. 一个新创建的客户端进程如果在该时间间隔内没有收到任何客户端请求，将被直接关闭。
  2. 一个正在运行的客户进程如果在这段时间后没有收到任何客户请求，将进入休眠状态以节省资源。"""
        }
    }

    gateway_common_mountpoint {
        desc {
            en: """ """
            zh: """ """
        }
    }

    gateway_common_clientinfo_override {
        desc {
            en: """ClientInfo override."""
            zh: """ClientInfo 重写。"""
        }
    }

    gateway_common_clientinfo_override_username {
        desc {
            en: """Template for overriding username."""
            zh: """username 重写模板"""
        }
    }
    gateway_common_clientinfo_override_password {
        desc {
            en: """Template for overriding password."""
            zh: """password 重写模板"""
        }
    }
    gateway_common_clientinfo_override_clientid {
        desc {
            en: """Template for overriding clientid."""
            zh: """clientid 重写模板"""
        }
    }

    gateway_common_authentication {
        desc {
            en: """Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs"""
            zh: """网关的认证器配置，对该网关下所以的监听器生效。如果每个监听器需要配置不同的认证器，需要配置监听器下的 <code>authentication</code> 字段。"""
        }
    }

    tcp_udp_listeners {
        desc {
            en: """Settings for the listeners."""
            zh: """监听器配置。"""
        }
    }

    tcp_listeners {
        desc {
            en: """Settings for the TCP listeners."""
            zh: """配置 TCP 类型的监听器。"""
        }
    }

    udp_listeners {
        desc {
            en: """Settings for the UDP listeners."""
            zh: """配置 UDP 类型的监听器。"""
        }
    }

    tcp_listener {
        desc {
            en: """ """
            zh: """ """
        }
    }

    tcp_listener_acceptors {
        desc {
            en: """Size of the acceptor pool."""
            zh: """Acceptor 进程池大小。"""
        }
    }

    tcp_listener_tcp_opts{
        desc {
            en: """Setting the TCP socket options."""
            zh: """TCP Socket 配置。"""
        }
    }

    tcp_listener_proxy_protocol {
        desc {
            en: """Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.
See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"""
            zh: """是否开启 Proxy Protocol V1/2。当 EMQX 集群部署在 HAProxy 或 Nginx 后需要获取客户端真实 IP 时常用到该选项。参考：https://www.haproxy.com/blog/haproxy/proxy-protocol/"""
        }
    }

    tcp_listener_proxy_protocol_timeout {
        desc {
            en: """Timeout for proxy protocol.
EMQX will close the TCP connection if proxy protocol packet is not received within the timeout."""
            zh: """接收 Proxy Protocol 报文头的超时时间。如果在超时内没有收到 Proxy Protocol 包，EMQX 将关闭 TCP 连接。"""
        }
    }

    ssl_listener {
        desc {
            en: """ """
            zh: """ """
        }
    }

    ssl_listener_options {
        desc {
            en: """SSL Socket options."""
            zh: """SSL Socket 配置。"""
        }
    }

    udp_listener {
        desc {
            en: """ """
            zh: """ """
        }
    }

    udp_listener_udp_opts {
        desc {
            en: """Settings for the UDP sockets."""
            zh: """UDP Socket 配置。"""
        }
    }

    udp_listener_active_n {
        desc {
            en: """Specify the {active, N} option for the socket.
See: https://erlang.org/doc/man/inet.html#setopts-2"""
            zh: """为 Socket 指定 {active, N} 选项。
参见：https://erlang.org/doc/man/inet.html#setopts-2"""
        }
    }

    udp_listener_recbuf {
        desc {
            en: """Size of the kernel-space receive buffer for the socket."""
            zh: """Socket 在内核空间接收缓冲区的大小。"""
        }
    }

    udp_listener_sndbuf {
        desc {
            en: """Size of the kernel-space send buffer for the socket."""
            zh: """Socket 在内核空间发送缓冲区的大小。"""
        }
    }

    udp_listener_buffer {
        desc {
            en: """Size of the user-space buffer for the socket."""
            zh: """Socket 在用户空间的缓冲区大小。"""
        }
    }

    udp_listener_reuseaddr {
        desc {
            en: """Allow local reuse of port numbers."""
            zh: """允许重用本地处于 TIME_WAIT 的端口号。"""
        }
    }

    dtls_listener {
        desc {
            en: """ """
            zh: """ """
        }
    }

    dtls_listener_acceptors {
        desc {
            en: """Size of the acceptor pool."""
            zh: """Acceptor 进程池大小。"""
        }
    }

    dtls_listener_dtls_opts {
        desc {
            en: """DTLS socket options"""
            zh: """DTLS Socket 配置"""
        }

    }

    gateway_common_listener_enable {
        desc {
            en: """Enable the listener."""
            zh: """是否启用该监听器。"""
        }
    }

    gateway_common_listener_bind {
        desc {
            en: """The IP address and port that the listener will bind."""
            zh: """监听器绑定的 IP 地址或端口。"""
        }
    }

    gateway_common_listener_max_connections {
        desc {
            en: """Maximum number of concurrent connections."""
            zh: """监听器支持的最大连接数。"""
        }
    }

    gateway_common_listener_max_conn_rate {
        desc {
            en: """Maximum connections per second."""
            zh: """监听器支持的最大连接速率。"""
        }
    }

    gateway_common_listener_enable_authn {
        desc {
            en: """Set <code>true</code> (default) to enable client authentication on this listener. 
When set to <code>false</code> clients will be allowed to connect without authentication."""
            zh: """配置 <code>true</code> （默认值）启用客户端进行身份认证。
配置 <code>false</code> 时，将不对客户端做任何认证。"""
        }
    }

    gateway_common_listener_mountpoint {
        desc {
            en: """When publishing or subscribing, prefix all topics with a mountpoint string.
The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.
For example if a client A subscribes to `t` with `listeners.tcp.\<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.
Variables in mountpoint string:
  - <code>${clientid}</code>: clientid
  - <code>${username}</code>: username
"""
            zh: """发布或订阅时，在所有主题前增加前缀字符串。
当消息投递给订阅者时，前缀字符串将从主题名称中删除。挂载点是用户可以用来实现不同监听器之间的消息路由隔离的一种方式。
例如，如果客户端 A 在 `listeners.tcp.\<name>.mountpoint` 设置为 `some_tenant` 的情况下订阅 `t`，则客户端实际上订阅了 `some_tenant/t` 主题。 类似地，如果另一个客户端 B（连接到与客户端 A 相同的侦听器）向主题 `t` 发送消息，则该消息被路由到所有订阅了 `some_tenant/t` 的客户端，因此客户端 A 将收到该消息，带有 主题名称`t`。 设置为 `\"\"` 以禁用该功能。
挂载点字符串中可用的变量：
   - <code>${clientid}</code>：clientid
   - <code>${username}</code>：用户名
"""
        }
    }

    gateway_common_listener_access_rules {
        desc {
            en: """The access control rules for this listener.
See: https://github.com/emqtt/esockd#allowdeny"""
            zh: """配置监听器的访问控制规则。
见：https://github.com/emqtt/esockd#allowdeny"""
        }
    }
}

emqx_lwm2m_api {

    lookup_resource {
        desc {
            en: """Look up a resource"""
            zh: """查看指定资源状态"""
        }
    }

    observe_resource {
        desc {
            en: """Observe or Cancel observe a resource"""
            zh: """Observe/Un-Observe 指定资源"""
        }
    }

    read_resource {
        desc {
            en: """Send a read command to a resource"""
            zh: """发送读指令到某资源"""
        }
    }

    write_resource {
        desc {
            en: """Send a write command to a resource"""
            zh: """发送写指令到某资源"""
        }
    }

    operations {
        desc {
            en: """Resource Operations"""
            zh: """资源可用操作列表"""
        }
    }

    dataType {
        desc {
            en: """Data Type"""
            zh: """数据类型"""
        }
    }

    path {
        desc {
            en: """Resource Path"""
            zh: """资源路径"""
        }
    }

    name {
        desc {
            en: """Resource Name"""
            zh: """资源名称"""
        }
    }
}

emqx_exhook_api {

  list_all_servers {
    desc {
      en: "List all servers"
      zh: "查看ExHook 服务器列表"
    }
  }

  add_server {
    desc {
      en: "Add a server"
      zh: "添加 ExHook 服务器"
    }
  }

  get_detail {
    desc {
      en: "Get the detail information of Exhook server"
      zh: "查看 Exhook 服务器详细信息"
    }
  }

  update_server {
    desc {
      en: "Update the server"
      zh: "更新 Exhook 服务器"
    }
  }

  delete_server {
    desc {
      en: "Delete the server"
      zh: "删除 Exhook 服务器"
    }
  }

  get_hooks {
    desc {
      en: "Get the hooks information of server"
      zh: "获取 Exhook 服务器的钩子信息"
    }
  }

  move_api {
    desc {
      en: """Move the server.
NOTE: The position should be \"front | rear | before:{name} | after:{name}"""
      zh: """移动 Exhook 服务器顺序。
注意: 移动的参数只能是：front | rear | before:{name} | after:{name}"""
    }
  }

  move_position {
    desc {
      en: "The target position to be moved"
      zh: "移动的方向"
    }
  }

  hook_name {
    desc {
      en: "The hook's name"
      zh: "钩子的名称"
    }
  }

  server_name {
    desc {
      en: "The Exhook server name"
      zh: "Exhook 服务器的名称"
    }
  }

  hook_params {
    desc {
      en: "The parameters used when the hook is registered"
      zh: "钩子注册时使用的参数"
    }
  }

  server_metrics {
    desc {
      en: "Metrics information of this server in the current node"
      zh: "当前节点中该服务器的指标信息"
    }
  }

  node_metrics {
    desc {
      en: "Metrics information of this server in all nodes"
      zh: "所有节点中该服务器的指标信息"
    }
  }

  node_status {
    desc {
      en: "status of this server in all nodes"
      zh: "所有节点中该服务器的状态信息"
    }
  }

  hook_metrics {
    desc {
      en: "Metrics information of this hook in the current node"
      zh: "当前节点中该钩子的指标信息"
    }
  }

  node_hook_metrics {
    desc {
      en: "Metrics information of this hook in all nodes"
      zh: "所有节点中该钩子的指标信息"
    }
  }

  node {
    desc {
      en: "Node name"
      zh: "节点名称"
    }
  }

  metrics {
    desc {
      en: "Metrics information"
      zh: "指标信息"
    }
  }

  status {
    desc {
      en: """The status of Exhook server.
connected: connection succeeded
connecting: connection failed, reconnecting
disconnected: failed to connect and didn't reconnect
disabled: this server is disabled
error: failed to view the status of this server
"""
      zh: """Exhook 服务器的状态。
connected: 连接成功
connecting: 连接失败，重连中
disconnected: 连接失败，且未设置自动重连
disabled: 该服务器未开启
error: 查看该服务器状态时发生错误"""
    }
  }

  metric_succeed {
    desc {
      en: "The number of times the hooks execution successful"
      zh: "钩子执行成功的次数"
    }
  }

  metric_failed {
    desc {
      en: "The number of times the hook execution failed"
      zh: "钩子执行失败的次数"
    }
  }

  metric_rate {
    desc {
      en: "The call rate of hooks"
      zh: "钩子的调用速率"
    }
  }

  metric_max_rate {
    desc {
      en: "Maximum call rate of hooks"
      zh: "钩子的最大调用速率"
    }
  }

}

emqx_exhook_schema {

  servers {
    desc {
      en: "List of exhook servers"
      zh: "ExHook 服务器列表"
    }
  }

  name {
    desc {
      en: "Name of the exhook server"
      zh: "ExHook 服务器名称"
    }
  }

  enable {
    desc {
      en: "Enable this Exhook server"
      zh: "开启这个 Exhook 服务器"
    }
  }

  url {
    desc {
      en: "URL of the gRPC server"
      zh: "gRPC 服务器地址"
    }
  }

  request_timeout {
    desc {
      en: "The timeout of request gRPC server"
      zh: "gRPC 服务器请求超时时间"
    }
  }

  failed_action {
    desc {
      en: "The value that is returned when the request to the gRPC server fails for any reason"
      zh: "当 gRPC 请求失败后的操作"
    }
  }

  auto_reconnect {
    desc {
      en: """Whether to automatically reconnect (initialize) the gRPC server.
When gRPC is not available, Exhook tries to request the gRPC service at that interval and reinitialize the list of mounted hooks."""
      zh: """自动重连到 gRPC 服务器的设置。
当 gRPC 服务器不可用时，Exhook 将会按照这里设置的间隔时间进行重连，并重新初始化注册的钩子"""
    }
  }

  pool_size {
    desc {
      en: "The process pool size for gRPC client"
      zh: "gRPC 客户端进程池大小"
    }
  }

  socket_options {
    desc {
      en: "Connection socket options"
      zh: "连接套接字设置"
    }
  }

  keepalive {
    desc {
      en: """Enables/disables periodic transmission on a connected socket when no other data is exchanged.
If the other end does not respond, the connection is considered broken and an error message is sent to the controlling process."""
      zh: """当没有其他数据交换时，是否向连接的对端套接字定期的发送探测包。如果另一端没有响应，则认为连接断开，并向控制进程发送错误消息"""
    }
  }

  nodelay {
    desc {
      en: """If true, option TCP_NODELAY is turned on for the socket,
which means that also small amounts of data are sent immediately"""
      zh: "如果为 true，则为套接字设置 TCP_NODELAY 选项，这意味着会立即发送数据包"
    }
  }

  recbuf {
    desc {
      en: "The minimum size of receive buffer to use for the socket"
      zh: "套接字的最小接收缓冲区大小"
    }
  }

  sndbuf {
    desc {
      en: "The minimum size of send buffer to use for the socket"
      zh: "套接字的最小发送缓冲区大小"
    }
  }
}

emqx_dashboard_api {

    token {
        desc {
            en: """Dashboard Auth Token"""
            zh: """Dashboard 认证 Token"""
        }
    }

    username {
        desc {
            en: """Dashboard Username"""
            zh: """Dashboard 用户名"""
        }
    }

    user_description {
        desc {
            en: """Dashboard User Description"""
            zh: """Dashboard 用户描述"""
        }
    }

    password {
        desc {
            en: """Dashboard Password"""
            zh: """Dashboard 密码"""
        }
    }

    license {
        desc {
            en: """EMQX License. opensource or enterprise"""
            zh: """EMQX 许可。开源版本 或者企业版"""
        }
    }

    version {
        desc {
            en: """EMQX Version"""
            zh: """EMQX 版本"""
        }
    }

    login_api {
        desc {
            en: """Dashboard Auth. Get Token"""
            zh: """Dashboard 认证。获取 Token"""
        }
    }

    login_success {
        desc {
            en: """Dashboard Auth. Success"""
            zh: """Dashboard 认证。成功"""
        }
    }

    login_failed401 {
        desc {
            en: """Login failed. Bad username or password"""
            zh: """登录失败。用户名或密码错误"""
        }
    }

    logout_api {
        desc {
            en: """Dashboard user logout"""
            zh: """Dashboard 用户登出"""
        }
    }

    list_users_api {
        desc {
            en: """Dashboard list users"""
            zh: """Dashboard 用户列表"""
        }
    }

    create_user_api {
        desc {
            en: """Create dashboard user"""
            zh: """创建 Dashboard 用户"""
        }
    }

    create_user_api_success {
        desc {
            en: """Create dashboard user success"""
            zh: """创建 Dashboard 用户成功"""
        }
    }

    update_user_api {
        desc {
            en: """Update dashboard user description"""
            zh: """更新 Dashboard 用户描述"""
        }
    }

    update_user_api200 {
        desc {
            en: """Update dashboard user success"""
            zh: """更新 Dashboard 用户成功"""
        }
    }

    delete_user_api {
        desc {
            en: """Delete dashboard user"""
            zh: """删除 Dashboard 用户"""
        }
    }

    users_api404 {
        desc {
            en: """Dashboard user not found"""
            zh: """Dashboard 用户不存在"""
        }
    }

    change_pwd_api {
        desc {
            en: """Change dashboard user password"""
            zh: """更改 Dashboard 用户密码"""
        }
    }

    old_pwd {
        desc {
            en: """Old password"""
            zh: """旧密码"""
        }
    }

    new_pwd {
        desc {
            en: """New password"""
            zh: """新密码"""
        }
    }

    login_failed_response400 {
        desc {
            en: """Login failed. Bad username or password"""
            zh: """登录失败。用户名或密码错误"""
        }
    }

}

emqx_dashboard_schema {
  listeners {
    desc {
      en: """HTTP(s) listeners are identified by their protocol type and are
used to serve dashboard UI and restful HTTP API.
Listeners must have a unique combination of port number and IP address.
For example, an HTTP listener can listen on all configured IP addresses
on a given port for a machine by specifying the IP address 0.0.0.0.
Alternatively, the HTTP listener can specify a unique IP address for each listener,
but use the same port."""
      zh: """仪表盘监听器设置。"""
    }
    label {
      en: "Listeners"
      zh: "监听器"
    }
  }
  sample_interval {
    desc {
      en: """How often to update metrics displayed in the dashboard.
Note: `sample_interval` should be a divisor of 60."""
      zh: """更新仪表板中显示的指标的时间间隔。必须小于60，且被60的整除。"""
    }
  }
  token_expired_time {
    desc {
      en: "JWT token expiration time."
      zh: "JWT token 过期时间"
    }
    label {
      en: "Token expired time"
      zh: "JWT 过期时间"
    }
  }
  num_acceptors {
    desc {
      en: "Socket acceptor pool size for TCP protocols."
      zh: "TCP协议的Socket acceptor池大小"
    }
    label {
      en: "Number of acceptors"
      zh: "Acceptor 数量"
    }
  }
  max_connections {
    desc {
      en: "Maximum number of simultaneous connections."
      zh: "同时处理的最大连接数"
    }
    label {
      en: "Maximum connections"
      zh: "最大连接数"
    }
  }
  backlog {
    desc {
      en: "Defines the maximum length that the queue of pending connections can grow to."
      zh: "排队等待连接的队列的最大长度"
    }
    label {
      en: "Backlog"
      zh: "排队长度"
    }
  }
  send_timeout {
    desc {
      en: "Send timeout for the socket."
      zh: "Socket发送超时时间"
    }
    label {
      en: "Send timeout"
      zh: "发送超时时间"
    }
  }
  inet6 {
    desc {
      en: "Enable IPv6 support, default is false, which means IPv4 only."
      zh: "启用IPv6， 如果机器不支持IPv6，请关闭此选项，否则会导致仪表盘无法使用。"
    }
    label {
      en: "IPv6"
      zh: "IPv6"
    }
  }
  ipv6_v6only {
    desc {
      en: "Disable IPv4-to-IPv6 mapping for the listener."
      zh: "当开启 inet6 功能的同时禁用 IPv4-to-IPv6 映射。该配置仅在 inet6 功能开启时有效。"
    }
    label {
      en: "IPv6 only"
      zh: "IPv6 only"
    }
  }
  desc_dashboard {
    desc {
      en: "Configuration for EMQX dashboard."
      zh: "EMQX仪表板配置"
    }
    label {
      en: "Dashboard"
      zh: "仪表板"
    }
  }
  desc_listeners {
    desc {
      en: "Configuration for the dashboard listener."
      zh: "仪表板监听器配置"
    }
    label {
      en: "Listeners"
      zh: "监听器"
    }
  }
  desc_http {
    desc {
      en: "Configuration for the dashboard listener (plaintext)."
      zh: "仪表板监听器(HTTP)配置"
    }
    label {
      en: "HTTP"
      zh: "HTTP"
    }
  }
  desc_https {
    desc {
      en: "Configuration for the dashboard listener (TLS)."
      zh: "仪表板监听器(HTTPS)配置"
    }
    label {
      en: "HTTPS"
      zh: "HTTPS"
    }
  }
  listener_enable {
    desc {
        en: "Ignore or enable this listener"
        zh: "忽略或启用该监听器配置"
    }
    label {
        en: "Enable"
        zh: "启用"
    }
  }
  bind {
    desc {
      en: "Port without IP(18083) or port with specified IP(127.0.0.1:18083)."
      zh: "监听的地址与端口，在dashboard更新此配置时，会重启dashboard服务。"
    }
    label {
      en: "Bind"
      zh: "绑定端口"
    }
  }
  default_username {
    desc {
      en: "The default username of the automatically created dashboard user."
      zh: "默认的仪表板用户名"
    }
    label {
      en: "Default username"
      zh: "默认用户名"
    }
  }
  default_password {
    desc {
      en: """The initial default password for dashboard 'admin' user.
For safety, it should be changed as soon as possible."""
      zh: """默认的仪表板用户密码
为了安全，应该尽快修改密码。"""
    }
    label {
      en: "Default password"
      zh: "默认密码"
    }
  }
  cors {
    desc {
      en: """Support Cross-Origin Resource Sharing (CORS).
Allows a server to indicate any origins (domain, scheme, or port) other than
its own from which a browser should permit loading resources."""
      zh: """支持跨域资源共享(CORS)
允许服务器指示任何来源(域名、协议或端口)，除了本服务器之外的任何浏览器应允许加载资源。"""
    }
    label {
      en: "CORS"
      zh: "跨域资源共享"
    }
  }
  i18n_lang {
    desc {
      en: "Internationalization language support."
      zh: "swagger多语言支持"
    }
    label {
      en: "I18n language"
      zh: "多语言支持"
    }
  }
  bootstrap_users_file {
    desc {
      en: "Initialize users file."
      zh: "初始化用户文件"
    }
    label {
      en: """Is used to add an administrative user to Dashboard when emqx is first launched,
      the format is:
       ```
       username1:password1
       username2:password2
       ```
"""
      zh: """用于在首次启动 emqx 时，为 Dashboard 添加管理用户，其格式为：
      ```
      username1:password1
      username2:password2
      ```
"""
    }
  }
}

emqx_connector_api {

    id {
        desc {
          en: "The connector ID. Must be of format {type}:{name}"
          zh: "连接器 ID， 格式必须为 {type}:{name}"
        }
        label: {
              en: "Connector ID"
              zh: "连接器 ID"
            }
    }

    conn_test_post {
        desc {
          en: """
Test creating a new connector by given ID <br/>
The ID must be of format '{type}:{name}'
"""
          zh: """
通过给定的 ID 测试创建一个新的连接器 <br/>
ID 的格式必须为“{type}:{name}”
"""
        }
        label: {
              en: "Create Test Connector"
              zh: "创建测试连接器"
            }
    }

    conn_get {
        desc {
          en: "List all connectors"
          zh: "列出所有连接器"
        }
        label: {
              en: "List All Connectors"
              zh: "列出所有连接器"
            }
    }

    conn_post {
        desc {
          en: "Create a new connector"
          zh: "创建一个新的连接器"
        }
        label: {
              en: "Create Connector"
              zh: "创建连接器"
            }
    }

    conn_id_get {
        desc {
          en: "Get the connector by ID"
          zh: "通过 ID 获取连接器"
        }
        label: {
              en: "Get Connector"
              zh: "获取连接器"
            }
    }

    conn_id_put {
        desc {
          en: "Update an existing connector by ID"
          zh: "通过 ID 更新一个连接器"
        }
        label: {
              en: "Update Connector"
              zh: "更新连接器"
            }
    }

    conn_id_delete {
        desc {
          en: "Delete a connector by ID"
          zh: "通过 ID 删除一个连接器"
        }
        label: {
              en: "Delete Connector"
              zh: "删除连接器"
            }
    }

}

emqx_connector_http {
    base_url {
        desc {
          en: """
The base URL is the URL includes only the scheme, host and port.<br/>
When send an HTTP request, the real URL to be used is the concatenation of the base URL and the
path parameter (passed by the emqx_resource:query/2,3 or provided by the request parameter).<br/>
For example: `http://localhost:9901/`
"""
          zh: """
base URL 只包含host和port。<br/>
发送HTTP请求时，真实的URL是由base URL 和 path parameter连接而成（通过emqx_resource:query/2,3传递，或者通过请求参数提供）。<br/>
示例：`http://localhost:9901/`
"""
        }
        label: {
              en: "Base Url"
              zh: "Base Url"
            }
    }

    connect_timeout {
        desc {
          en: "The timeout when connecting to the HTTP server."
          zh: "连接HTTP服务器的超时时间。"
        }
        label: {
              en: "Connect Timeout"
              zh: "连接超时"
            }
    }

    max_retries {
        desc {
          en: "Max retry times if error on sending request."
          zh: "请求出错时的最大重试次数。"
        }
        label: {
              en: "Max Retries"
              zh: "最大重试次数"
            }
    }

    pool_type {
        desc {
          en: "The type of the pool. Can be one of `random`, `hash`."
          zh: "连接池的类型，可用类型有`random`, `hash`。"
        }
        label: {
              en: "Pool Type"
              zh: "连接池类型"
            }
    }

    pool_size {
        desc {
          en: "The pool size."
          zh: "连接池大小。"
        }
        label: {
              en: "Pool Size"
              zh: "连接池大小"
            }
    }

    enable_pipelining {
        desc {
          en: "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request."
          zh: "正整数，设置最大可发送的异步 HTTP 请求数量。当设置为 1 时，表示每次发送完成 HTTP 请求后都需要等待服务器返回，再继续发送下一个请求。"
        }
        label: {
              en: "HTTP Pipelineing"
              zh: "HTTP 管道"
            }
    }

    request {
        desc {
          en: """
If the request is provided, the caller can send HTTP requests via
<code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code>
"""
          zh: """
如果提供了请求，调用者可以通过以下方式发送 HTTP 请求
<code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code>
"""
        }
        label: {
              en: "Request"
              zh: "HTTP 请求"
            }
    }

    method {
        desc {
          en: "HTTP method."
          zh: "HTTP 请求方法。"
        }
        label: {
              en: "HTTP Method"
              zh: "HTTP 请求方法"
            }
    }

    path {
        desc {
          en: "URL path."
          zh: "HTTP请求路径。"
        }
        label: {
              en: "URL Path"
              zh: "HTTP请求路径"
            }
    }

    body {
        desc {
          en: "HTTP request body."
          zh: "HTTP请求报文主体。"
        }
        label: {
              en: "HTTP Body"
              zh: "HTTP请求报文主体"
            }
    }

    headers {
        desc {
          en: "List of HTTP headers."
          zh: "HTTP 头字段列表。"
        }
        label: {
              en: "HTTP Headers"
              zh: "HTTP 头字段列表"
            }
    }

    request_timeout {
        desc {
          en: "HTTP request timeout."
          zh: "HTTP 请求超时。"
        }
        label: {
              en: "Request Timeout"
              zh: "HTTP 请求超时"
            }
    }

}

emqx_connector_mongo {

    single_mongo_type {
        desc {
          en: "Standalone instance."
          zh: "Standalone模式。"
        }
        label: {
              en: "Standalone instance"
              zh: "Standalone模式"
            }
    }

    rs_mongo_type {
        desc {
          en: "Replica set."
          zh: "Replica set模式。"
        }
        label: {
              en: "Replica set"
              zh: "Replica set模式"
            }
    }

    sharded_mongo_type {
        desc {
          en: "Sharded cluster."
          zh: "Sharded cluster模式。"
        }
        label: {
              en: "Sharded cluster"
              zh: "Sharded cluster模式"
            }
    }

    auth_source {
        desc {
          en: "Database name associated with the user's credentials."
          zh: "与用户证书关联的数据库名称。"
        }
        label: {
              en: "Auth Source"
              zh: "认证源"
            }
    }

    server {
        desc {
          en: """
The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The MongoDB default port 27017 is used if `[:Port]` is not specified.
"""
          zh: """
将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>
主机名具有以下形式：`Host[:Port]`。<br/>
如果未指定 `[:Port]`，则使用 MongoDB 默认端口 27017。
"""
        }
        label: {
              en: "Server Host"
              zh: "服务器地址"
            }
    }

    servers {
        desc {
          en: """
A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`
For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.
A host entry has the following form: `Host[:Port]`.
The MongoDB default port 27017 is used if `[:Port]` is not specified.
"""
          zh: """
集群将要连接的节点列表。 节点之间用逗号分隔，如：`Node[,Node].`
每个节点的配置为：将要连接的 IPv4 或 IPv6 地址或主机名。
主机名具有以下形式：`Host[:Port]`。
如果未指定 `[:Port]`，则使用 MongoDB 默认端口 27017。
"""
        }
        label: {
              en: "Servers"
              zh: "服务器列表"
            }
    }

    w_mode {
        desc {
          en: "Write mode."
          zh: "写模式。"
        }
        label: {
              en: "Write Mode"
              zh: "写模式"
            }
    }

    r_mode {
        desc {
          en: "Read mode."
          zh: "读模式。"
        }
        label: {
              en: "Read Mode"
              zh: "读模式"
            }
    }

    duration {
        desc {
          en: "Time interval, such as timeout or TTL."
          zh: "时间间隔，例如超时或 TTL。"
        }
        label: {
              en: "Time Interval"
              zh: "时间间隔"
            }
    }

    max_overflow {
        desc {
          en: "Max Overflow."
          zh: "最大溢出。"
        }
        label: {
              en: "Max Overflow"
              zh: "最大溢出"
            }
    }

    replica_set_name {
        desc {
          en: "Name of the replica set."
          zh: "副本集的名称。"
        }
        label: {
              en: "Replica Set Name"
              zh: "副本集名称"
            }
    }

    srv_record {
        desc {
          en: "Use DNS SRV record."
          zh: "使用 DNS SRV 记录。"
        }
        label: {
              en: "Srv Record"
              zh: "SRV 记录"
            }
    }

    desc_single {
                   desc {
                         en: """Settings for a single MongoDB instance."""
                         zh: """配置 Single 模式"""
                        }
                   label: {
                           en: "Setting Single MongoDB"
                           zh: "配置 Single 模式"
                          }
                  }

    desc_rs {
                   desc {
                         en: """Settings for replica set."""
                         zh: """配置 Replica Set"""
                        }
                   label: {
                           en: "Setting Replica Set"
                           zh: "配置 Replica Set"
                          }
                  }

    desc_sharded {
                   desc {
                         en: """Settings for sharded cluster."""
                         zh: """配置 Sharded Cluster"""
                        }
                   label: {
                           en: "Setting Sharded Cluster"
                           zh: "配置 Sharded Cluster"
                          }
                  }

    desc_topology {
                   desc {
                         en: """Topology of MongoDB."""
                         zh: """配置 Topology"""
                        }
                   label: {
                           en: "Setting Topology"
                           zh: "配置 Topology"
                          }
                  }

}

emqx_connector_mqtt {

    num_of_bridges {
        desc {
          en: "The current number of bridges that are using this connector."
          zh: "当前使用此连接器的网桥数量。"
        }
        label: {
              en: "Num of Bridges"
              zh: "网桥数量"
            }
    }

    type {
        desc {
          en: "The Connector Type."
          zh: "连接器类型。"
        }
        label: {
              en: "Connector Type"
              zh: "连接器类型"
            }
    }

    name {
        desc {
          en: "Connector name, used as a human-readable description of the connector."
          zh: "连接器名称，人类可读的连接器描述。"
        }
        label: {
              en: "Connector Name"
              zh: "连接器名称"
            }
    }

}

emqx_connector_mqtt_schema {
    mode {
        desc {
          en: """
The mode of the MQTT Bridge.<br/>

- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/>
In 'cluster_shareload' mode, the incoming load from the remote broker is shared by
using shared subscription.<br/>
Note that the 'clientid' is suffixed by the node name, this is to avoid
clientid conflicts between different nodes. And we can only use shared subscription
topic filters for <code>remote_topic</code> of ingress connections.
"""
          zh: """
MQTT 桥的模式。 <br/>

- cluster_shareload：在 emqx 集群的每个节点上创建一个 MQTT 连接。<br/>
在“cluster_shareload”模式下，来自远程代理的传入负载通过共享订阅的方式接收。<br/>
请注意，<code>clientid</code> 以节点名称为后缀，这是为了避免不同节点之间的clientid冲突。
而且对于入口连接的 <code>remote_topic</code>，我们只能使用共享订阅主题过滤器。
"""
        }
        label: {
              en: "MQTT Bridge Mode"
              zh: "MQTT 桥接模式"
            }
    }

    server {
        desc {
          en: "The host and port of the remote MQTT broker"
          zh: "远程 MQTT Broker的主机和端口。"
        }
        label: {
              en: "Broker IP And Port"
              zh: "Broker主机和端口"
        }
    }

    bridge_mode {
        desc {
            en: """
If enable bridge mode.
NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT
broker MUST support this feature.
    """
            zh: """
是否启用 Bridge Mode。
注意：此设置只针对 MQTT 协议版本 < 5.0 有效，并且需要远程 MQTT Broker 支持 Bridge Mode。
    """
        }
        label {
            en: "Bridge Mode"
            zh: "Bridge 模式"
        }
    }

    proto_ver {
        desc {
          en: "The MQTT protocol version"
          zh: "MQTT 协议版本"
        }
        label: {
              en: "Protocol Version"
              zh: "协议版本"
            }
    }

    username {
        desc {
          en: "The username of the MQTT protocol"
          zh: "MQTT 协议的用户名"
        }
        label: {
              en: "Username"
              zh: "用户名"
            }
    }

    password {
        desc {
          en: "The password of the MQTT protocol"
          zh: "MQTT 协议的密码"
        }
        label: {
              en: "Password"
              zh: "密码"
            }
    }

    clean_start {
        desc {
          en: "The clean-start or the clean-session of the MQTT protocol"
          zh: "MQTT 清除会话"
        }
        label: {
              en: "Clean Session"
              zh: "清除会话"
            }
    }

    max_inflight {
        desc {
          en: "Max inflight (sent, but un-acked) messages of the MQTT protocol"
          zh: "MQTT 协议的最大飞行（已发送但未确认）消息"
        }
        label: {
              en: "Max Inflight Message"
              zh: "最大飞行消息"
            }
    }

    ingress_remote_topic {
        desc {
          en: "Receive messages from which topic of the remote broker"
          zh: "从远程broker的哪个topic接收消息"
        }
        label: {
              en: "Remote Topic"
              zh: "远程主题"
            }
    }

    ingress_remote_qos {
        desc {
          en: "The QoS level to be used when subscribing to the remote broker"
          zh: "订阅远程borker时要使用的 QoS 级别"
        }
        label: {
              en: "Remote QoS"
              zh: "远程 QoS"
            }
    }

    ingress_local_topic {
        desc {
          en: """
Send messages to which topic of the local broker.<br/>
Template with variables is allowed.
"""
          zh: """
向本地broker的哪个topic发送消息。<br/>
允许使用带有变量的模板。
"""
        }
        label: {
              en: "Local Topic"
              zh: "本地主题"
            }
    }

    ingress_local_qos {
        desc {
          en: """
The QoS of the MQTT message to be sent.<br/>
Template with variables is allowed.
"""
          zh: """
待发送 MQTT 消息的 QoS。<br/>
允许使用带有变量的模板。
"""
        }
        label: {
              en: "Local QoS"
              zh: "本地 QoS"
            }
    }

    ingress_hookpoint {
        desc {
          en: "The hook point will be triggered when there's any message received from the remote broker."
          zh: "当从远程borker收到任何消息时，将触发钩子。"
        }
        label: {
              en: "Hookpoint"
              zh: "挂载点"
            }
    }

    egress_local_topic {
        desc {
          en: "The local topic to be forwarded to the remote broker"
          zh: "要转发到远程broker的本地主题"
        }
        label: {
              en: "Local Topic"
              zh: "本地主题"
            }
    }

    egress_remote_topic {
        desc {
          en: """
Forward to which topic of the remote broker.<br/>
Template with variables is allowed.
"""
          zh: """
转发到远程broker的哪个topic。<br/>
允许使用带有变量的模板。
"""
        }
        label: {
              en: "Remote Topic"
              zh: "远程主题"
            }
    }

    egress_remote_qos {
        desc {
          en: """
The QoS of the MQTT message to be sent.<br/>
Template with variables is allowed.
"""
          zh: """
待发送 MQTT 消息的 QoS。<br/>
允许使用带有变量的模板。
"""
        }
        label: {
              en: "Remote QoS"
              zh: "远程 QoS"
            }
    }

    dir {
        desc {
          en: """
The dir where the replayq file saved.<br/>
Set to 'false' disables the replayq feature.
"""
          zh: """
replayq 文件保存的目录。<br/>
设置为 'false' 会禁用 replayq 功能。
"""
        }
        label: {
              en: "Replyq file Save Dir"
              zh: "Replyq 文件保存目录"
            }
    }

    seg_bytes {
        desc {
          en: """
The size in bytes of a single segment.<br/>
A segment is mapping to a file in the replayq dir. If the current segment is full, a new segment
(file) will be opened to write.
"""
          zh: """
单个段的大小（以字节为单位）。<br/>
一个段映射到 replayq 目录中的一个文件。 如果当前段已满，则新段（文件）将被打开写入。
"""
        }
        label: {
              en: "Segment Size"
              zh: "Segment 大小"
            }
    }

    offload {
        desc {
          en: """
In offload mode, the disk queue is only used to offload queue tail segments.<br/>
The messages are cached in the memory first, then it writes to the replayq files after the size of
the memory cache reaches 'seg_bytes'.
"""
          zh: """
在Offload模式下，磁盘队列仅用于卸载队列尾段。<br/>
消息首先缓存在内存中，然后写入replayq文件。内存缓大小为“seg_bytes” 指定的值。
"""
        }
        label: {
              en: "Offload Mode"
              zh: "Offload 模式"
            }
    }

    retain {
        desc {
          en: """
The 'retain' flag of the MQTT message to be sent.<br/>
Template with variables is allowed.
"""
          zh: """
要发送的 MQTT 消息的“保留”标志。<br/>
允许使用带有变量的模板。
"""
        }
        label: {
              en: "Retain Flag"
              zh: "保留消息标志"
            }
    }

    payload {
        desc {
          en: """
The payload of the MQTT message to be sent.<br/>
Template with variables is allowed.
"""
          zh: """
要发送的 MQTT 消息的负载。<br/>
允许使用带有变量的模板。
"""
        }
        label: {
              en: "Payload"
              zh: "消息负载"
            }
    }

    desc_connector {
                   desc {
                         en: """Generic configuration for the connector."""
                         zh: """连接器的通用配置。"""
                        }
                   label: {
                           en: "Connector Generic Configuration"
                           zh: "连接器通用配置。"
                          }
                  }

    desc_ingress {
                   desc {
                         en: """
The ingress config defines how this bridge receive messages from the remote MQTT broker, and then send them to the local broker.<br/>
Template with variables is allowed in 'local_topic', 'remote_qos', 'qos', 'retain', 'payload'.<br/>
NOTE: if this bridge is used as the input of a rule (emqx rule engine), and also local_topic is configured, then messages got from the remote broker will be sent to both the 'local_topic' and the rule.
"""
                         zh: """
Ingress 模式定义了这个 bridge 如何从远程 MQTT broker 接收消息，然后将它们发送到本地 broker 。<br/>
允许带有的模板变量: 'local_topic'、'remote_qos'、'qos'、'retain'、'payload' 。<br/>
注意：如果这个 bridge 被用作规则的输入（emqx 规则引擎），并且还配置了 local_topic，那么从远程 broker 获取的消息将同时被发送到 'local_topic' 和规则引擎。
"""
                        }
                   label: {
                           en: "Ingress Config"
                           zh: "Ingress 模式配置"
                          }
                  }

    desc_egress {
                   desc {
                         en: """
The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/>
Template with variables is allowed in 'remote_topic', 'qos', 'retain', 'payload'.<br/>
NOTE: if this bridge is used as the action of a rule (emqx rule engine), and also local_topic is configured, then both the data got from the rule and the MQTT messages that matches local_topic will be forwarded.
"""
                         zh: """
Egress 模式定义了 bridge 如何将消息从本地 broker 转发到远程 broker。<br/>
允许带有的模板变量: 'remote_topic'、'qos'、'retain'、'payload' 。<br/>
注意：如果这个 bridge 作为规则（emqx 规则引擎）的输出，并且还配置了 local_topic，那么从规则引擎中获取的数据和匹配 local_topic 的 MQTT 消息都会被转发到远程 broker 。
"""
                        }
                   label: {
                           en: "Egress Config"
                           zh: "Egress 模式配置"
                          }
                  }

    desc_replayq {
                   desc {
                         en: """Queue messages in disk files."""
                         zh: """本地磁盘消息队列"""
                        }
                   label: {
                           en: "Replayq"
                           zh: "本地磁盘消息队列"
                          }
                  }



}

emqx_connector_mysql {

    server {
        desc {
          en: """
The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The MySQL default port 3306 is used if `[:Port]` is not specified.
"""
          zh: """
将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>
主机名具有以下形式：`Host[:Port]`。<br/>
如果未指定 `[:Port]`，则使用 MySQL 默认端口 3306。
"""
        }
        label: {
              en: "Server Host"
              zh: "服务器地址"
            }
    }

}

emqx_connector_pgsql {

    server {
        desc {
          en: """
The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The PostgreSQL default port 5432 is used if `[:Port]` is not specified.
"""
          zh: """
将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>
主机名具有以下形式：`Host[:Port]`。<br/>
如果未指定 `[:Port]`，则使用 PostgreSQL 默认端口 5432。
"""
        }
        label: {
              en: "Server Host"
              zh: "服务器地址"
            }
    }

}

emqx_connector_redis {

    single {
        desc {
          en: "Single mode"
          zh: "单机模式。"
        }
        label: {
              en: "Single Mode"
              zh: "单机模式"
            }
    }

    cluster {
        desc {
          en: "Cluster mode"
          zh: "集群模式。"
        }
        label: {
              en: "Cluster Mode"
              zh: "集群模式"
            }
    }

    sentinel {
        desc {
          en: "Sentinel mode"
          zh: "哨兵模式。"
        }
        label: {
              en: "Sentinel Mode"
              zh: "哨兵模式"
            }
    }

    sentinel_desc {
        desc {
          en: "The cluster name in Redis sentinel mode."
          zh: "Redis 哨兵模式下的集群名称。"
        }
        label: {
              en: "Cluster Name"
              zh: "集群名称"
            }
    }

    server {
        desc {
          en: """
The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The Redis default port 6379 is used if `[:Port]` is not specified.
"""
          zh: """
将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>
主机名具有以下形式：`Host[:Port]`。<br/>
如果未指定 `[:Port]`，则使用 MongoDB 默认端口 27017。
"""
        }
        label: {
              en: "Server Host"
              zh: "服务器地址"
            }
    }

    servers {
        desc {
          en: """
A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`
For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.
A host entry has the following form: `Host[:Port]`.
The MongoDB default port 27017 is used if `[:Port]` is not specified.
"""
          zh: """

集群将要连接的节点列表。 节点之间用逗号分隔，如：`Node[,Node].`
每个节点的配置为：将要连接的 IPv4 或 IPv6 地址或主机名。
主机名具有以下形式：`Host[:Port]`。
如果未指定 `[:Port]`，则使用 Redis 默认端口 6379。
"""
        }
        label: {
              en: "Servers"
              zh: "服务器列表"
            }
    }

    database {
        desc {
          en: "Redis database ID."
          zh: "Redis 数据库 ID。"
        }
        label: {
              en: "Database ID"
              zh: "数据库 ID"
            }
    }

}

emqx_connector_schema {

    mqtt {
        desc {
          en: "MQTT bridges."
          zh: "MQTT bridges。"
        }
        label: {
              en: "MQTT bridges"
              zh: "MQTT bridges"
            }
    }

    desc_connector {
        desc {
          en: """
Configuration for EMQX connectors.<br/>
A connector maintains the data related to the external resources, such as MySQL database.
"""
          zh: """
EMQX 连接器的配置。<br/>
连接器维护与外部资源相关的数据，比如 MySQL 数据库。
"""
        }
        label: {
              en: "Connector"
              zh: "连接器"
            }
    }

}

emqx_connector_schema_lib {

    ssl {
        desc {
          en: "SSL connection settings."
          zh: "启用 SSL 连接。"
        }
        label: {
              en: "Enable SSL"
              zh: "启用SSL"
            }
    }

    prepare_statement {
        desc {
          en: "Key-value list of SQL prepared statements."
          zh: "SQL 预处理语句列表。"
        }
        label: {
              en: "SQL Prepared Statements List"
              zh: "SQL 预处理语句列表"
            }
    }

    database_desc {
        desc {
          en: "Database name."
          zh: "数据库名字。"
        }
        label: {
              en: "Database Name"
              zh: "数据库名字"
            }
    }

    pool_size {
        desc {
          en: "Size of the connection pool."
          zh: "连接池大小。"
        }
        label: {
              en: "Pool Size"
              zh: "连接池大小"
            }
    }

    username {
        desc {
          en: "EMQX's username in the external database."
          zh: "内部数据库的用户名。"
        }
        label: {
              en: "Username"
              zh: "用户名"
            }
    }

    password {
        desc {
          en: "EMQX's password in the external database."
          zh: "内部数据库密码。"
        }
        label: {
              en: "Password"
              zh: "密码"
            }
    }

    auto_reconnect {
        desc {
          en: "Enable automatic reconnect to the database."
          zh: "自动重连数据库。"
        }
        label: {
              en: "Auto Reconnect Database"
              zh: "自动重连数据库"
            }
    }

}

emqx_conf_schema {

  cluster_name {
    desc {
      en: """Human-friendly name of the EMQX cluster."""
      zh: """EMQX集群名称。每个集群都有一个唯一的名称。服务发现时会用于做路径的一部分。"""
    }
    label {
      en: "Cluster Name"
      zh: "集群名称"
    }
  }

  process_limit {
    desc {
      en: """Maximum number of simultaneously existing processes for this Erlang system.
The actual maximum chosen may be much larger than the Number passed.
For more information, see: https://www.erlang.org/doc/man/erl.html
          """
      zh: """Erlang系统同时存在的最大进程数。
实际选择的最大值可能比设置的数字大得多。
参考: https://www.erlang.org/doc/man/erl.html
          """
    }
    label {
      en: "Erlang Process Limit"
      zh: "Erlang 最大进程数"
    }
  }

  max_ports {
    desc {
      en: """Maximum number of simultaneously existing ports for this Erlang system.
The actual maximum chosen may be much larger than the Number passed.
For more information, see: https://www.erlang.org/doc/man/erl.html
          """
      zh: """Erlang系统同时存在的最大端口数。
实际选择的最大值可能比设置的数字大得多。
参考: https://www.erlang.org/doc/man/erl.html
          """
    }
    label {
      en: "Erlang Port Limit"
      zh: "Erlang 最大端口数"
    }
  }

  dist_buffer_size {
    desc {
      en: """Erlang's distribution buffer busy limit in kilobytes."""
      zh: """Erlang分布式缓冲区的繁忙阈值，单位是KB。"""
    }
    label {
      en: "Erlang's dist buffer size(KB)"
      zh: "Erlang分布式缓冲区的繁忙阈值(KB)"
    }
  }

  max_ets_tables {
    desc {
      en: """Max number of ETS tables"""
      zh: """Erlang ETS 表的最大数量"""
    }
    label {
      en: "Max number of ETS tables"
      zh: "Erlang 表的最大数量"
    }
  }

  cluster_discovery_strategy {
    desc {
      en: """Service discovery method for the cluster nodes."""
      zh: """集群节点发现方式。可选值为:
- manual: 手动加入集群<br/>
- static: 配置静态节点。配置几个固定的节点，新节点通过连接固定节点中的某一个来加入集群。<br/>
- mcast: 使用 UDP 多播的方式发现节点。<br/>
- dns: 使用 DNS A 记录的方式发现节点。<br/>
- etcd: 使用 etcd 发现节点。<br/>
- k8s: 使用 Kubernetes 发现节点。<br/>
           """
    }
    label {
      en: "Cluster Discovery Strategy"
      zh: "集群服务发现策略"
    }
  }

  cluster_autoclean {
    desc {
      en: """Remove disconnected nodes from the cluster after this interval."""
      zh: """指定多久之后从集群中删除离线节点。"""
    }
    label {
      en: "Cluster Auto Clean"
      zh: "自动删除离线节点时间"
    }
  }

  cluster_autoheal {
    desc {
      en: """If <code>true</code>, the node will try to heal network partitions automatically."""
      zh: """集群脑裂自动恢复机制开关。"""
    }
    label {
      en: "Cluster Auto Heal"
      zh: "节点脑裂自动修复机制"
    }
  }

  cluster_proto_dist {
    desc {
      en: """The Erlang distribution protocol for the cluster."""
      zh: """分布式 Erlang 集群协议类型。可选值为:
- inet_tcp: 使用 IPv4 <br/>
- inet6_tcp 使用 IPv6 <br/>
- inet_tls: 使用 TLS，需要与 node.ssl_dist_optfile 配置一起使用。<br/>
         """
    }
    label {
      en: "Cluster Protocol Distribution"
      zh: "集群内部通信协议"
    }
  }

  cluster_static_seeds {
    desc {
      en: """List EMQX node names in the static cluster. See <code>node.name</code>."""
      zh: """集群中的EMQX节点名称列表，
指定固定的节点列表，多个节点间使用逗号 , 分隔。
当 cluster.discovery_strategy 为 static 时，此配置项才有效。
适合于节点数量较少且固定的集群。
          """
    }
    label {
      en: "Cluster Static Seeds"
      zh: "集群静态节点"
    }
  }

  cluster_mcast_addr {
    desc {
      en: """Multicast IPv4 address."""
      zh: """指定多播 IPv4 地址。
当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Multicast Address"
      zh: "多播地址"
    }
  }

  cluster_mcast_ports {
    desc {
      en: """List of UDP ports used for service discovery.<br/>
Note: probe messages are broadcast to all the specified ports.
          """
      zh: """指定多播端口。如有多个端口使用逗号 , 分隔。
当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Multicast Ports"
      zh: "多播端口"
    }
  }

  cluster_mcast_iface {
    desc {
      en: """Local IP address the node discovery service needs to bind to."""
      zh: """指定节点发现服务需要绑定到本地 IP 地址。
当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Multicast Interface"
      zh: "多播绑定地址"
    }
  }

  cluster_mcast_ttl {
    desc {
      en: """Time-to-live (TTL) for the outgoing UDP datagrams."""
      zh: """指定多播的 Time-To-Live 值。
当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Multicast TTL"
      zh: "多播TTL"
    }
  }

  cluster_mcast_loop {
    desc {
      en: """If <code>true</code>, loop UDP datagrams back to the local socket."""
      zh: """设置多播的报文是否投递到本地回环地址。
当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Multicast Loop"
      zh: "多播回环开关"
    }
  }

  cluster_mcast_sndbuf {
    desc {
      en: """Size of the kernel-level buffer for outgoing datagrams."""
      zh: """外发数据报的内核级缓冲区的大小。
当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Muticast Sendbuf"
      zh: "多播发送缓存区"
    }
  }

  cluster_mcast_recbuf {
    desc {
      en: """Size of the kernel-level buffer for incoming datagrams."""
      zh: """接收数据报的内核级缓冲区的大小。
当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Muticast Sendbuf"
      zh: "多播接收数据缓冲区"
    }
  }

  cluster_mcast_buffer {
    desc {
      en: """Size of the user-level buffer."""
      zh: """用户级缓冲区的大小。
当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Muticast Buffer"
      zh: "多播用户级缓冲区"
    }
  }

  cluster_dns_name {
    desc {
      en: """The domain name from which to discover peer EMQX nodes' IP addresses.
Applicable when <code>cluster.discovery_strategy = dns</code>
"""
      zh: """指定 DNS A 记录的名字。emqx 会通过访问这个 DNS A 记录来获取 IP 地址列表。
当<code>cluster.discovery_strategy</code> 为 <code>dns</code> 时有效。
"""
    }
    label {
      en: "Cluster Dns Name"
      zh: "DNS名称"
    }
  }

  cluster_dns_record_type {
    desc {
      en: """DNS record type. """
      zh: """DNS 记录类型。"""
    }
    label {
      en: "DNS Record Type"
      zh: "DNS记录类型"
    }
  }

  cluster_etcd_server {
    desc {
      en: """List of endpoint URLs of the etcd cluster"""
      zh: """指定 etcd 服务的地址。如有多个服务使用逗号 , 分隔。
当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Etcd Server"
      zh: "Etcd 服务器地址"
    }
  }

  cluster_etcd_prefix {
    desc {
      en: """Key prefix used for EMQX service discovery."""
      zh: """指定 etcd 路径的前缀。每个节点在 etcd 中都会创建一个路径:
v2/keys/<prefix>/<cluster.name>/<node.name> <br/>
当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。
      """
    }
    label {
      en: "Cluster Etcd Prefix"
      zh: "Etcd 路径前缀"
    }
  }

  cluster_etcd_node_ttl {
    desc {
      en: """Expiration time of the etcd key associated with the node.
It is refreshed automatically, as long as the node is alive.
          """
      zh: """指定 etcd 中节点信息的过期时间。
当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Etcd Node TTL"
      zh: "Etcd 节点过期时间"
    }
  }

  cluster_etcd_ssl {
    desc {
      en: """Options for the TLS connection to the etcd cluster."""
      zh: """当使用 TLS 连接 etcd 时的配置选项。
当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster Etcd SSL Option"
      zh: "Etcd SSL 选项"
    }
  }

  cluster_k8s_apiserver {
    desc {
      en: """Kubernetes API endpoint URL."""
      zh: """指定 Kubernetes API Server。如有多个 Server 使用逗号 , 分隔。
当 cluster.discovery_strategy 为 k8s 时，此配置项才有效。
          """
    }
    label {
      en: "Cluster k8s ApiServer"
      zh: "K8s 服务地址"
    }
  }

  cluster_k8s_service_name {
    desc {
      en: """EMQX broker service name."""
      zh: """指定 Kubernetes 中 EMQX 的服务名。
当 cluster.discovery_strategy 为 k8s 时，此配置项才有效。
          """
    }
    label {
      en: "K8s Service Name"
      zh: "K8s 服务别名"
    }
  }

  cluster_k8s_address_type {
    desc {
      en: """Address type used for connecting to the discovered nodes.
Setting <code>cluster.k8s.address_type</code> to <code>ip</code> will
make EMQX to discover IP addresses of peer nodes from Kubernetes API.
"""
      zh: """当使用 k8s 方式集群时，address_type 用来从 Kubernetes 接口的应答里获取什么形式的 Host 列表。
指定 <code>cluster.k8s.address_type</code> 为 <code>ip</code>，则将从 Kubernetes 接口中获取集群中其他节点
的IP地址。
"""
    }
    label {
      en: "K8s Address Type"
      zh: "K8s 地址类型"
    }
  }

  cluster_k8s_namespace {
    desc {
      en: """Kubernetes namespace."""
      zh: """当使用 k8s 方式并且 cluster.k8s.address_type 指定为 dns 类型时，
可设置 emqx 节点名的命名空间。与 cluster.k8s.suffix 一起使用用以拼接得到节点名列表。
      """
    }
    label {
      en: "K8s Namespace"
      zh: "K8s 命名空间"
    }
  }

  cluster_k8s_suffix {
    desc {
      en: """Node name suffix.<br/>
Note: this parameter is only relevant when <code>address_type</code> is <code>dns</code>
or <code>hostname</code>."""
      zh: """当使用 k8s 方式并且 cluster.k8s.address_type 指定为 dns 类型时，可设置 emqx 节点名的后缀。
与 cluster.k8s.namespace 一起使用用以拼接得到节点名列表。
          """
    }
    label {
      en: "K8s Suffix"
      zh: "K8s 前缀"
    }
  }

  node_name {
    desc {
      en: """Unique name of the EMQX node. It must follow <code>%name%@FQDN</code> or
<code>%name%@IPv4</code> format.
          """
      zh: """节点名。格式为 \<name>@\<host>。其中 <host> 可以是 IP 地址，也可以是 FQDN。
详见 http://erlang.org/doc/reference_manual/distributed.html。
          """
    }
    label {
      en: "Node Name"
      zh: "节点名"
    }
  }

  node_cookie {
    desc {
      en: """Secret cookie is a random string that should be the same on all nodes in
the given EMQX cluster, but unique per EMQX cluster. It is used to prevent EMQX nodes that
belong to different clusters from accidentally connecting to each other."""
      zh: """分布式 Erlang 集群使用的 cookie 值。集群间保持一致"""
    }
    label {
      en: "Node Cookie"
      zh: "节点 Cookie"
    }
  }

  node_data_dir {
    desc {
      en: """
Path to the persistent data directory.<br/>
Possible auto-created subdirectories are:<br/>
- `mnesia/<node_name>`: EMQX's built-in database directory.<br/>
For example, `mnesia/emqx@127.0.0.1`.<br/>
There should be only one such subdirectory.<br/>
Meaning, in case the node is to be renamed (to e.g. `emqx@10.0.1.1`),<br/>
the old dir should be deleted first.<br/>
- `configs`: Generated configs at boot time, and cluster/local override configs.<br/>
- `patches`: Hot-patch beam files are to be placed here.<br/>
- `trace`: Trace log files.<br/>

**NOTE**: One data dir cannot be shared by two or more EMQX nodes.
"""
      zh: """
节点数据存放目录，可能会自动创建的子目录如下：<br/>
- `mnesia/<node_name>`。EMQX的内置数据库目录。例如，`mnesia/emqx@127.0.0.1`。<br/>
如果节点要被重新命名（例如，`emqx@10.0.1.1`）。旧目录应该首先被删除。<br/>
- `configs`。在启动时生成的配置，以及集群/本地覆盖的配置。<br/>
- `patches`: 热补丁文件将被放在这里。<br/>
- `trace`: 日志跟踪文件。<br/>

**注意**: 一个数据dir不能被两个或更多的EMQX节点同时使用。
         """
    }
    label {
      en: "Node Data Dir"
      zh: "节点数据目录"
    }
  }

  node_config_files {
    desc {
      en: """List of configuration files that are read during startup. The order is
significant: later configuration files override the previous ones.
          """
      zh: """启动时读取的配置文件列表。后面的配置文件项覆盖前面的文件。"""
    }
    label {
      en: "Config Files"
      zh: "配置文件"
    }
  }

  node_global_gc_interval {
    desc {
      en: """Periodic garbage collection interval."""
      zh: """系统调优参数，设置节点运行多久强制进行一次全局垃圾回收。"""
    }
    label {
      en: "Global GC Interval"
      zh: "全局垃圾回收"
    }
  }

  node_crash_dump_file {
    desc {
      en: """Location of the crash dump file."""
      zh: """设置 Erlang crash_dump 文件的存储路径和文件名。"""
    }
    label {
      en: "Crash Dump File"
      zh: "节点崩溃时的Dump文件"
    }
  }

  node_crash_dump_seconds {
    desc {
      en: """The number of seconds that the broker is allowed to spend writing a crash dump."""
      zh: """保存崩溃文件最大允许时间，如果文件太大，在规则时间内没有保存完成，则会直接结束。"""
    }
    label {
      en: "Crash Dump Seconds"
      zh: "保存崩溃文件最长时间"
    }
  }

  node_crash_dump_bytes {
    desc {
      en: """The maximum size of a crash dump file in bytes."""
      zh: """限制崩溃文件的大小，当崩溃时节点内存太大，
如果为了保存现场，需要全部存到崩溃文件中，此处限制最多能保存多大的文件。
          """
    }
    label {
      en: "Crash Dump Bytes"
      zh: "崩溃文件最大容量"
    }
  }

  node_dist_net_ticktime {
    desc {
      en: """This is the approximate time an EMQX node may be unresponsive until it is considered down and thereby disconnected."""
      zh: """系统调优参数，此配置将覆盖 vm.args 文件里的 -kernel net_ticktime 参数。当一个节点持续无响应多久之后，认为其已经宕机并断开连接。
      """
    }
    label {
      en: "Dist Net TickTime"
      zh: "节点间心跳间隔"
    }
  }

  node_backtrace_depth {
    desc {
      en: """Maximum depth of the call stack printed in error messages and
<code>process_info</code>.
          """
      zh: """错误信息中打印的最大堆栈层数"""
    }
    label {
      en: "BackTrace Depth"
      zh: "最大堆栈导数"
    }
  }

  node_applications {
    desc {
      en: """List of Erlang applications that shall be rebooted when the EMQX broker joins the cluster.
          """
      zh: """当新EMQX 加入集群时，应重启的Erlang应用程序的列表。"""
    }
    label {
      en: "Application"
      zh: "应用"
    }
  }

  node_etc_dir {
    desc {
      en: """<code>etc</code> dir for the node"""
      zh: """<code>etc</code> 存放目录"""
    }
    label {
      en: "Etc Dir"
      zh: "Etc 目录"
    }
  }

  db_backend {
    desc {
      en: """
Select the backend for the embedded database.<br/>
<code>rlog</code> is the default backend,
that is suitable for very large clusters.<br/>
<code>mnesia</code> is a backend that offers decent performance in small clusters.
"""
      zh: """ rlog是默认的数据库，他适用于大规模的集群。
mnesia是备选数据库，在小集群中提供了很好的性能。
      """
    }
    label {
      en: "DB Backend"
      zh: "内置数据库"
    }
  }

  db_role {
    desc {
      en: """
Select a node role.<br/>
<code>core</code> nodes provide durability of the data, and take care of writes.
It is recommended to place core nodes in different racks or different availability zones.<br/>
<code>replicant</code> nodes are ephemeral worker nodes. Removing them from the cluster
doesn't affect database redundancy<br/>
It is recommended to have more replicant nodes than core nodes.<br/>
Note: this parameter only takes effect when the <code>backend</code> is set
to <code>rlog</code>.
"""
      zh: """
选择节点的角色。<br/>
<code>core</code> 节点提供数据的持久性，并负责写入。建议将核心节点放置在不同的机架或不同的可用区。<br/>
<code>repliant</code> 节点是临时工作节点。 从集群中删除它们，不影响数据库冗余<br/>
建议复制节点多于核心节点。<br/>
注意：该参数仅在设置<code>backend</code>时生效到 <code>rlog</code>。
          """
    }
    label {
      en: "DB Role"
      zh: "数据库角色"
    }
  }

  db_core_nodes {
    desc {
      en: """
List of core nodes that the replicant will connect to.<br/>
Note: this parameter only takes effect when the <code>backend</code> is set
to <code>rlog</code> and the <code>role</code> is set to <code>replicant</code>.<br/>
This value needs to be defined for manual or static cluster discovery mechanisms.<br/>
If an automatic cluster discovery mechanism is being used (such as <code>etcd</code>),
there is no need to set this value.
"""
      zh: """当前节点连接的核心节点列表。<br/>
注意：该参数仅在设置<code>backend</code>时生效到 <code>rlog</code>
并且设置<code>role</code>为<code>replicant</code>时生效。<br/>
该值需要在手动或静态集群发现机制下设置。<br/>
如果使用了自动集群发现机制（如<code>etcd</code>），则不需要设置该值。
          """
    }
    label {
      en: "Db Core Node"
      zh: "数据库核心节点"
    }
  }

  db_rpc_module {
    desc {
      en: """Protocol used for pushing transaction logs to the replicant nodes."""
      zh: """集群间推送事务日志到复制节点使用的协议。"""
    }
    label {
      en: "RPC Module"
      zh: "RPC协议"
    }
  }

  db_tlog_push_mode {
    desc {
      en: """
In sync mode the core node waits for an ack from the replicant nodes before sending the next
transaction log entry.
"""
      zh: """同步模式下，核心节点等待复制节点的确认信息，然后再发送下一条事务日志。"""
    }
    label {
      en: "Tlog Push Mode"
      zh: "Tlog推送模式"
    }
  }

  db_default_shard_transport {
    desc {
      en: """Defines the default transport for pushing transaction logs.<br/>
This may be overridden on a per-shard basis in <code>db.shard_transports</code>.
<code>gen_rpc</code> uses the <code>gen_rpc</code> library,
<code>distr</code> uses the Erlang distribution.<br/>"""
      zh: """
定义用于推送事务日志的默认传输。<br/>
这可以在 <code>db.shard_transports</code> 中基于每个分片被覆盖。
<code>gen_rpc</code> 使用 <code>gen_rpc</code> 库，
<code>distr</code> 使用 Erlang 发行版。<br/>
      """
    }
    label {
      en: "Default Shard Transport"
      zh: "事务日志传输默认协议"
    }
  }

  db_shard_transports {
    desc {
      en: """Allows to tune the transport method used for transaction log replication, on a per-shard basis.<br/>
<code>gen_rpc</code> uses the <code>gen_rpc</code> library,
<code>distr</code> uses the Erlang distribution.<br/>If not specified,
the default is to use the value set in <code>db.default_shard_transport</code>."""
      zh: """允许为每个 shard 下的事务日志复制操作的传输方法进行调优。<br/>
<code>gen_rpc</code> 使用 <code>gen_rpc</code> 库，
<code>distr</code> 使用 Erlang 自带的 rpc 库。<br/>如果未指定，
默认是使用 <code>db.default_shard_transport</code> 中设置的值。
      """
    }
    label {
      en: "Shard Transports"
      zh: "事务日志传输协议"
    }
  }

  cluster_call_retry_interval {
    desc {
      en: """Time interval to retry after a failed call."""
      zh: """当集群间调用出错时，多长时间重试一次。"""
    }
    label {
      en: "Cluster Call Retry Interval"
      zh: "重试时间间隔"
    }
  }

  cluster_call_max_history {
    desc {
      en: """Retain the maximum number of completed transactions (for queries)."""
      zh: """集群间调用最多保留的历史记录数。只用于排错时查看。"""
    }
    label {
      en: "Cluster Call Max History"
      zh: "最大历史记录"
    }
  }

  cluster_call_cleanup_interval {
    desc {
      en: """Time interval to clear completed but stale transactions.
Ensure that the number of completed transactions is less than the <code>max_history</code>."""
      zh: """清理过期事务的时间间隔"""
    }
    label {
      en: "Clean Up Interval"
      zh: "清理间隔"
    }
  }

  rpc_mode {
    desc {
      en: """In <code>sync</code> mode the sending side waits for the ack from the receiving side."""
      zh: """在 <code>sync</code> 模式下，发送端等待接收端的 ack信号。"""
    }
    label {
      en: "RPC Mode"
      zh: "RPC 模式"
    }
  }

  rpc_driver {
    desc {
      en: """Transport protocol used for inter-broker communication"""
      zh: """集群间通信使用的传输协议。"""
    }
    label {
      en: "RPC dirver"
      zh: "RPC 驱动"
    }
  }

  rpc_async_batch_size {
    desc {
      en: """The maximum number of batch messages sent in asynchronous mode.
      Note that this configuration does not work in synchronous mode.
      """
      zh: """异步模式下，发送的批量消息的最大数量。"""
    }
    label {
      en: "Async Batch Size"
      zh: "异步模式下的批量消息数量"
    }
  }

  rpc_port_discovery {
    desc {
      en: """<code>manual</code>: discover ports by <code>tcp_server_port</code>.<br/>
<code>stateless</code>: discover ports in a stateless manner, using the following algorithm.
If node name is <code>emqxN@127.0.0.1</code>, where the N is an integer,
then the listening port will be 5370 + N."""
      zh: """<code>manual</code>: 通过 <code>tcp_server_port</code> 来发现端口。
<br/><code>stateless</code>: 使用无状态的方式来发现端口，使用如下算法。如果节点名称是 <code>
emqxN@127.0.0.1</code>, N 是一个数字，那么监听端口就是 5370 + N。
         """
    }
    label {
      en: "RRC Port Discovery"
      zh: "RPC 端口发现策略"
    }
  }

  rpc_tcp_server_port {
    desc {
      en: """Listening port used by RPC local service.<br/>
Note that this config only takes effect when rpc.port_discovery is set to manual."""
      zh: """RPC 本地服务使用的 TCP 端口。<br/>
只有当 rpc.port_discovery 设置为 manual 时，此配置才会生效。
      """
    }
    label {
      en: "RPC TCP Server Port"
      zh: "RPC TCP 服务监听端口"
    }
  }

  rpc_ssl_server_port {
    desc {
      en: """Listening port used by RPC local service.<br/>
Note that this config only takes effect when rpc.port_discovery is set to manual
and <code>driver</code> is set to <code>ssl</code>."""
      zh: """RPC 本地服务使用的监听SSL端口。<br/>
只有当 rpc.port_discovery 设置为 manual 且 <code> dirver </code> 设置为 <code>ssl</code>，
此配置才会生效。
      """
    }
    label {
      en: "RPC SSL Server Port"
      zh: "RPC SSL 服务监听端口"
    }
  }

  rpc_tcp_client_num {
    desc {
      en: """Set the maximum number of RPC communication channels initiated by this node to each remote node."""
      zh: """设置本节点与远程节点之间的 RPC 通信通道的最大数量。"""
    }
    label {
      en: "RPC TCP Client Num"
      zh: "RPC TCP 客户端数量"
    }
  }

  rpc_connect_timeout {
    desc {
      en: """Timeout for establishing an RPC connection."""
      zh: """建立 RPC 连接的超时时间。"""
    }
    label {
      en: "RPC Connect Timeout"
      zh: "RPC 连接超时时间"
    }
  }

  rpc_certfile {
    desc {
      en: """Path to TLS certificate file used to validate identity of the cluster nodes.
Note that this config only takes effect when <code>rpc.driver</code> is set to <code>ssl</code>.
      """
      zh: """TLS 证书文件的路径，用于验证集群节点的身份。
只有当 <code>rpc.driver</code> 设置为 <code>ssl</code> 时，此配置才会生效。
      """
    }
    label {
      en: "RPC Certfile"
      zh: "RPC 证书文件"
    }
  }

  rpc_keyfile {
    desc {
      en: """Path to the private key file for the <code>rpc.certfile</code>.<br/>
Note: contents of this file are secret, so it's necessary to set permissions to 600."""
      zh: """<code>rpc.certfile</code> 的私钥文件的路径。<br/>
注意：此文件内容是私钥，所以需要设置权限为 600。
      """
    }
    label {
      en: "RPC Keyfile"
      zh: "RPC 私钥文件"
    }
  }

  rpc_cacertfile {
    desc {
      en: """Path to certification authority TLS certificate file used to validate <code>rpc.certfile</code>.<br/>
Note: certificates of all nodes in the cluster must be signed by the same CA."""
      zh: """验证 <code>rpc.certfile</code> 的 CA 证书文件的路径。<br/>
注意：集群中所有节点的证书必须使用同一个 CA 签发。
      """
    }
    label {
      en: "RPC Cacertfile"
      zh: "RPC CA 证书文件"
    }
  }

  rpc_send_timeout {
    desc {
      en: """Timeout for sending the RPC request."""
      zh: """发送 RPC 请求的超时时间。"""
    }
    label {
      en: "RPC Send Timeout"
      zh: "RPC 发送超时时间"
    }
  }

  rpc_authentication_timeout {
    desc {
      en: """Timeout for the remote node authentication."""
      zh: """远程节点认证的超时时间。"""
    }
    label {
      en: "RPC Authentication Timeout"
      zh: "RPC 认证超时时间"
    }
  }

  rpc_call_receive_timeout {
    desc {
      en: """Timeout for the reply to a synchronous RPC."""
      zh: """同步 RPC 的回复超时时间。"""
    }
    label {
      en: "RPC Call Receive Timeout"
      zh: "RPC 调用接收超时时间"
    }
  }

  rpc_socket_keepalive_idle {
    desc {
      en: """How long the connections between the brokers should remain open after the last message is sent."""
      zh: """broker 之间的连接在最后一条消息发送后保持打开的时间。"""
    }
    label {
      en: "RPC Socket Keepalive Idle"
      zh: "RPC Socket Keepalive Idle"
    }
  }

  rpc_socket_keepalive_interval {
    desc {
      en: """The interval between keepalive messages."""
      zh: """keepalive 消息的间隔。"""
    }
    label {
      en: "RPC Socket Keepalive Interval"
      zh: "RPC Socket Keepalive 间隔"
    }
  }

  rpc_socket_keepalive_count {
    desc {
      en: """How many times the keepalive probe message can fail to receive a reply
until the RPC connection is considered lost."""
      zh: """keepalive 探测消息发送失败的次数，直到 RPC 连接被认为已经断开。"""
    }
    label {
      en: "RPC Socket Keepalive Count"
      zh: "RPC Socket Keepalive 次数"
    }
  }

  rpc_socket_sndbuf {
    desc {
      en: """TCP tuning parameters. TCP sending buffer size."""
      zh: """TCP 调节参数。TCP 发送缓冲区大小。"""
    }
    label {
      en: "RPC Socket Sndbuf"
      zh: "RPC 套接字发送缓冲区大小"
    }
  }

  rpc_socket_recbuf {
    desc {
      en: """TCP tuning parameters. TCP receiving buffer size."""
      zh: """TCP 调节参数。TCP 接收缓冲区大小。"""
    }
    label {
      en: "RPC Socket Recbuf"
      zh: "RPC 套接字接收缓冲区大小"
    }
  }

  rpc_socket_buffer {
    desc {
      en: """TCP tuning parameters. Socket buffer size in user mode."""
      zh: """TCP 调节参数。用户模式套接字缓冲区大小。"""
    }
    label {
      en: "RPC Socket Buffer"
      zh: "RPC 套接字缓冲区大小"
    }
  }

  rpc_insecure_fallback {
    desc {
      en: """Enable compatibility with old RPC authentication."""
      zh: """兼容旧的无鉴权模式"""
    }
    label {
      en: "RPC insecure fallback"
      zh: "向后兼容旧的无鉴权模式"
    }
  }

  log_file_handlers {
    desc {
      en: """File-based log handlers."""
      zh: """输出到文件的日志处理进程列表"""
    }
    label {
      en: "File Handler"
      zh: "File Handler"
    }
  }

  common_handler_enable {
    desc {
      en: """Enable this log handler."""
      zh: """启用此日志处理进程。"""
    }
    label {
      en: "Enable Log Handler"
      zh: "启用日志处理进程"
    }
  }

  common_handler_level {
    desc {
      en: """
The log level for the current log handler.
Defaults to warning.
"""
      zh: """
当前日志处理进程的日志级别。
默认为 warning 级别。
"""
    }
    label {
      en: "Log Level"
      zh: "日志级别"
    }
  }

  common_handler_time_offset {
    desc {
      en: """
The time offset to be used when formatting the timestamp.
Can be one of:
  - <code>system</code>: the time offset used by the local system
  - <code>utc</code>: the UTC time offset
  - <code>+-[hh]:[mm]</code>: user specified time offset, such as "-02:00" or "+00:00"
Defaults to: <code>system</code>.
"""
      zh: """
日志中的时间戳使用的时间偏移量。
可选值为：
  - <code>system</code>: 本地系统使用的时区偏移量
  - <code>utc</code>: 0 时区的偏移量
  - <code>+-[hh]:[mm]</code>: 自定义偏移量，比如 "-02:00" 或者 "+00:00"
默认值为本地系统的时区偏移量：<code>system</code>。
"""
    }
    label {
      en: "Time Offset"
      zh: "时间偏移量"
    }
  }

  common_handler_chars_limit {
    desc {
      en: """
Set the maximum length of a single log message. If this length is exceeded, the log message will be truncated.
NOTE: Restrict char limiter if formatter is JSON , it will get a truncated incomplete JSON data, which is not recommended.
"""
      zh: """
设置单个日志消息的最大长度。 如果超过此长度，则日志消息将被截断。最小可设置的长度为100。
注意：如果日志格式为 JSON，限制字符长度可能会导致截断不完整的 JSON 数据。
"""
    }
    label {
      en: "Single Log Max Length"
      zh: "单条日志长度限制"
    }
  }

  common_handler_formatter {
    desc {
      en: """Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging."""
      zh: """选择日志格式类型。 <code>text</code> 用于纯文本，<code>json</code> 用于结构化日志记录。"""
    }
    label {
      en: "Log Formatter"
      zh: "日志格式类型"
    }
  }

  common_handler_single_line {
    desc {
      en: """Print logs in a single line if set to true. Otherwise, log messages may span multiple lines."""
      zh: """如果设置为 true，则单行打印日志。 否则，日志消息可能跨越多行。"""
    }
    label {
      en: "Single Line Mode"
      zh: "单行模式"
    }
  }

  common_handler_sync_mode_qlen {
    desc {
      en: """As long as the number of buffered log events is lower than this value,
all log events are handled asynchronously. This means that the client process sending the log event,
by calling a log function in the Logger API, does not wait for a response from the handler
but continues executing immediately after the event is sent.
It is not affected by the time it takes the handler to print the event to the log device.
If the message queue grows larger than this value,
the handler starts handling log events synchronously instead,
meaning that the client process sending the event must wait for a response.
When the handler reduces the message queue to a level below the sync_mode_qlen threshold,
asynchronous operation is resumed.
"""
      zh: """只要缓冲的日志事件的数量低于这个值，所有的日志事件都会被异步处理。
这意味着，日志落地速度不会影响正常的业务进程，因为它们不需要等待日志处理进程的响应。
如果消息队列的增长超过了这个值，处理程序开始同步处理日志事件。也就是说，发送事件的客户进程必须等待响应。
当处理程序将消息队列减少到低于sync_mode_qlen阈值的水平时，异步操作就会恢复。
默认为100条信息，当等待的日志事件大于100条时，就开始同步处理日志。"""
    }
    label {
      en: "Queue Length before Entering Sync Mode"
      zh: "进入异步模式的队列长度"
    }
  }

  common_handler_drop_mode_qlen {
    desc {
      en: """When the number of buffered log events is larger than this value, the new log events are dropped.
When drop mode is activated or deactivated, a message is printed in the logs."""
      zh: """当缓冲的日志事件数大于此值时，新的日志事件将被丢弃。起到过载保护的功能。
为了使过载保护算法正常工作必须要：<code> sync_mode_qlen =< drop_mode_qlen =< flush_qlen </code> 且 drop_mode_qlen > 1
要禁用某些模式，请执行以下操作。
- 如果sync_mode_qlen被设置为0，所有的日志事件都被同步处理。也就是说，异步日志被禁用。
- 如果sync_mode_qlen被设置为与drop_mode_qlen相同的值，同步模式被禁用。也就是说，处理程序总是以异步模式运行，除非调用drop或flushing。
- 如果drop_mode_qlen被设置为与flush_qlen相同的值，则drop模式被禁用，永远不会发生。
"""
    }
    label {
      en: "Queue Length before Entering Drop Mode"
      zh: "进入丢弃模式的队列长度"
    }
  }

  common_handler_flush_qlen {
    desc {
      en: """If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place.
To flush events, the handler discards the buffered log messages without logging."""
      zh: """如果缓冲日志事件的数量增长大于此阈值，则会发生冲刷（删除）操作。 日志处理进程会丢弃缓冲的日志消息。
来缓解自身不会由于内存瀑涨而影响其它业务进程。日志内容会提醒有多少事件被删除。"""
    }
    label {
      en: "Flush Threshold"
      zh: "冲刷阈值"
    }
  }

  common_handler_supervisor_reports {
    desc {
      en: """
Type of supervisor reports that are logged. Defaults to <code>error</code>
  - <code>error</code>: only log errors in the Erlang processes.
  - <code>progress</code>: log process startup.
"""
      zh: """
Supervisor 报告的类型。默认为 error 类型。
  - <code>error</code>：仅记录 Erlang 进程中的错误。
  - <code>progress</code>：除了 error 信息外，还需要记录进程启动的详细信息。
"""
    }
    label {
      en: "Report Type"
      zh: "报告类型"
    }
  }

  common_handler_max_depth {
    desc {
      en: """Maximum depth for Erlang term log formatting and Erlang process message queue inspection."""
      zh: """Erlang 内部格式日志格式化和 Erlang 进程消息队列检查的最大深度。"""
    }
    label {
      en: "Max Depth"
      zh: "最大深度"
    }
  }

  log_file_handler_file {
    desc {
      en: """Name the log file."""
      zh: """日志文件路径及名字。"""
    }
    label {
      en: "Log File Name"
      zh: "日志文件名字"
    }
  }

  log_file_handler_max_size {
    desc {
      en: """This parameter controls log file rotation. The value `infinity` means the log file will grow indefinitely, otherwise the log file will be rotated once it reaches `max_size` in bytes."""
      zh: """此参数控制日志文件轮换。 `infinity` 意味着日志文件将无限增长，否则日志文件将在达到 `max_size`（以字节为单位）时进行轮换。
与 rotation count配合使用。如果 counter 为 10，则是10个文件轮换。
"""
    }
    label {
      en: "Rotation Size"
      zh: "日志文件轮换大小"
    }
  }

  log_rotation_enable {
    desc {
      en: """Enable log rotation feature."""
      zh: """启用日志轮换功能。启动后生成日志文件后缀会加上对应的索引数字，比如：log/emqx.log.1。
系统会默认生成<code>*.siz/*.idx</code>用于记录日志位置，请不要手动修改这两个文件。
"""
    }
    label {
      en: "Rotation Enable"
      zh: "日志轮换"
    }
  }

  log_rotation_count {
    desc {
      en: """Maximum number of log files."""
      zh: """轮换的最大日志文件数。"""
    }
    label {
      en: "Max Log Files Number"
      zh: "最大日志文件数"
    }
  }

  log_overload_kill_enable {
    desc {
      en: """Enable log handler overload kill feature."""
      zh: """日志处理进程过载时为保护自己节点其它的业务能正常，强制杀死日志处理进程。"""
    }
    label {
      en: "Log Handler Overload Kill"
      zh: "日志处理进程过载保护"
    }
  }

  log_overload_kill_mem_size {
    desc {
      en: """Maximum memory size that the log handler process is allowed to use."""
      zh: """日志处理进程允许使用的最大内存。"""
    }
    label {
      en: "Log Handler Max Memory Size"
      zh: "日志处理进程允许使用的最大内存"
    }
  }

  log_overload_kill_qlen {
    desc {
      en: """Maximum allowed queue length."""
      zh: """允许的最大队列长度。"""
    }
    label {
      en: "Max Queue Length"
      zh: "最大队列长度"
    }
  }

  log_overload_kill_restart_after {
    desc {
      en: """If the handler is terminated, it restarts automatically after a delay specified in milliseconds. The value `infinity` prevents restarts."""
      zh: """如果处理进程终止，它会在以指定的时间后后自动重新启动。 `infinity` 不自动重启。"""
    }
    label {
      en: "Handler Restart Timer"
      zh: "处理进程重启机制"
    }
  }

  log_burst_limit_enable {
    desc {
      en: """Enable log burst control feature."""
      zh: """启用日志限流保护机制。"""
    }
    label {
      en: "Enable Burst"
      zh: "日志限流保护"
    }
  }

  log_burst_limit_max_count {
    desc {
      en: """Maximum number of log events to handle within a `window_time` interval. After the limit is reached, successive events are dropped until the end of the `window_time`."""
      zh: """在 `window_time` 间隔内处理的最大日志事件数。 达到限制后，将丢弃连续事件，直到 `window_time` 结束。"""
    }
    label {
      en: "Events Number"
      zh: "日志事件数"
    }
  }

  log_burst_limit_window_time {
    desc {
      en: """See <code>max_count</code>."""
      zh: """参考 <code>max_count</code>。"""
    }
    label {
      en: "Window Time"
      zh: "Window Time"
    }
  }

  authorization {
    desc {
      en: """
Authorization a.k.a. ACL.<br/>
In EMQX, MQTT client access control is extremely flexible.<br/>
An out-of-the-box set of authorization data sources are supported.
For example,<br/>
'file' source is to support concise and yet generic ACL rules in a file;<br/>
'built_in_database' source can be used to store per-client customizable rule sets,
natively in the EMQX node;<br/>
'http' source to make EMQX call an external HTTP API to make the decision;<br/>
'PostgreSQL' etc. to look up clients or rules from external databases;<br/>
"""
      zh: """ 授权（ACL）。EMQX 支持完整的客户端访问控制（ACL）。<br/> """
    }
    label {
      en: "Authorization"
      zh: "授权"
    }
  }

  desc_cluster {
    desc {
      en: """EMQX nodes can form a cluster to scale up the total capacity.<br/>
      Here holds the configs to instruct how individual nodes can discover each other."""
      zh: """EMQX 节点可以组成一个集群，以提高总容量。<br/> 这里指定了节点之间如何连接。"""
    }
    label {
      en: "Cluster"
      zh: "集群"
    }
  }

  desc_cluster_static {
    desc {
      en: """Service discovery via static nodes.
The new node joins the cluster by connecting to one of the bootstrap nodes."""
      zh: """静态节点服务发现。新节点通过连接一个节点来加入集群。"""
    }
    label {
      en: "Cluster Static"
      zh: "静态节点服务发现"
    }
  }

  desc_cluster_mcast {
    desc {
      en: """Service discovery via UDP multicast."""
      zh: """UDP 组播服务发现。"""
    }
    label {
      en: "Cluster Multicast"
      zh: "UDP 组播服务发现"
    }
  }

  desc_cluster_dns {
    desc {
      en: """Service discovery via DNS SRV records."""
      zh: """DNS SRV 记录服务发现。"""
    }
    label {
      en: "Cluster DNS"
      zh: "DNS SRV 记录服务发现"
    }
  }

  desc_cluster_etcd {
    desc {
      en: """Service discovery using 'etcd' service."""
      zh: """使用 'etcd' 服务的服务发现。"""
    }
    label {
      en: "Cluster Etcd"
      zh: "'etcd' 服务的服务发现"
    }
  }

  desc_cluster_k8s {
    desc {
      en: """Service discovery via Kubernetes API server."""
      zh: """Kubernetes 服务发现。"""
    }
    label {
      en: "Cluster Kubernetes"
      zh: "Kubernetes 服务发现"
    }
  }

  desc_node {
    desc {
      en: """Node name, cookie, config & data directories and the Erlang virtual machine (BEAM) boot parameters."""
      zh: """节点名称、Cookie、配置文件、数据目录和 Erlang 虚拟机（BEAM）启动参数。"""
    }
    label {
      en: "Node"
      zh: "节点"
    }
  }

  desc_db {
    desc {
      en: """Settings for the embedded database."""
      zh: """内置数据库的配置。"""
    }
    label {
      en: "Database"
      zh: "数据库"
    }
  }

  desc_cluster_call {
    desc {
      en: """Options for the 'cluster call' feature that allows to execute a callback on all nodes in the cluster."""
      zh: """集群调用功能的选项。"""
    }
    label {
      en: "Cluster Call"
      zh: "集群调用"
    }
  }

  desc_rpc {
    desc {
      en: """EMQX uses a library called <code>gen_rpc</code> for inter-broker communication.<br/>
Most of the time the default config should work,
but in case you need to do performance fine-tuning or experiment a bit,
this is where to look."""
      zh: """EMQX 使用 <code>gen_rpc</code> 库来实现跨节点通信。<br/>
大多数情况下，默认的配置应该可以工作，但如果你需要做一些性能优化或者实验，可以尝试调整这些参数。"""
    }
    label {
      en: "RPC"
      zh: "RPC"
    }
  }

  desc_log {
    desc {
      en: """EMQX logging supports multiple sinks for the log events.
Each sink is represented by a _log handler_, which can be configured independently."""
      zh: """EMQX 日志记录支持日志事件的多个接收器。 每个接收器由一个_log handler_表示，可以独立配置。"""
    }
    label {
      en: "Log"
      zh: "日志"
    }
  }

  desc_console_handler {
    desc {
      en: """Log handler that prints log events to the EMQX console."""
      zh: """日志处理进程将日志事件打印到 EMQX 控制台。"""
    }
    label {
      en: "Console Handler"
      zh: "Console Handler"
    }
  }

  desc_log_file_handler {
    desc {
      en: """Log handler that prints log events to files."""
      zh: """日志处理进程将日志事件打印到文件。"""
    }
    label {
      en: "Files Log Handler"
      zh: "文件日志处理进程"
    }
  }

  desc_log_rotation {
    desc {
      en: """
By default, the logs are stored in `./log` directory (for installation from zip file) or in `/var/log/emqx` (for binary installation).<br/>
This section of the configuration controls the number of files kept for each log handler.
"""
      zh: """
默认情况下，日志存储在 `./log` 目录（用于从 zip 文件安装）或 `/var/log/emqx`（用于二进制安装）。<br/>
这部分配置，控制每个日志处理进程保留的文件数量。
"""
    }
    label {
      en: "Log Rotation"
      zh: "日志轮换"
    }
  }

  desc_log_overload_kill {
    desc {
      en: """
Log overload kill features an overload protection that activates when the log handlers use too much memory or have too many buffered log messages.<br/>
When the overload is detected, the log handler is terminated and restarted after a cooldown period.
"""
      zh: """
日志过载终止，具有过载保护功能。当日志处理进程使用过多内存，或者缓存的日志消息过多时该功能被激活。<br/>
检测到过载时，日志处理进程将终止，并在冷却期后重新启动。
"""
    }
    label {
      en: "Log Overload Kill"
      zh: "日志过载保护"
    }
  }

  desc_log_burst_limit {
    desc {
      en: """Large bursts of log events produced in a short time can potentially cause problems, such as:
 - Log files grow very large
 - Log files are rotated too quickly, and useful information gets overwritten
 - Overall performance impact on the system

Log burst limit feature can temporarily disable logging to avoid these issues."""
      zh: """短时间内产生的大量日志事件可能会导致问题，例如：
  - 日志文件变得非常大
  - 日志文件轮换过快，有用信息被覆盖
  - 对系统的整体性能影响

日志突发限制功能可以暂时禁用日志记录以避免这些问题。"""
    }
    label {
      en: "Log Burst Limit"
      zh: "日志突发限制"
    }
  }

  desc_authorization {
    desc {
      en: """Settings that control client authorization."""
      zh: """授权相关"""
    }
    label {
      en: "Authorization"
      zh: "授权"
    }
  }
}

emqx_bridge_api {

    desc_param_path_operation_cluster {
                   desc {
                         en: """Operations can be one of: enable, disable, start, stop, restart"""
                         zh: """集群可用操作：启用、禁用、启动、停止、重新启动"""
                        }
                   label: {
                           en: "Cluster Operation"
                           zh: "集群可用操作"
                          }
                  }

    desc_param_path_operation_on_node {
                   desc {
                         en: """Operations can be one of: stop, restart"""
                         zh: """节点可用操作：停止、重新启动"""
                        }
                   label: {
                           en: "Node Operation "
                           zh: "节点可用操作"
                          }
                  }

    desc_param_path_node {
                   desc {
                         en: """The node name, e.g. emqx@127.0.0.1"""
                         zh: """节点名，比如 emqx@127.0.0.1"""
                        }
                   label: {
                           en: "The node name"
                           zh: "节点名"
                          }
                  }

    desc_param_path_id {
                   desc {
                         en: """The bridge Id. Must be of format {type}:{name}"""
                         zh: """Bridge ID ， 格式为 {type}:{name}"""
                        }
                   label: {
                           en: "Bridge ID"
                           zh: "Bridge ID"
                          }
                  }

    desc_api1 {
                   desc {
                         en: """List all created bridges"""
                         zh: """列出所有 Birdge """
                        }
                   label: {
                           en: "List All Bridges"
                           zh: "列出所有 Bridge"
                          }
                  }

    desc_api2 {
                   desc {
                         en: """Create a new bridge by type and name"""
                         zh: """通过类型和名字创建 Bridge"""
                        }
                   label: {
                           en: "Create Bridge"
                           zh: "创建 Bridge"
                          }
                  }

    desc_api3 {
                   desc {
                         en: """Get a bridge by Id"""
                         zh: """通过 ID 获取 Bridge"""
                        }
                   label: {
                           en: "Get Bridge"
                           zh: "获取 Bridge"
                          }
                  }

    desc_api4 {
                   desc {
                         en: """Update a bridge by Id"""
                         zh: """通过 ID 更新 Bridge"""
                        }
                   label: {
                           en: "Update Bridge"
                           zh: "更新 Bridge"
                          }
                  }

    desc_api5 {
                   desc {
                         en: """Delete a bridge by Id"""
                         zh: """通过 ID 删除 Bridge"""
                        }
                   label: {
                           en: "Delete Bridge"
                           zh: "删除 Bridge"
                          }
                  }

    desc_api6 {
                   desc {
                         en: """Reset a bridge metrics by Id"""
                         zh: """通过 ID 重置 Bridge 的计数"""
                        }
                   label: {
                           en: "Reset Bridge Metrics"
                           zh: "重置 Bridge 计数"
                          }
                  }

    desc_api7 {
                   desc {
                         en: """Enable/Disable/Stop/Restart bridges on all nodes in the cluster."""
                         zh: """在集群中的所有节点上启用/禁用/停止/重新启动 Bridge。"""
                        }
                   label: {
                           en: "Cluster Bridge Operate"
                           zh: "集群 Bridge 操作"
                          }
                  }

    desc_api8 {
                   desc {
                         en: """Stop/Restart bridges on a specific node.
 NOTE: It's not allowed to disable/enable bridges on a single node."""
                         zh: """在某个节点上停止/重新启动 Bridge。
NOTE：不允许在单节点上启用/禁用 Bridge"""
                        }
                   label: {
                           en: "Node Bridge Operate"
                           zh: "单节点 Bridge 操作"
                          }
                  }

}

emqx_bridge_mqtt_schema {

    desc_rec {
                   desc {
                         en: """Configuration for MQTT bridge."""
                         zh: """MQTT Bridge 配置"""
                        }
                   label: {
                           en: "MQTT Bridge Configuration"
                           zh: "MQTT Bridge 配置"
                          }
                  }

    desc_type {
                   desc {
                         en: """The bridge type."""
                         zh: """Bridge 的类型"""
                        }
                   label: {
                           en: "Bridge Type"
                           zh: "Bridge 类型"
                          }
                  }

    desc_name {
                   desc {
                         en: """Bridge name, used as a human-readable description of the bridge."""
                         zh: """Bridge 名字，Bridge 的可读描述"""
                        }
                   label: {
                           en: "Bridge Name"
                           zh: "Bridge 名字"
                          }
                  }

}

emqx_bridge_schema {

    desc_enable {
                   desc {
                         en: """Enable or disable this bridge"""
                         zh: """启用/禁用 Bridge"""
                        }
                   label: {
                           en: "Enable Or Disable Bridge"
                           zh: "启用/禁用 Bridge"
                          }
                  }

    desc_connector {
                   desc {
                         en: """
The ID or the configs of the connector to be used for this bridge. Connector IDs must be of format:
<code>{type}:{name}</code>.<br/>
In config files, you can find the corresponding config entry for a connector by such path:
'connectors.{type}.{name}'.<br/>
"""
                         zh: """
Bridge 使用的 Connector 的 ID 或者配置。Connector ID 的格式必须为：<code>{type}:{name}</code>。<br/>
在配置文件中，您可以通过以下路径找到 Connector 的相应配置条目：'connector.{type}.{name}'。<br/>"""
                        }
                   label: {
                           en: "Connector ID"
                           zh: "Connector ID"
                          }
                  }

    desc_metrics {
                   desc {
                         en: """The metrics of the bridge"""
                         zh: """Bridge 的计数"""
                        }
                   label: {
                           en: "Bridge Metrics"
                           zh: "Bridge 计数"
                          }
                  }

    desc_node_metrics {
                   desc {
                         en: """The metrics of the bridge for each node"""
                         zh: """每个节点的 Bridge 计数"""
                        }
                   label: {
                           en: "Each Node Bridge Metircs"
                           zh: "每个节点的 Bridge 计数"
                          }
                  }

    desc_status {
                   desc {
                         en: """The status of the bridge"""
                         zh: """Bridge 的状态"""
                        }
                   label: {
                           en: "Bridge Status"
                           zh: "Bridge 状态"
                          }
                  }

    desc_node_status {
                   desc {
                         en: """The status of the bridge for each node"""
                         zh: """每个节点的 Bridge 状态"""
                        }
                   label: {
                           en: "Node Bridge Status"
                           zh: "每个节点的 Bridge 状态"
                          }
                  }

    bridges_webhook {
                   desc {
                         en: """WebHook to an HTTP server."""
                         zh: """转发消息到 HTTP 服务器的 WebHook"""
                        }
                   label: {
                           en: "WebHook"
                           zh: "WebHook"
                          }
                  }


    bridges_name {
                   desc {
                         en: """MQTT bridges to/from another MQTT broker"""
                         zh: """桥接到另一个 MQTT Broker 的 MQTT Bridge"""
                        }
                   label: {
                           en: "MQTT Bridge"
                           zh: "MQTT Bridge"
                          }
                  }

    metric_matched {
                   desc {
                         en: """Count of this bridge is queried"""
                         zh: """Bridge 执行操作的次数"""
                        }
                   label: {
                           en: "Bridge Matched"
                           zh: "Bridge 执行操作的次数"
                          }
                  }

    metric_success {
                   desc {
                         en: """Count of query success"""
                         zh: """Bridge 执行操作成功的次数"""
                        }
                   label: {
                           en: "Bridge Success"
                           zh: "Bridge 执行操作成功的次数"
                          }
                  }

    metric_failed {
                   desc {
                         en: """Count of query failed"""
                         zh: """Bridge 执行操作失败的次数"""
                        }
                   label: {
                           en: "Bridge Failed"
                           zh: "Bridge 执行操作失败的次数"
                          }
                  }

    metric_rate {
                   desc {
                         en: """The rate of matched, times/second"""
                         zh: """执行操作的速率，次/秒"""
                        }
                   label: {
                           en: "Rate"
                           zh: "速率"
                          }
                  }

    metric_rate_max {
                   desc {
                         en: """The max rate of matched, times/second"""
                         zh: """执行操作的最大速率，次/秒"""
                        }
                   label: {
                           en: "Max Rate Of Matched"
                           zh: "执行操作的最大速率"
                          }
                  }

    metric_rate_last5m {
                   desc {
                         en: """The average rate of matched in the last 5 minutes, times/second"""
                         zh: """5 分钟平均速率，次/秒"""
                        }
                   label: {
                           en: "Last 5 Minutes Rate"
                           zh: "5 分钟平均速率"
                          }
                  }

    desc_bridges {
                   desc {
                         en: """Configuration for MQTT bridges."""
                         zh: """MQTT Bridge 配置"""
                        }
                   label: {
                           en: "MQTT Bridge Configuration"
                           zh: "MQTT Bridge 配置"
                          }
                  }

    desc_metrics {
                   desc {
                         en: """Bridge metrics."""
                         zh: """Bridge 计数"""
                        }
                   label: {
                           en: "Bridge Metrics"
                           zh: "Bridge 计数"
                          }
                  }

    desc_node_metrics {
                   desc {
                         en: """Node metrics."""
                         zh: """节点的计数器"""
                        }
                   label: {
                           en: "Node Metrics"
                           zh: "节点的计数器"
                          }
                  }

    desc_node_status {
                   desc {
                         en: """Node status."""
                         zh: """节点的状态"""
                        }
                   label: {
                           en: "Node Status"
                           zh: "节点的状态"
                          }
                  }

    desc_node_name {
                   desc {
                         en: """The node name."""
                         zh: """节点的名字"""
                        }
                   label: {
                           en: "Node Name"
                           zh: "节点名字"
                          }
                  }

}

emqx_bridge_webhook_schema {

    config_enable {
                   desc {
                         en: """Enable or disable this bridge"""
                         zh: """启用/禁用 Bridge"""
                        }
                   label: {
                           en: "Enable Or Disable Bridge"
                           zh: "启用/禁用 Bridge"
                          }
                  }

    config_direction {
                   desc {
                         en: """The direction of this bridge, MUST be 'egress'"""
                         zh: """Bridge 的方向， 必须是 egress"""
                        }
                   label: {
                           en: "Bridge Direction"
                           zh: "Bridge 方向"
                          }
                  }

    config_url {
                   desc {
                         en: """
The URL of the HTTP Bridge.<br/>
Template with variables is allowed in the path, but variables cannot be used in the scheme, host,
or port part.<br/>
For example, <code> http://localhost:9901/${topic} </code> is allowed, but
<code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code>
is not allowed.
"""
                         zh: """
HTTP Bridge 的 URL。<br/>
路径中允许使用带变量的模板，但是 host， port 不允许使用变量模板。<br/>
例如，<code> http://localhost:9901/${topic} </code> 是允许的，
但是<code> http://${host}:9901/message </code>
或 <code> http://localhost:${port}/message </code>
不允许。
"""
                        }
                   label: {
                           en: "HTTP Bridge"
                           zh: "HTTP Bridge"
                          }
                  }

    config_local_topic {
                   desc {
                         en: """
The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.<br/>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded.
"""
                         zh: """
发送到 'local_topic' 的消息都会转发到 HTTP 服务器。 <br/>
注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 HTTP 服务器。
"""
                        }
                   label: {
                           en: "Local Topic"
                           zh: "本地 Topic"
                          }
                  }

    config_method {
                   desc {
                         en: """
The method of the HTTP request. All the available methods are: post, put, get, delete.<br/>
Template with variables is allowed.<br/>
"""
                         zh: """
HTTP 请求的方法。 所有可用的方法包括：post、put、get、delete。<br/>
允许使用带有变量的模板。<br/>"""
                        }
                   label: {
                           en: "HTTP Method"
                           zh: "HTTP 请求方法"
                          }
                  }

    config_headers {
                   desc {
                         en: """
The headers of the HTTP request.<br/>
Template with variables is allowed.
"""
                         zh: """
HTTP 请求的标头。<br/>
允许使用带有变量的模板。
"""
                        }
                   label: {
                           en: "HTTP Header"
                           zh: "HTTP 请求标头"
                          }
                  }

    config_body {
                   desc {
                         en: """
The body of the HTTP request.<br/>
Template with variables is allowed.
"""
                         zh: """
HTTP 请求的正文。<br/>
允许使用带有变量的模板。"""
                        }
                   label: {
                           en: "HTTP Body"
                           zh: "HTTP 请求正文"
                          }
                  }

    config_request_timeout {
                   desc {
                         en: """HTTP request timeout."""
                         zh: """HTTP 请求超时"""
                        }
                   label: {
                           en: "HTTP Request Timeout"
                           zh: "HTTP 请求超时"
                          }
                  }

    config_max_retries {
                   desc {
                         en: """HTTP request max retry times if failed."""
                         zh: """HTTP 请求失败最大重试次数"""
                        }
                   label: {
                           en: "HTTP Request Max Retries"
                           zh: "HTTP 请求重试次数"
                          }
                  }

    desc_type {
                   desc {
                         en: """The Bridge Type"""
                         zh: """Bridge 类型"""
                        }
                   label: {
                           en: "Bridge Type"
                           zh: "Bridge 类型"
                          }
                  }

    desc_name {
                   desc {
                         en: """Bridge name, used as a human-readable description of the bridge."""
                         zh: """Bridge 名字，Bridge 的可读描述"""
                        }
                   label: {
                           en: "Bridge Name"
                           zh: "Bridge 名字"
                          }
                  }

    desc_config {
                   desc {
                         en: """Configuration for an HTTP bridge."""
                         zh: """HTTP Bridge 配置"""
                        }
                   label: {
                           en: "HTTP Bridge Configuration"
                           zh: "HTTP Bridge 配置"
                          }
                  }

}

emqx_auto_subscribe_api {
  list_auto_subscribe_api {
    desc {
      en: """Get auto subscribe topic list"""
      zh: """获取自动订阅主题列表"""
    }
  }

  update_auto_subscribe_api {
    desc {
      en: """Update auto subscribe topic list"""
      zh: """更新自动订阅主题列表"""
    }
  }

  update_auto_subscribe_api_response409 {
    desc {
      en: """Auto Subscribe topics max limit"""
      zh: """超出自定订阅主题列表长度限制"""
    }
  }

}

emqx_auto_subscribe_schema {
  auto_subscribe {
    desc {
      en: """After the device logs in successfully, the subscription is automatically completed for the device through the pre-defined subscription representation. Supports the use of placeholders."""
      zh: """设备登录成功之后，通过预设的订阅表示符，为设备自动完成订阅。支持使用占位符。"""
    }
    lable {
      en: """Auto Subscribe"""
      zh: """自动订阅"""
    }
  }

  topic {
    desc {
      en: """Topic name, placeholders are supported. For example: client/${clientid}/username/${username}/host/${host}/port/${port}
Required field, and cannot be empty string"""
      zh: """订阅标识符，支持使用占位符，例如 client/${clientid}/username/${username}/host/${host}/port/${port}
必填，且不可为空字符串"""
    }
    label {
      en: """Topic"""
      zh: """订阅标识符"""
    }
  }

  qos {
    desc {
      en: """Default value 0. Quality of service.
At most once (0)
At least once (1)
Exactly once (2)"""
      zh: """缺省值为 0，服务质量，
QoS 0：消息最多传递一次，如果当时客户端不可用，则会丢失该消息。
QoS 1：消息传递至少 1 次。
QoS 2：消息仅传送一次。"""
    }
    label {
      en: """Quality of Service"""
      zh: """服务质量"""
    }
  }

  rh {
    desc {
      en: """Default value 0. This option is used to specify whether the server forwards the retained message to the client when establishing a subscription.
Retain Handling is equal to 0, as long as the client successfully subscribes, the server will send the retained message.
Retain Handling is equal to 1, if the client successfully subscribes and this subscription does not exist previously, the server sends the retained message. After all, sometimes the client re-initiate the subscription just to change the QoS, but it does not mean that it wants to receive the reserved messages again.
Retain Handling is equal to 2, even if the client successfully subscribes, the server does not send the retained message."""
      zh: """指定订阅建立时服务端是否向客户端发送保留消息，
可选值 0：只要客户端订阅成功，服务端就发送保留消息。
可选值 1：客户端订阅成功且该订阅此前不存在，服务端才发送保留消息。毕竟有些时候客户端重新发起订阅可能只是为了改变一下 QoS，并不意味着它想再次接收保留消息。
可选值 2：即便客户订阅成功，服务端也不会发送保留消息。"""
    }
    label {
      en: """Retain Handling"""
      zh: """Retain Handling"""
    }
  }

  rap {
    desc {
      en: """Default value 0. This option is used to specify whether the server retains the RETAIN mark when forwarding messages to the client, and this option does not affect the RETAIN mark in the retained message. Therefore, when the option Retain As Publish is set to 0, the client will directly distinguish whether this is a normal forwarded message or a retained message according to the RETAIN mark in the message, instead of judging whether this message is the first received after subscribing(the forwarded message may be sent before the retained message, which depends on the specific implementation of different brokers)."""
      zh: """缺省值为 0，这一选项用来指定服务端向客户端转发消息时是否要保留其中的 RETAIN 标识，注意这一选项不会影响保留消息中的 RETAIN 标识。因此当 Retain As Publish 选项被设置为 0 时，客户端直接依靠消息中的 RETAIN 标识来区分这是一个正常的转发消息还是一个保留消息，而不是去判断消息是否是自己订阅后收到的第一个消息（转发消息甚至可能会先于保留消息被发送，视不同 Broker 的具体实现而定）。"""
    }
    label {
      en: """Retain As Publish"""
      zh: """Retain As Publish"""
    }
  }

  nl {
    desc {
      en: """Default value 0.
MQTT v3.1.1： if you subscribe to the topic published by yourself, you will receive all messages that you published.
MQTT v5: if you set this option as 1 when subscribing, the server will not forward the message you published to you."""
      zh: """缺省值为0，
MQTT v3.1.1：如果设备订阅了自己发布消息的主题，那么将收到自己发布的所有消息。
MQTT v5：如果设备在订阅时将此选项设置为 1，那么服务端将不会向设备转发自己发布的消息"""
    }
    label {
      en: """No Local"""
      zh: """No Local"""
    }
  }
}

emqx_authz_api_cache {
  authorization_cache_delete {
    desc {
      en: """Clean all authorization cache in the cluster."""
      zh: """清除集群中所有授权数据缓存。"""
    }
  }
}

emqx_authz_api_mnesia {
  users_username_get {
    desc {
      en: """Show the list of record for username"""
      zh: """获取内置数据库中所有用户名类型的规则记录"""
    }
  }

  users_username_post {
    desc {
      en: """Add new records for username"""
      zh: """添加内置数据库中用户名类型的规则记录"""
    }
  }

  users_clientid_get {
    desc {
      en: """Show the list of record for clientid"""
      zh: """获取内置数据库中所有客户端标识符类型的规则记录"""
    }
  }

  users_clientid_post {
    desc {
      en: """Add new records for clientid"""
      zh: """添加内置数据库中客户端标识符类型的规则记录"""
    }
  }


  user_username_get {
    desc {
      en: """Get record info for username"""
      zh: """获取内置数据库中指定用户名类型的规则记录"""
    }
  }

  user_username_put {
    desc {
      en: """Set record for username"""
      zh: """更新内置数据库中指定用户名类型的规则记录"""
    }
  }

  user_username_delete {
    desc {
      en: """Delete one record for username"""
      zh: """删除内置数据库中指定用户名类型的规则记录"""
    }
  }

  user_clientid_get {
    desc {
      en: """Get record info for clientid"""
      zh: """获取内置数据库中指定客户端标识符类型的规则记录"""
    }
  }

  user_clientid_put {
    desc {
      en: """Set record for clientid"""
      zh: """更新内置数据库中指定客户端标识符类型的规则记录"""
    }
  }

  user_clientid_delete {
    desc {
      en: """Delete one record for clientid"""
      zh: """删除内置数据库中指定客户端标识符类型的规则记录"""
    }
  }


  rules_for_all_get {
    desc {
      en: """Show the list of rules for all"""
      zh: """列出为所有客户端启用的规则列表"""
    }
  }

  rules_for_all_post {
    desc {
      en: """
Create/Update the list of rules for all.
Set a empty list to clean up rules
"""
      zh: """
创建/更新 为所有客户端启用的规则列表。
设为空列表以清楚所有规则
"""
    }
  }

  purge_all_delete {
    desc {
      en: """Purge all records for username/clientid/all"""
      zh: """清除所有内置数据库中的规则, 用户名/客户端标识符/所有"""
    }
  }

  fuzzy_username {
    desc {
      en: """Fuzzy search `username` as substring"""
      zh: """使用字串匹配模糊搜索用户名"""
    }
    label {
      en: """fuzzy_username"""
      zh: """用户名子串"""
    }
  }

  fuzzy_clientid {
    desc {
      en: """Fuzzy search `clientid` as substring"""
      zh: """使用字串匹配模糊搜索客户端标识符"""
    }
    label {
      en: """fuzzy_clientid"""
      zh: """客户端标识符子串"""
    }
  }

  topic {
    desc {
      en: """Rule on specific topic"""
      zh: """在指定主题上的规则"""
    }
    label {
      en: """topic"""
      zh: """主题"""
    }
  }

  permission {
    desc {
      en: """Permission"""
      zh: """权限"""
    }
    label {
      en: """permission"""
      zh: """权限"""
    }
  }

  action {
    desc {
      en: """Authorized action (pub/sub/all)"""
      zh: """被授权的行为 (发布/订阅/所有)"""
    }
    label {
      en: """action"""
      zh: """行为"""
    }
  }

  clientid {
    desc {
      en: """ClientID"""
      zh: """客户端标识符"""
    }
    label {
      en: """clientid"""
      zh: """客户端标识符"""
    }
  }

  username {
    desc {
      en: """Username"""
      zh: """用户名"""
    }
    label {
      en: """username"""
      zh: """用户名"""
    }
  }
}

emqx_authz_api_schema {
  enable {
    desc {
      en: """Set to <code>true</code> or <code>false</code> to disable this ACL provider."""
      zh: """设为 <code>true</code> 或 <code>false</code> 以启用或禁用此访问控制数据源。"""
    }
    label {
      en: """enable"""
      zh: """enable"""
    }
  }

  type {
    desc {
      en: """Backend type."""
      zh: """数据后端类型。"""
    }
    label {
      en: """type"""
      zh: """type"""
    }
  }

#==== authz_file

  rules {
    desc {
      en: """Authorization static file rules."""
      zh: """静态授权文件规则。"""
    }
    label {
      en: """rules"""
      zh: """规则"""
    }
  }

#==== authz_http

  method {
    desc {
      en: """HTTP method."""
      zh: """HTTP 请求方法。"""
    }
    label {
      en: """method"""
      zh: """method"""
    }
  }

  url {
    desc {
      en: """URL of the auth server."""
      zh: """认证服务器 URL。"""
    }
    label {
      en: """url"""
      zh: """url"""
    }
  }

  headers {
    desc {
      en: """List of HTTP Headers."""
      zh: """HTTP Headers 列表"""
    }
    label {
      en: """Headers"""
      zh: """请求头"""
    }
  }

  headers_no_content_type {
    desc {
      en: """List of HTTP headers (without <code>content-type</code>)."""
      zh: """HTTP Headers 列表（无 <code>content-type</code>）。"""
    }
    label {
      en: """headers_no_content_type"""
      zh: """请求头(无 content-type)"""
    }
  }

  body {
    desc {
      en: """HTTP request body."""
      zh: """HTTP 请求体。"""
    }
    label {
      en: """body"""
      zh: """请求体"""
    }
  }

  request_timeout {
    desc {
      en: """Request timeout."""
      zh: """请求超时时间。"""
    }
    label {
      en: """request_timeout"""
      zh: """请求超时"""
    }
  }

#==== authz_mnesia

# only common fields(`enable` and `type`)

#==== authz_mongo

  collection {
    desc {
      en: """`MongoDB` collection containing the authorization data."""
      zh: """`MongoDB` 授权数据集。"""
    }
    label {
      en: """collection"""
      zh: """数据集"""
    }
  }

  filter {
    desc {
      en: """
Conditional expression that defines the filter condition in the query.
Filter supports the following placeholders:
 - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting
 - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting
"""
      zh: """
在查询中定义过滤条件的条件表达式。
过滤器支持如下占位符：
- <code>${username}</code>: 将在运行时被替换为客户端连接时使用的用户名
- <code>${clientid}</code>: 将在运行时被替换为客户端连接时使用的客户端标识符
"""
    }
    label {
      en: """Filter"""
      zh: """过滤器"""
    }
  }

#==== authz_mysql

# `query`, is common field

#==== authz_pgsql

# `query`, is common field

#==== authz_redis

  cmd {
    desc {
      en: """Database query used to retrieve authorization data."""
      zh: """访问控制数据查询命令。"""
    }
    label {
      en: """cmd"""
      zh: """查询命令"""
    }
  }

#==== common field for DBs (except mongodb and redis)

  query {
    desc {
      en: """Database query used to retrieve authorization data."""
      zh: """访问控制数据查询语句。"""
    }
    label {
      en: """query"""
      zh: """查询语句"""
    }
  }

#==== fields

  position {
    desc {
      en: """Where to place the source."""
      zh: """认证数据源位置。"""
    }
    label {
      en: """position"""
      zh: """位置"""
    }
  }
}

emqx_authz_api_settings {
  authorization_settings_get {
    desc {
      en: """Get authorization settings"""
      zh: """获取授权配置"""
    }
  }

  authorization_settings_put {
    desc {
      en: """Update authorization settings"""
      zh: """更新授权配置"""
    }
  }
}

emqx_authz_api_sources {
  authorization_sources_get {
    desc {
      en: """List all authorization sources"""
      zh: """列出所有授权数据源"""
    }
  }

  authorization_sources_post {
    desc {
      en: """Add a new source"""
      zh: """添加授权数据源"""
    }
  }

  authorization_sources_type_get {
    desc {
      en: """Get a authorization source"""
      zh: """获取指定类型的授权数据源"""
    }
  }

  authorization_sources_type_put {
    desc {
      en: """Update source"""
      zh: """更新指定类型的授权数据源"""
    }
  }

  authorization_sources_type_delete {
    desc {
      en: """Delete source"""
      zh: """删除指定类型的授权数据源"""
    }
  }

  authorization_sources_type_status_get {
    desc {
      en: """Get a authorization source"""
      zh: """获取指定授权数据源的状态"""
    }
  }

  authorization_sources_type_move_post {
    desc {
      en: """Change the exection order of sources"""
      zh: """更新授权数据源的优先执行顺序"""
    }
  }

  sources {
    desc {
      en: """Authorization source"""
      zh: """授权数据源列表"""
    }
    label {
      en: """sources"""
      zh: """数据源列表"""
    }
  }

  sources {
    desc {
      en: """Authorization sources"""
      zh: """授权数据源列表"""
    }
    label {
      en: """sources"""
      zh: """数据源列表"""
    }
  }

  source_config {
    desc {
      en: """Source config"""
      zh: """数据源配置"""
    }
    label {
      en: """source_config"""
      zh: """数据源配置"""
    }
  }

  source {
    desc {
      en: """Authorization source"""
      zh: """授权数据源"""
    }
    label {
      en: """source"""
      zh: """数据源"""
    }
  }

  source_config {
    desc {
      en: """Source config"""
      zh: """数据源配置"""
    }
    label {
      en: """source_config"""
      zh: """数据源配置"""
    }
  }

  source_type {
    desc {
      en: """Authorization type"""
      zh: """数据源类型"""
    }
    label {
      en: """source_type"""
      zh: """数据源类型"""
    }
  }
}

emqx_authz_schema {
  sources {
    desc {
      en: """
Authorization data sources.<br/>
An array of authorization (ACL) data providers.
It is designed as an array, not a hash-map, so the sources can be
ordered to form a chain of access controls.<br/>

When authorizing a 'publish' or 'subscribe' action, the configured
sources are checked in order. When checking an ACL source,
in case the client (identified by username or client ID) is not found,
it moves on to the next source. And it stops immediately
once an 'allow' or 'deny' decision is returned.<br/>

If the client is not found in any of the sources,
the default action configured in 'authorization.no_match' is applied.<br/>

NOTE:
The source elements are identified by their 'type'.
It is NOT allowed to configure two or more sources of the same type.
"""
      zh: """
授权数据源。<br/>
授权（ACL）数据源的列表。
它被设计为一个数组，而不是一个散列映射，
所以可以作为链式访问控制。<br/>

当授权一个 'publish' 或 'subscribe' 行为时，
该配置列表中的所有数据源将按顺序进行检查。
如果在某个客户端未找到时(使用 ClientID 或 Username)。
将会移动到下一个数据源。直至得到 'allow' 或 'deny' 的结果。<br/>

如果在任何数据源中都未找到对应的客户端信息。
配置的默认行为 ('authorization.no_match') 将生效。<br/>

注意：
数据源使用 'type' 进行标识。
使用同一类型的数据源多于一次不被允许。
"""
    }
    label {
      en: """sources"""
      zh: """数据源"""
    }
  }

  authorization {
    desc {
      en: """Configuration related to the client authorization."""
      zh: """客户端授权相关配置"""
    }
    label {
      en: """authorization"""
      zh: """授权"""
    }
  }

  enable {
    desc {
      en: """Set to <code>true</code> or <code>false</code> to disable this ACL provider"""
      zh: """设为 <code>true</code> 或 <code>false</code> 以启用或禁用此访问控制数据源"""
    }
    label {
      en: """enable"""
      zh: """enable"""
    }
  }

  type {
    desc {
      en: """Backend type."""
      zh: """数据后端类型"""
    }
    label {
      en: """type"""
      zh: """type"""
    }
  }

#==== authz_file

  file {
    desc {
      en: """Authorization using a static file."""
      zh: """使用静态文件授权"""
    }
    label {
      en: """file"""
      zh: """文件"""
    }
  }

  path {
    desc {
      en: """
Path to the file which contains the ACL rules.
If the file provisioned before starting EMQX node,
it can be placed anywhere as long as EMQX has read access to it.
That is, EMQX will treat it as read only.

In case the rule-set is created or updated from EMQX Dashboard or HTTP API,
a new file will be created and placed in `authz` subdirectory inside EMQX's `data_dir`,
and the old file will not be used anymore.
"""
      zh: """
包含 ACL 规则的文件路径。
如果在启动 EMQX 节点前预先配置该路径，
那么可以将该文件置于任何 EMQX 可以访问到的位置。

如果从 EMQX Dashboard 或 HTTP API 创建或修改了规则集，
那么EMQX将会生成一个新的文件并将它存放在 `data_dir` 下的 `authz` 子目录中，
并从此弃用旧的文件。"""
    }
    label {
      en: """path"""
      zh: """path"""
    }
  }

#==== authz_http

  http_get {
    desc {
      en: """Authorization using an external HTTP server (via GET requests)."""
      zh: """使用外部 HTTP 服务器授权(GET 请求)。"""
    }
    label {
      en: """http_get"""
      zh: """http_get"""
    }
  }

  http_post {
    desc {
      en: """Authorization using an external HTTP server (via POST requests)."""
      zh: """使用外部 HTTP 服务器授权(POST 请求)。"""
    }
    label {
      en: """http_post"""
      zh: """http_post"""
    }
  }

  method {
    desc {
      en: """HTTP method."""
      zh: """HTTP 请求方法"""
    }
    label {
      en: """method"""
      zh: """method"""
    }
  }

  url {
    desc {
      en: """URL of the auth server."""
      zh: """授权 HTTP 服务器地址。"""
    }
    label {
      en: """URL"""
      zh: """URL"""
    }
  }

  headers {
    desc {
      en: """List of HTTP Headers."""
      zh: """HTTP Headers 列表"""
    }
    label {
      en: """Headers"""
      zh: """请求头"""
    }
  }

  headers_no_content_type {
    desc {
      en: """List of HTTP headers (without <code>content-type</code>)."""
      zh: """HTTP Headers 列表 (无 <code>content-type</code>) 。"""
    }
    label {
      en: """headers_no_content_type"""
      zh: """请求头(无 content-type)"""
    }
  }

  body {
    desc {
      en: """HTTP request body."""
      zh: """HTTP request body。"""
    }
    label {
      en: """Request Body"""
      zh: """Request Body"""
    }
  }

  request_timeout {
    desc {
      en: """HTTP request timeout."""
      zh: """HTTP 请求超时时长。"""
    }
    label {
      en: """Request Timeout"""
      zh: """请求超时时间"""
    }
  }

#==== authz_mnesia

  mnesia {
    desc {
      en: """Authorization using a built-in database (mnesia)."""
      zh: """使用内部数据库授权（mnesia）。"""
    }
    label {
      en: """mnesia"""
      zh: """mnesia"""
    }
  }

#==== authz_mongo

  mongo_single {
    desc {
      en: """Authorization using a single MongoDB instance."""
      zh: """使用 MongoDB 授权（单实例）。"""
    }
    label {
      en: """mongo_single"""
      zh: """mongo_single"""
    }
  }

  mongo_rs {
    desc {
      en: """Authorization using a MongoDB replica set."""
      zh: """使用 MongoDB 授权（副本集模式）"""
    }
    label {
      en: """mongo_rs"""
      zh: """mongo_rs"""
    }
  }

  mongo_sharded {
    desc {
      en: """Authorization using a sharded MongoDB cluster."""
      zh: """使用 MongoDB 授权（分片集群模式）。"""
    }
    label {
      en: """mongo_sharded"""
      zh: """mongo_sharded"""
    }
  }

  collection {
    desc {
      en: """`MongoDB` collection containing the authorization data."""
      zh: """`MongoDB` 授权数据集。"""
    }
    label {
      en: """collection"""
      zh: """数据集"""
    }
  }

  filter {
    desc {
      en: """
Conditional expression that defines the filter condition in the query.
Filter supports the following placeholders:
 - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting
 - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting
"""
      zh: """
在查询中定义过滤条件的条件表达式。
过滤器支持如下占位符：
- <code>${username}</code>：将在运行时被替换为客户端连接时使用的用户名
- <code>${clientid}</code>：将在运行时被替换为客户端连接时使用的客户端标识符
"""
    }
    label {
      en: """Filter"""
      zh: """过滤器"""
    }
  }

#==== authz_mysql

  mysql {
    desc {
      en: """Authorization using a MySQL database."""
      zh: """使用 MySOL 数据库授权"""
    }
    label {
      en: """mysql"""
      zh: """mysql"""
    }
  }

#==== authz_pgsql

  postgresql {
    desc {
      en: """Authorization using a PostgreSQL database."""
      zh: """使用 PostgreSQL 数据库授权"""
    }
    label {
      en: """postgresql"""
      zh: """postgresql"""
    }
  }

#==== authz_redis

  redis_single {
    desc {
      en: """Authorization using a single Redis instance."""
      zh: """使用 Redis 授权（单实例）。"""
    }
    label {
      en: """redis_single"""
      zh: """redis_single"""
    }
  }

  redis_sentinel {
    desc {
      en: """Authorization using a Redis Sentinel."""
      zh: """使用 Redis 授权（哨兵模式）。"""
    }
    label {
      en: """redis_sentinel"""
      zh: """redis_sentinel"""
    }
  }

  redis_cluster {
    desc {
      en: """Authorization using a Redis cluster."""
      zh: """使用 Redis 授权（集群模式）。"""
    }
    label {
      en: """redis_cluster"""
      zh: """redis_cluster"""
    }
  }

  cmd {
    desc {
      en: """Database query used to retrieve authorization data."""
      zh: """访问控制数据查查询命令"""
    }
    label {
      en: """cmd"""
      zh: """查询命令"""
    }
  }

#==== common field for DBs (except redis)

  query {
    desc {
      en: """Database query used to retrieve authorization data."""
      zh: """访问控制数据查询语句/查询命令。"""
    }
    label {
      en: """query"""
      zh: """查询语句"""
    }
  }

#==== metrics field

  metrics {
    desc {
      en: """The metrics of the resource."""
      zh: """资源统计指标。"""
    }
    label: {
      en: """Metrics"""
      zh: """指标"""
    }
  }

  node_metrics {
    desc {
      en: """The metrics of the resource for each node."""
      zh: """每个节点上资源的统计指标。"""
    }
    label: {
      en: """Resource Metrics in Node"""
      zh: """节点资源指标"""
    }
  }

  status {
    desc {
      en: """The status of the resource."""
      zh: """资源状态。"""
    }
    label: {
      en: """Status"""
      zh: """状态"""
    }
  }

  node_status {
    desc {
      en: """The status of the resource for each node."""
      zh: """每个节点上资源的状态。"""
    }
    label: {
      en: """Resource Status in Node"""
      zh: """节点资源状态"""
    }
  }

  node_error {
    desc {
      en: """The error of node."""
      zh: """节点上产生的错误。"""
    }
    label: {
      en: """Error in Node"""
      zh: """节点产生的错误"""
    }
  }

  matched {
    desc {
      en: """Count of this resource is queried."""
      zh: """请求命中次数。"""
    }
    label: {
      en: """Matched"""
      zh: """已命中"""
    }
  }

  success {
    desc {
      en: """Count of query success."""
      zh: """请求成功次数。"""
    }
    label: {
      en: """Success"""
      zh: """成功"""
    }
  }

  failed {
    desc {
      en: """Count of query failed."""
      zh: """请求失败次数。"""
    }
    label: {
      en: """Failed"""
      zh: """失败"""
    }
  }

  rate {
    desc {
      en: """The rate of matched, times/second."""
      zh: """命中速率，单位：次/秒。"""
    }
    label: {
      en: """Rate"""
      zh: """速率"""
    }
  }

  rate_max {
    desc {
      en: """The max rate of matched, times/second."""
      zh: """最大命中速率，单位：次/秒。"""
    }
    label: {
      en: """Max Rate"""
      zh: """最大速率"""
    }
  }

  rate_last5m {
    desc {
      en: """The average rate of matched in the last 5 minutes, times/second."""
      zh: """5分钟内平均命中速率，单位：次/秒。"""
    }
    label: {
      en: """Rate in Last 5min"""
      zh: """5分钟内速率"""
    }
  }

  node {
    desc {
      en: """Node name."""
      zh: """节点名称。"""
    }
    label: {
      en: """Node Name."""
      zh: """节点名称。"""
    }
  }

  metrics_total {
    desc {
      en: """The total number of times the authorization rule was triggered."""
      zh: """授权实例被触发的总次数。"""
    }
    label: {
      en: """The Total Number of Times the Authorization Rule was Triggered"""
      zh: """授权实例被触发的总次数"""
    }
  }

  nomatch {
    desc {
      en: """The number of times that no authorization rules were matched."""
      zh: """没有匹配到任何授权规则的次数。"""
    }
    label: {
      en: """The Number of Times that no Authorization Rules were Matched"""
      zh: """没有匹配到任何授权规则的次数"""
    }
  }

  allow {
    desc {
      en: """The number of times the authentication was successful."""
      zh: """授权成功的次数。"""
    }
    label: {
      en: """The Number of Times the Authentication was Successful"""
      zh: """授权成功次数"""
    }
  }

  deny {
    desc {
      en: """The number of authentication failures."""
      zh: """授权失败的次数。"""
    }
    label: {
      en: """The Number of Authentication Failures"""
      zh: """授权失败次数"""
    }
  }
}

emqx_authn_api {

  authentication_get {
    desc {
      en: """List authenticators for global authentication."""
      zh: """列出全局认证链上的认证器。"""
    }
  }

  authentication_post {
    desc {
      en: """Create authenticator for global authentication."""
      zh: """为全局认证链创建认证器。"""
    }
  }

  authentication_id_get {
    desc {
      en: """Get authenticator from global authentication chain."""
      zh: """获取全局认证链上的指定认证器。"""
    }
  }

  authentication_id_put {
    desc {
      en: """Update authenticator from global authentication chain."""
      zh: """更新全局认证链上的指定认证器。"""
    }
  }

  authentication_id_delete {
    desc {
      en: """Delete authenticator from global authentication chain."""
      zh: """删除全局认证链上的指定认证器。"""
    }
  }

  authentication_id_status_get {
    desc {
      en: """Get authenticator status from global authentication chain."""
      zh: """获取全局认证链上指定认证器的状态。"""
    }
  }

  listeners_listener_id_authentication_get {
    desc {
      en: """List authenticators for listener authentication."""
      zh: """列出监听器认证链上的认证器。"""
    }
  }

  listeners_listener_id_authentication_post {
    desc {
      en: """Create authenticator for listener authentication."""
      zh: """在监听器认证链上创建认证器。"""
    }
  }

  listeners_listener_id_authentication_id_get {
    desc {
      en: """Get authenticator from listener authentication chain."""
      zh: """获取监听器认证链上的指定认证器。"""
    }
  }

  listeners_listener_id_authentication_id_put {
    desc {
      en: """Update authenticator from listener authentication chain."""
      zh: """更新监听器认证链上的指定认证器。"""
    }
  }

  listeners_listener_id_authentication_id_delete {
    desc {
      en: """Delete authenticator from listener authentication chain."""
      zh: """删除监听器认证链上的指定认证器。"""
    }
  }

  listeners_listener_id_authentication_id_status_get {
    desc {
      en: """Get authenticator status from listener authentication chain."""
      zh: """获取监听器认证链上指定认证器的状态。"""
    }
  }

  authentication_id_move_post {
    desc {
      en: """Move authenticator in global authentication chain."""
      zh: """更改全局认证链上指定认证器的顺序。"""
    }
  }

  listeners_listener_id_authentication_id_move_post   {
    desc {
      en: """Move authenticator in listener authentication chain."""
      zh: """更改监听器认证链上指定认证器的顺序。"""
    }
  }

  authentication_id_users_post {
    desc {
      en: """Create users for authenticator in global authentication chain."""
      zh: """为全局认证链上的指定认证器创建用户数据。"""
    }
  }

  authentication_id_users_get {
    desc {
      en: """List users in authenticator in global authentication chain."""
      zh: """获取全局认证链上指定认证器中的用户数据。"""
    }
  }

  listeners_listener_id_authentication_id_users_post {
    desc {
      en: """Create users for authenticator in listener authentication chain."""
      zh: """为监听器认证链上的指定认证器创建用户数据。"""
    }
  }

  listeners_listener_id_authentication_id_users_get {
    desc {
      en: """List users in authenticator in listener authentication chain."""
      zh: """列出监听器认证链上指定认证器中的用户数据。"""
    }
  }

  authentication_id_users_user_id_get {
    desc {
      en: """Get user from authenticator in global authentication chain."""
      zh: """获取全局认证链上指定认证器中的指定用户数据。"""
    }
  }

  authentication_id_users_user_id_put {
    desc {
      en: """Update user in authenticator in global authentication chain."""
      zh: """更新全局认证链上指定认证器中的指定用户数据。"""
    }
  }

  authentication_id_users_user_id_delete {
    desc {
      en: """Delete user in authenticator in global authentication chain."""
      zh: """删除全局认证链上指定认证器中的指定用户数据。"""
    }
  }

  listeners_listener_id_authentication_id_users_user_id_get {
    desc {
      en: """Get user from authenticator in listener authentication chain."""
      zh: """获取监听器认证链上指定认证器中的指定用户数据。"""
    }
  }

  listeners_listener_id_authentication_id_users_user_id_put {
    desc {
      en: """Update user in authenticator in listener authentication chain."""
      zh: """更新监听器认证链上指定认证器中的指定用户数据。"""
    }
  }

  listeners_listener_id_authentication_id_users_user_id_delete {
    desc {
      en: """Delete user in authenticator in listener authentication chain."""
      zh: """删除监听器认证链上指定认证器中的指定用户数据。"""
    }
  }

  param_auth_id {
    desc {
      en: """Authenticator ID."""
      zh: """认证器 ID。"""
    }
  }

  param_listener_id {
    desc {
      en: """Listener ID."""
      zh: """监听器 ID。"""
    }
  }


  param_user_id {
    desc {
      en: """User ID."""
      zh: """用户 ID。"""
    }
  }

  like_user_id {
    desc {
      en: """Fuzzy search user_id (username or clientid)."""
      zh: """使用用户 ID （username 或 clientid）模糊查询。"""
    }
    label {
      en: """like_user_id"""
      zh: """like_user_id"""
    }
  }

  is_superuser {
    desc {
      en: """Is superuser"""
      zh: """是否是超级用户"""
    }
  }

}

emqx_authn_http {
  get {
    desc {
      en: """Configuration of authenticator using HTTP Server as authentication service (Using GET request)."""
      zh: """使用 HTTP Server 作为认证服务的认证器的配置项 (使用 GET 请求)。"""
    }
  }

  post {
    desc {
      en: """Configuration of authenticator using HTTP Server as authentication service (Using POST request)."""
      zh: """使用 HTTP Server 作为认证服务的认证器的配置项 (使用 POST 请求)。"""
    }
  }

  method {
    desc {
      en: """HTTP request method."""
      zh: """HTTP 请求方法。"""
    }
    label {
      en: """Request Method"""
      zh: """请求方法"""
    }
  }

  url {
    desc {
      en: """URL of the HTTP server."""
      zh: """认证 HTTP 服务器地址。"""
    }
    label {
      en: """URL"""
      zh: """URL"""
    }
  }

  headers {
    desc {
      en: """List of HTTP Headers."""
      zh: """HTTP Headers 列表"""
    }
    label {
      en: """Headers"""
      zh: """请求头"""
    }
  }

  headers_no_content_type {
    desc {
      en: """List of HTTP headers (without <code>content-type</code>)."""
      zh: """HTTP Headers 列表 (无 <code>content-type</code>) 。"""
    }
    label {
      en: """headers_no_content_type"""
      zh: """请求头(无 content-type)"""
    }
  }

  body {
    desc {
      en: """HTTP request body."""
      zh: """HTTP request body。"""
    }
    label {
      en: """Request Body"""
      zh: """Request Body"""
    }
  }

  request_timeout {
    desc {
      en: """HTTP request timeout."""
      zh: """HTTP 请求超时时长。"""
    }
    label {
      en: """Request Timeout"""
      zh: """请求超时时间"""
    }
  }
}

emqx_authn_jwt {
  use_jwks {
    desc {
      en: """Whether to use JWKS."""
      zh: """是否使用 JWKS。"""
    }
    label {
      en: """Whether to Use JWKS"""
      zh: """是否使用 JWKS"""
    }
  }

  algorithm {
    desc {
      en: """JWT signing algorithm, Supports HMAC (configured as <code>hmac-based</code>) and RSA, ECDSA (configured as <code>public-key</code>)."""
      zh: """JWT 签名算法，支持 HMAC (配置为 <code>hmac-based</code>）和 RSA、ECDSA (配置为 <code>public-key</code>)。"""
    }
    label {
      en: """JWT Signing Algorithm"""
      zh: """JWT 签名算法"""
    }
  }

  public_key {
    desc {
      en: """The public key used to verify the JWT."""
      zh: """用于验证 JWT 的公钥。"""
    }
    label {
      en: """Public Key"""
      zh: """公钥"""
    }
  }

  secret_base64_encoded {
    desc {
      en: """Whether secret is base64 encoded."""
      zh: """密钥是否为 Base64 编码。"""
    }
    label {
      en: """Whether Secret is Base64 Encoded"""
      zh: """密钥是否为 Base64 编码"""
    }
  }

  secret {
    desc {
      en: """The key to verify the JWT using HMAC algorithm."""
      zh: """使用 HMAC 算法时用于验证 JWT 的密钥"""
    }
    label {
      en: """Secret"""
      zh: """Secret"""
    }
  }

  endpoint {
    desc {
      en: """JWKS endpoint, it's a read-only endpoint that returns the server's public key set in the JWKS format."""
      zh: """JWKS 端点， 它是一个以 JWKS 格式返回服务端的公钥集的只读端点。"""
    }
    label {
      en: """JWKS Endpoint"""
      zh: """JWKS Endpoint"""
    }
  }

  refresh_interval {
    desc {
      en: """JWKS refresh interval."""
      zh: """JWKS 刷新间隔。"""
    }
    label {
      en: """JWKS Refresh Interval"""
      zh: """JWKS 刷新间隔"""
    }
  }

  cacertfile {
    desc {
      en: """Path to a file containing PEM-encoded CA certificates."""
      zh: """包含 PEM 编码的 CA 证书的文件的路径。"""
    }
    label {
      en: """CA Certificate File"""
      zh: """CA 证书文件"""
    }
  }

  certfile {
    desc {
      en: """Path to a file containing the user certificate."""
      zh: """包含用户证书的文件的路径。"""
    }
    label {
      en: """Certificate File"""
      zh: """证书文件"""
    }
  }

  keyfile {
    desc {
      en: """Path to a file containing the user's private PEM-encoded key."""
      zh: """包含 PEM 编码的用户私钥的文件的路径。"""
    }
    label {
      en: """Key File"""
      zh: """私钥文件"""
    }
  }

  verify {
    desc {
      en: """Enable or disable SSL peer verification."""
      zh: """指定握手过程中是否校验对端证书。"""
    }
    label {
      en: """Verify"""
      zh: """Verify"""
    }
  }

  server_name_indication {
    desc {
      en: """Server Name Indication (SNI)."""
      zh: """服务器名称指示（SNI）。"""
    }
    label {
      en: """Server Name Indication"""
      zh: """服务器名称指示"""
    }
  }

  verify_claims {
    desc {
      en: """
A list of custom claims to validate, which is a list of name/value pairs.
Values can use the following placeholders:
- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting
- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting
Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.
"""
      zh: """
需要验证的自定义声明列表，它是一个名称/值对列表。
值可以使用以下占位符：
- <code>${username}</code>: 将在运行时被替换为客户端连接时使用的用户名
- <code>${clientid}</code>: 将在运行时被替换为客户端连接时使用的客户端标识符
认证时将验证 JWT（取自 Password 字段）中 claims 的值是否与 <code>verify_claims</code> 中要求的相匹配。
"""
    }
    label {
      en: """Verify Claims"""
      zh: """Verify Claims"""
    }
  }

  ssl {
    desc {
      en: """SSL options."""
      zh: """SSL 选项。"""
    }
    label {
      en: """SSL Options"""
      zh: """SSL 选项"""
    }
  }

  enable {
    desc {
      en: """Enable/disable SSL."""
      zh: """启用/禁用 SSL。"""
    }
    label {
      en: """Enable/disable SSL"""
      zh: """启用/禁用 SSL"""
    }
  }

  hmac-based {
    desc {
      en: """Configuration when the JWT for authentication is issued using the HMAC algorithm."""
      zh: """用于认证的 JWT 使用 HMAC 算法签发时的配置。"""
    }
  }

  public-key {
    desc {
      en: """Configuration when the JWT for authentication is issued using RSA or ECDSA algorithm."""
      zh: """用于认证的 JWT 使用 RSA 或 ECDSA 算法签发时的配置。"""
    }
  }

  jwks {
    desc {
      en: """Configuration when JWTs used for authentication need to be fetched from the JWKS endpoint."""
      zh: """用于认证的 JWTs 需要从 JWKS 端点获取时的配置。"""
    }
  }

  ssl_disable {
    desc {
      en: """SSL configuration."""
      zh: """SSL 配置。"""
    }
  }

  ssl_enable {
    desc {
      en: """SSL configuration."""
      zh: """SSL 配置。"""
    }
  }

  acl_claim_name {
    desc {
      en: """JWT claim name to use for getting ACL rules."""
      zh: """JWT claim name to use for getting ACL rules."""
    }
    label {
      en: """ACL claim name"""
      zh: """ACL claim name"""
    }
  }

  from {
    desc {
      en: """Field to take JWT from."""
      zh: """要从中获取 JWT 的字段。"""
    }
    label {
      en: """From Field"""
      zh: """源字段"""
    }
  }


}

emqx_authn_mnesia {
  authentication {
    desc {
      en: """Configuration of authenticator using built-in database as data source."""
      zh: """使用内置数据库作为认证数据源的认证器的配置项。"""
    }
  }

  user_id_type {
    desc {
      en: """Specify whether to use `clientid` or `username` for authentication."""
      zh: """指定使用客户端ID `clientid` 还是用户名 `username` 进行认证。"""
    }

    label: {
      en: """Authentication ID Type"""
      zh: """认证 ID 类型"""
    }
  }

}

emqx_authn_mongodb {
  standalone {
    desc {
      en: """Configuration of authenticator using MongoDB (Standalone) as authentication data source."""
      zh: """使用 MongoDB (Standalone) 作为认证数据源的认证器的配置项。"""
    }
  }

  replica-set {
    desc {
      en: """Configuration of authenticator using MongoDB (Replica Set) as authentication data source."""
      zh: """使用 MongoDB (Replica Set) 作为认证数据源的认证器的配置项。"""
    }
  }

  sharded-cluster {
    desc {
      en: """Configuration of authenticator using MongoDB (Sharded Cluster) as authentication data source."""
      zh: """使用 MongoDB (Sharded Cluster) 作为认证数据源的认证器的配置项。"""
    }
  }

  collection {
    desc {
      en: """Collection used to store authentication data."""
      zh: """存储认证数据的集合。"""
    }
    label: {
      en: """Collection"""
      zh: """集合"""
    }
  }

  filter {
    desc {
      en: """
Conditional expression that defines the filter condition in the query.
Filter supports the following placeholders:
- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting
- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting
"""
      zh: """
在查询中定义过滤条件的条件表达式。
过滤器支持如下占位符：
- <code>${username}</code>: 将在运行时被替换为客户端连接时使用的用户名
- <code>${clientid}</code>: 将在运行时被替换为客户端连接时使用的客户端标识符
"""
    }
    label: {
      en: """Filter"""
      zh: """过滤器"""
    }
  }

  password_hash_field {
    desc {
      en: """Document field that contains password hash."""
      zh: """文档中用于存放密码散列的字段。"""
    }
    label: {
      en: """Password Hash Field"""
      zh: """密码散列字段"""
    }
  }

  salt_field {
    desc {
      en: """Document field that contains the password salt."""
      zh: """文档中用于存放盐值的字段。"""
    }
    label: {
      en: """Salt Field"""
      zh: """盐值字段"""
    }
  }

  is_superuser_field {
    desc {
      en: """Document field that defines if the user has superuser privileges."""
      zh: """文档中用于定义用户是否具有超级用户权限的字段。"""
    }
    label: {
      en: """Is Superuser Field"""
      zh: """超级用户字段"""
    }
  }
}

emqx_authn_mysql {
  authentication {
    desc {
      en: """Configuration of authenticator using MySQL as authentication data source."""
      zh: """使用 MySQL 作为认证数据源的认证器的配置项。"""
    }
  }

  query {
    desc {
      en: """SQL used to query data for authentication, such as password hash."""
      zh: """用于查询密码散列等用于认证的数据的 SQL 语句。"""
    }
    label: {
      en: """Query"""
      zh: """查询语句"""
    }
  }

  query_timeout {
    desc {
      en: """Timeout for the SQL query."""
      zh: """SQL 查询的超时时间。"""
    }
    label: {
      en: """Query Timeout"""
      zh: """查询超时"""
    }
  }
}

emqx_authn_pgsql {
  authentication {
    desc {
      en: """Configuration of authenticator using PostgreSQL as authentication data source."""
      zh: """使用 PostgreSQL 作为认证数据源的认证器的配置项。"""
    }
  }

  query {
    desc {
      en: """SQL used to query data for authentication, such as password hash."""
      zh: """用于查询密码散列等用于认证的数据的 SQL 语句。"""
    }
    label: {
      en: """Query"""
      zh: """查询语句"""
    }
  }
}

emqx_authn_redis {
  standalone {
    desc {
      en: """Configuration of authenticator using Redis (Standalone) as authentication data source."""
      zh: """使用 Redis (Standalone) 作为认证数据源的认证器的配置项。"""
    }
  }

  cluster {
    desc {
      en: """Configuration of authenticator using Redis (Cluster) as authentication data source."""
      zh: """使用 Redis (Cluster) 作为认证数据源的认证器的配置项。"""
    }
  }

  sentinel {
    desc {
      en: """Configuration of authenticator using Redis (Sentinel) as authentication data source."""
      zh: """使用 Redis (Sentinel) 作为认证数据源的认证器的配置项。"""
    }
  }

  cmd {
    desc {
      en: """The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>."""
      zh: """用于查询密码散列等用于认证的数据的 Redis Command，目前仅支持 <code>HGET</code> 与 <code>HMGET</code>。"""
    }
    label: {
      en: """Command"""
      zh: """Command"""
    }
  }
}

emqx_authn_schema {
  enable {
    desc {
      en: """Set to <code>true</code> or <code>false</code> to disable this auth provider."""
      zh: """设为 <code>true</code> 或 <code>false</code> 以启用或禁用此认证数据源。"""
    }
    label: {
      en: """Enable"""
      zh: """启用"""
    }
  }

  mechanism {
    desc {
      en: """Authentication mechanism."""
      zh: """认证机制。"""
    }
    label: {
      en: """Authentication Mechanism"""
      zh: """认证机制"""
    }
  }

  backend {
    desc {
      en: """Backend type."""
      zh: """后端类型。"""
    }
    label: {
      en: """Backend Type"""
      zh: """后端类型"""
    }
  }

  metrics {
    desc {
      en: """The metrics of the resource."""
      zh: """资源统计指标。"""
    }
    label: {
      en: """Metrics"""
      zh: """指标"""
    }
  }

  node_metrics {
    desc {
      en: """The metrics of the resource for each node."""
      zh: """每个节点上资源的统计指标。"""
    }
    label: {
      en: """Resource Metrics in Node"""
      zh: """节点资源指标"""
    }
  }

  status {
    desc {
      en: """The status of the resource."""
      zh: """资源状态。"""
    }
    label: {
      en: """Status"""
      zh: """状态"""
    }
  }

  node_status {
    desc {
      en: """The status of the resource for each node."""
      zh: """每个节点上资源的状态。"""
    }
    label: {
      en: """Resource Status in Node"""
      zh: """节点资源状态"""
    }
  }

  node_error {
    desc {
      en: """The error of node."""
      zh: """节点上产生的错误。"""
    }
    label: {
      en: """Error in Node"""
      zh: """节点产生的错误"""
    }
  }

  matched {
    desc {
      en: """Count of this resource is queried."""
      zh: """请求命中次数。"""
    }
    label: {
      en: """Matched"""
      zh: """已命中"""
    }
  }

  success {
    desc {
      en: """Count of query success."""
      zh: """请求成功次数。"""
    }
    label: {
      en: """Success"""
      zh: """成功"""
    }
  }

  failed {
    desc {
      en: """Count of query failed."""
      zh: """请求失败次数。"""
    }
    label: {
      en: """Failed"""
      zh: """失败"""
    }
  }

  rate {
    desc {
      en: """The rate of matched, times/second."""
      zh: """命中速率，单位：次/秒。"""
    }
    label: {
      en: """Rate"""
      zh: """速率"""
    }
  }

  rate_max {
    desc {
      en: """The max rate of matched, times/second."""
      zh: """最大命中速率，单位：次/秒。"""
    }
    label: {
      en: """Max Rate"""
      zh: """最大速率"""
    }
  }

  rate_last5m {
    desc {
      en: """The average rate of matched in the last 5 minutes, times/second."""
      zh: """5分钟内平均命中速率，单位：次/秒。"""
    }
    label: {
      en: """Rate in Last 5min"""
      zh: """5分钟内速率"""
    }
  }

  node {
    desc {
      en: """Node name."""
      zh: """节点名称。"""
    }
    label: {
      en: """Node Name."""
      zh: """节点名称。"""
    }
  }

  metrics_nomatch {
    desc {
      en: """The number of times the instance was ignored when the required authentication information was not found in the current instance."""
      zh: """在当前实例中没有找到需要的认证信息，实例被忽略的次数。"""
    }
    label: {
      en: """Nomatch Times"""
      zh: """实例被忽略的次数"""
    }
  }

  metrics_total {
    desc {
      en: """The total number of times the current instance was triggered."""
      zh: """当前实例被触发的总次数。"""
    }
    label: {
      en: """Total Triggered Times"""
      zh: """当前实例被触发的总次数"""
    }
  }

  metrics_success {
    desc {
      en: """The required authentication information is found in the current instance, and the instance returns authentication success."""
      zh: """在当前实例中找到需要的认证信息，并且实例返回认证成功的次数。"""
    }
    label: {
      en: """Authentication Success Times"""
      zh: """实例认证成功的次数"""
    }
  }

  metrics_failed {
    desc {
      en: """The required authentication information is found in the current instance, and the instance returns authentication failure."""
      zh: """在当前实例中找到需要的认证信息，并且实例返回认证失败的次数。"""
    }
    label: {
      en: """Authentication Failed Times"""
      zh: """实例认证失败的次数"""
    }
  }

  metrics_rate {
    desc {
      en: """The total rate at which instances are triggered, times/second."""
      zh: """实例被触发的速率。触发速率等于匹配速率 + 忽略速率，单位：次/秒。"""
    }
    label: {
      en: """Total Triggered Rate"""
      zh: """实例被触发的速率"""
    }
  }

  metrics_rate_max {
    desc {
      en: """The highest trigger rate the instance has ever reached, times/second."""
      zh: """实例曾经达到的最高触发速率，单位：次/秒。"""
    }
    label: {
      en: """Highest Triggered Rate"""
      zh: """实例曾经达到的最高触发速率"""
    }
  }

  metrics_rate_last5m {
    desc {
      en: """The average trigger rate of the instance within 5 minutes, times/second."""
      zh: """实例5分钟内平均触发速率，单位：次/秒。"""
    }
    label: {
      en: """Average Triggered Rate in Last 5min"""
      zh: """实例5分钟内平均触发速率"""
    }
  }
}

emqx_authn_user_import_api {

  authentication_id_import_users_post {
    desc {
      en: """Import users into authenticator in global authentication chain."""
      zh: """为全局认证链上的指定认证器导入用户数据。"""
    }
  }

  listeners_listener_id_authentication_id_import_users_post {
    desc {
      en: """Import users into authenticator in listener authentication chain."""
      zh: """为监听器认证链上的指定认证器导入用户数据。"""
    }
  }

}

emqx_limiter_schema {

  failure_strategy {
    desc {
      en: """The strategy when all the retries failed."""
      zh: """当所有的重试都失败后的处理策略"""
    }
    label: {
      en: """Failure Strategy"""
      zh: """失败策略"""
    }
  }

  max_retry_time {
    desc {
      en: """The maximum retry time when acquire failed."""
      zh: """申请失败后，尝试重新申请的时长最大值"""
    }
    label: {
      en: """Max Retry Time"""
      zh: """最大重试时间"""
    }
  }

  divisible {
    desc {
      en: """Is it possible to split the number of requested tokens?"""
      zh: """申请的令牌数是否可以被分割"""
    }
    label: {
      en: """Divisible"""
      zh: """是否可分割"""
    }
  }

  client_bucket_capacity {
    desc {
      en: """The capacity of per user."""
      zh: """每个使用者的令牌容量上限"""
    }
    label: {
      en: """Capacity"""
      zh: """容量"""
    }
  }

  capacity {
    desc {
      en: """The capacity of this token bucket."""
      zh: """该令牌桶的容量"""
    }
    label: {
      en: """Capacity"""
      zh: """容量"""
    }
  }

  low_watermark {
    desc {
      en: """If the remaining tokens are lower than this value,
the check/consume will succeed, but it will be forced to wait for a short period of time."""
      zh: """当桶中剩余的令牌数低于这个值，即使令牌申请成功了，也会被强制暂停一会儿"""
    }
    label: {
      en: """Low Watermark"""
      zh: """低水位线"""
    }
  }

  initial {
    desc {
      en: """The initial number of tokens for this bucket."""
      zh: """桶中的初始令牌数"""
    }
    label: {
      en: """Initial"""
      zh: """初始令牌数"""
    }
  }

  rate {
    desc {
      en: """Rate for this bucket."""
      zh: """桶的令牌生成速率"""
    }
    label: {
      en: """Rate"""
      zh: """速率"""
    }
  }

  client {
    desc {
      en: """The rate limit for each user of the bucket"""
      zh: """对桶的每个使用者的速率控制设置"""
    }
    label: {
      en: """Per Client"""
      zh: """每个使用者的限制"""
    }
  }

  bucket_cfg {
    desc {
      en: """Bucket Configs"""
      zh: """桶的配置"""
    }
    label: {
      en: """Buckets"""
      zh: """桶的配置"""
    }
  }

  burst {
    desc {
      en: """The burst, This value is based on rate.<br/>
 This value + rate = the maximum limit that can be achieved when limiter burst."""
      zh: """突发速率。
突发速率允许短时间内速率超过设置的速率值，突发速率 + 速率 = 当前桶能达到的最大速率值"""
    }
    label: {
      en: """Burst"""
      zh: """突发速率"""
    }
  }

  message_routing {
    desc {
      en: """The message routing limiter.
This is used to limit the forwarding rate for this EMQX node.
Once the limit is reached, new publish will be refused"""
      zh: """消息派发速率控制器。
这个用来控制当前节点内的消息派发速率，当达到最大速率后，新的推送将会被拒绝"""
    }
    label: {
      en: """Message Routing"""
      zh: """消息派发"""
    }
  }

  connection {
    desc {
      en: """The connection limiter.
This is used to limit the connection rate for this EMQX node.
Once the limit is reached, new connections will be refused"""
      zh: """连接速率控制器。
这个用来控制当前节点上的连接速率，当达到最大速率后，新的连接将会被拒绝"""
    }
    label: {
      en: """Connection"""
      zh: """连接速率"""
    }
  }

  message_in {
    desc {
      en: """The message in limiter.
This is used to limit the inbound message numbers for this EMQX node
Once the limit is reached, the restricted client will be slow down even be hung for a while."""
      zh: """流入速率控制器。
这个用来控制当前节点上的消息流入速率，当达到最大速率后，会话将会被限速甚至被强制挂起一小段时间"""
    }
    label: {
      en: """Message In"""
      zh: """消息流入速率"""
    }
  }

  bytes_in {
    desc {
      en: """The bytes_in limiter.
This is used to limit the inbound bytes rate for this EMQX node.
Once the limit is reached, the restricted client will be slow down even be hung for a while."""
      zh: """流入字节率控制器。
这个是用来控制当前节点上的数据流入的字节率，每条消息将会消耗和其二进制大小等量的令牌，当达到最大速率后，会话将会被限速甚至被强制挂起一小段时间"""
    }
    label: {
      en: """Bytes In"""
      zh: """流入字节率"""
    }
  }

  internal {
    desc {
      en: """Limiter for EMQX internal app."""
      zh: """EMQX 内部功能所用限制器。"""

    }
  }
}

emqx_schema {

  force_shutdown_enable {
    desc {
      en: "Enable `force_shutdown` feature."
      zh: "启用 `force_shutdown` 功能。"
    }
    label {
      en: "Enable `force_shutdown` feature"
      zh: "启用 `force_shutdown` 功能"
    }
  }

  force_shutdown_max_message_queue_len {
    desc {
      en: "Maximum message queue length."
      zh: "消息队列的最大长度。"
    }
    label {
      en: "Maximum mailbox queue length of process."
      zh: "进程邮箱消息队列的最大长度"
    }
  }

  force_shutdown_max_heap_size {
    desc {
        en: "Total heap size"
        zh: "Heap 的总大小。"
    }
    label {
        en: "Total heap size"
        zh: "Heap 的总大小"
    }
  }

  overload_protection_enable {
    desc {
        en: "React on system overload or not."
        zh: "是否对系统过载做出反应。"
    }
    label {
        en: "React on system overload or not"
        zh: "是否对系统过载做出反应"
    }
  }

  overload_protection_backoff_delay {
    desc {
        en: "When at high load, some unimportant tasks could be delayed for execution, here set the duration in milliseconds precision."
        zh: "高负载时，一些不重要的任务可能会延迟执行，在这里设置允许延迟的时间。单位为毫秒。"
    }
    label {
        en: "Delay Time"
        zh: "延迟时间"
    }
  }

  overload_protection_backoff_gc {
    desc {
        en: "When at high load, skip forceful GC."
        zh: "高负载时，跳过强制 GC。"
    }
    label {
        en: "Skip GC"
        zh: "跳过GC"
    }
  }

  overload_protection_backoff_hibernation {
    desc {
        en: "When at high load, skip process hibernation."
        zh: "高负载时，跳过进程休眠。"
    }
    label {
        en: "Skip hibernation"
        zh: "跳过休眠"
    }
  }

  overload_protection_backoff_new_conn {
    desc {
        en: "When at high load, close new incoming connections."
        zh: "高负载时，拒绝新进来的客户端连接。"
    }
    label {
        en: "Close new connections"
        zh: "关闭新连接"
    }
  }

  conn_congestion_enable_alarm {
    desc {
        en: "Enable or disable connection congestion alarm."
        zh: "启用或者禁用连接阻塞告警功能。"
    }
    label {
        en: "Enable/disable congestion alarm"
        zh: "启用/禁用阻塞告警"
    }
  }

  conn_congestion_min_alarm_sustain_duration {
    desc {
        en: "Minimal time before clearing the alarm.<br/>"
            "The alarm is cleared only when there's no pending data in<br/>"
            "the queue, and at least <code>min_alarm_sustain_duration</code>"
            "milliseconds passed since the last time we considered the connection 'congested'.<br/>"
            "This is to avoid clearing and raising the alarm again too often."
        zh: "清除警报前的最短时间。<br/>"
            "只有当队列中没有挂起的数据，并且连接至少被堵塞了 <code>min_alarm_sustain_duration</code> 毫秒时，<br/>"
            "报警才会被清除。这是为了避免太频繁地清除和再次发出警报。"
    }
    label {
        en: "Sustain duration"
        zh: "告警维持时间"
    }
  }

  force_gc_enable {
    desc {
        en: "Enable forced garbage collection."
        zh: "启用强制垃圾回收。"
    }
    label {
        en: "Enable forced garbage collection"
        zh: "启用强制垃圾回收"
    }
  }

  force_gc_count {
    desc {
        en: "GC the process after this many received messages."
        zh: "在进程收到多少消息之后，对此进程执行垃圾回收。"
    }
    label {
        en: "Process GC messages num"
        zh: "垃圾回收消息数"
    }
  }

  force_gc_bytes {
    desc {
        en: "GC the process after specified number of bytes have passed through."
        zh: "在进程处理过多少个字节之后，对此进程执行垃圾回收。"
    }
    label {
        en: "Process GC bytes"
        zh: "垃圾回收字节数"
    }
  }

  sysmon_vm_process_check_interval {
    desc {
        en: "The time interval for the periodic process limit check."
        zh: "定期进程限制检查的时间间隔。"
    }
    label {
        en: "Process limit check interval"
        zh: "进程限制检查时间"
    }
  }

  sysmon_vm_process_high_watermark {
    desc {
        en: "The threshold, as percentage of processes, for how many\n"
            " processes can simultaneously exist at the local node before the corresponding\n"
            " alarm is raised."
        zh: "在发出相应警报之前，本地节点上可以同时存在多少进程的阈值（以进程百分比表示）。"
    }
    label {
        en: "Process high watermark"
        zh: "进程数高水位线"
    }
  }

  sysmon_vm_process_low_watermark {
    desc {
        en: "The threshold, as percentage of processes, for how many\n"
            " processes can simultaneously exist at the local node before the corresponding\n"
            " alarm is cleared."
        zh: "在清除相应警报之前，本地节点上可以同时存在多少进程的阈值（以进程百分比表示）。"
    }
    label {
        en: "Process low watermark"
        zh: "进程数低水位线"
    }
  }

  sysmon_vm_long_gc {
    desc {
        en: "Enable Long GC monitoring."
        zh: "启用长垃圾回收监控。"
    }
    label {
        en: "Enable Long GC monitoring."
        zh: "启用长垃圾回收监控"
    }
  }

  sysmon_vm_long_schedule {
    desc {
        en: "Enable Long Schedule monitoring."
        zh: "启用长调度监控。"
    }
    label {
        en: "Enable Long Schedule monitoring."
        zh: "启用长调度监控"
    }
  }

  sysmon_vm_large_heap {
    desc {
        en: "Enable Large Heap monitoring."
        zh: "启用大 heap 监控。"
    }
    label {
        en: "Enable Large Heap monitoring."
        zh: "启用大 heap 监控"
    }
  }

  sysmon_vm_busy_dist_port {
    desc {
        en: "Enable Busy Distribution Port monitoring."
        zh: "启用分布式端口过忙监控。"
    }
    label {
        en: "Enable Busy Distribution Port monitoring."
        zh: "启用分布式端口过忙监控"
    }
  }

  sysmon_vm_busy_port {
    desc {
        en: "Enable Busy Port monitoring."
        zh: "启用端口过忙监控。"
    }
    label {
        en: "Enable Busy Port monitoring."
        zh: "启用端口过忙监控"
    }
  }

  sysmon_os_cpu_check_interval {
    desc {
        en: "The time interval for the periodic CPU check."
        zh: "定期 CPU 检查的时间间隔。"
    }
    label {
        en: "The time interval for the periodic CPU check."
        zh: "定期 CPU 检查的时间间隔"
    }
  }

  sysmon_os_cpu_high_watermark {
    desc {
        en: "The threshold, as percentage of system CPU load,\n"
            " for how much system cpu can be used before the corresponding alarm is raised."
        zh: "在发出相应警报之前可以使用多少系统 CPU 的阈值，以系统CPU负载的百分比表示。"
    }
    label {
        en: "CPU high watermark"
        zh: "CPU 高水位线"
    }
  }

  sysmon_os_cpu_low_watermark {
    desc {
        en: "The threshold, as percentage of system CPU load,\n"
            " for how much system cpu can be used before the corresponding alarm is cleared."
        zh: "在解除相应警报之前可以使用多少系统 CPU 的阈值，以系统CPU负载的百分比表示。"
    }
    label {
        en: "CPU low watermark"
        zh: "CPU 低水位线"
    }
  }

  sysmon_os_mem_check_interval {
    desc {
        en: "The time interval for the periodic memory check."
        zh: "定期内存检查的时间间隔。"
    }
    label {
        en: "Mem check interval"
        zh: "内存检查间隔"
    }
  }

  sysmon_os_sysmem_high_watermark {
    desc {
        en: "The threshold, as percentage of system memory,\n"
            " for how much system memory can be allocated before the corresponding alarm is raised."
        zh: "在发出相应报警之前可以分配多少系统内存的阈值，以系统内存的百分比表示。"
    }
    label {
        en: "SysMem high wartermark"
        zh: "系统内存高水位线"
    }
  }

  sysmon_os_procmem_high_watermark {
    desc {
        en: "The threshold, as percentage of system memory,\n"
        " for how much system memory can be allocated by one Erlang process before\n"
        " the corresponding alarm is raised."
        zh: "在发出相应警报之前，一个Erlang进程可以分配多少系统内存的阈值，以系统内存的百分比表示。"
    }
    label {
        en: "ProcMem high wartermark"
        zh: "进程内存高水位线"
    }
  }

  sysmon_top_num_items {
    desc {
        en: "The number of top processes per monitoring group"
        zh: "每个监视组的顶级进程数。"
    }
    label {
        en: "Top num items"
        zh: "顶级进程数"
    }
  }

  sysmon_top_sample_interval {
    desc {
        en: "Specifies how often process top should be collected"
        zh: "指定应收集进程顶部的频率。"
    }
    label {
        en: "Top sample interval"
        zh: "取样时间"
    }
  }

  sysmon_top_max_procs {
    desc {
        en: "Stop collecting data when the number of processes\n"
            "in the VM exceeds this value"
        zh: "当 VM 中的进程数超过此值时，停止收集数据。"
    }
    label {
        en: "Max procs"
        zh: "最大进程数"
    }
  }

  sysmon_top_db_hostname {
    desc {
        en: "Hostname of the PostgreSQL database that collects the data points"
        zh: "收集数据点的 PostgreSQL 数据库的主机名。"
    }
    label {
        en: "DB Hostname"
        zh: "数据库主机名"
    }
  }

  sysmon_top_db_port {
    desc {
        en: "Port of the PostgreSQL database that collects the data points."
        zh: "收集数据点的 PostgreSQL 数据库的端口。"
    }
    label {
        en: "DB Port"
        zh: "数据库端口"
    }
  }

  sysmon_top_db_username {
    desc {
        en: "Username of the PostgreSQL database"
        zh: "PostgreSQL 数据库的用户名"
    }
    label {
        en: "DB Username"
        zh: "数据库用户名"
    }
  }

  sysmon_top_db_password {
    desc {
        en: "EMQX user password in the PostgreSQL database"
        zh: "PostgreSQL 数据库的密码"
    }
    label {
        en: "DB Password"
        zh: "数据库密码"
    }
  }

  sysmon_top_db_name {
    desc {
        en: "PostgreSQL database name"
        zh: "PostgreSQL 数据库的数据库名"
    }
    label {
        en: "DB Name"
        zh: "数据库名"
    }
  }

  alarm_actions {
    desc {
        en: "The actions triggered when the alarm is activated.<br/>"
            "Currently, the following actions are supported: <code>log</code> and "
            "<code>publish</code>.\n"
            "<code>log</code> is to write the alarm to log (console or file).\n"
            "<code>publish</code> is to publish the alarm as an MQTT message to "
            "the system topics:\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>"
        zh: "警报激活时触发的动作。<br/>"
            "目前，支持以下操作：<code>log</code> 和 "
            "<code>publish</code>.\n"
            "<code>log</code> 将告警写入日志 (控制台或者文件).\n"
            "<code>publish</code> 将告警作为 MQTT 消息发布到系统主题:\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>"
    }
    label: {
        en: "Alarm Actions"
        zh: "告警动作"
    }
  }

  alarm_size_limit {
    desc {
        en: "The maximum total number of deactivated alarms to keep as history.<br/>"
            "When this limit is exceeded, the oldest deactivated alarms are "
            "deleted to cap the total number.\n"
        zh: "要保留为历史记录的已停用报警的最大总数。当超过此限制时，将删除最旧的停用报警，以限制总数。"
    }
    label: {
        en: "Alarm size limit"
        zh: "告警总数限制"
    }
  }

  alarm_validity_period {
    desc {
        en: "Retention time of deactivated alarms. Alarms are not deleted immediately\n"
            "when deactivated, but after the retention time.\n"
        zh: "停用报警的保留时间。报警在停用时不会立即删除，而是在保留时间之后删除。"
    }
    label: {
        en: "Alarm validity period"
        zh: "告警保留时间"
    }
  }

  flapping_detect_enable {
    desc {
        en: "Enable flapping connection detection feature."
        zh: "启用抖动检测功能。"
    }
    label: {
        en: "Enable flapping detection"
        zh: "启用抖动检测"
    }
  }

  flapping_detect_max_count {
    desc {
        en: "The maximum number of disconnects allowed for a MQTT Client in `window_time`"
        zh: "MQTT 客户端在“窗口”时间内允许的最大断开次数。"
    }
    label: {
        en: "Max count"
        zh: "最大断开次数"
    }
  }

  flapping_detect_window_time {
    desc {
        en: "The time window for flapping detection."
        zh: "抖动检测的时间窗口。"
    }
    label: {
        en: "Window time"
        zh: "时间窗口"
    }
  }

  flapping_detect_ban_time {
    desc {
        en: "How long the flapping clientid will be banned."
        zh: "抖动的客户端将会被禁止登录多长时间。"
    }
    label: {
        en: "Ban time"
        zh: "禁止登录时长"
    }
  }

  persistent_session_store_enabled {
    desc {
        en: "Use the database to store information about persistent sessions.\n"
            "This makes it possible to migrate a client connection to another\n"
            "cluster node if a node is stopped.\n"
        zh: "使用数据库存储有关持久会话的信息。\n"
            "这使得在节点停止时，可以将客户端连接迁移到另一个群集节点。"
    }
    label: {
        en: "Enable persistent session store"
        zh: "启用持久会话保存"
    }
  }

  persistent_session_store_backend {
    desc {
        en: "Database management system used to store information about persistent sessions and messages.\n"
            "- `builtin`: Use the embedded database (mria)"
        zh: "用于存储持久性会话和信息的数据库管理后端\n"
            "- `builtin`: 使用内置的数据库（mria）"
    }
    label: {
        en: "Backend"
        zh: "后端类型"
    }
  }

  persistent_store_on_disc {
    desc {
        en: "Save information about the persistent sessions on disc.\n"
            "If this option is enabled, persistent sessions will survive full restart of the cluster.\n"
            "Otherwise, all the data will be stored in RAM, and it will be lost when all the nodes in the cluster are stopped."
        zh: "将持久会话数据保存在磁盘上。如果为 false 则存储在内存中。\n"
            "如开启， 持久会话数据可在集群重启后恢复。\n"
            "如关闭， 数据仅存储在内存中， 则在整个集群停止后丢失。"
    }
    label: {
        en: "Persist on disc"
        zh: "持久化在磁盘上"
    }
  }

  persistent_store_ram_cache {
    desc {
        en: "Maintain a copy of the data in RAM for faster access."
        zh: "在内存中保持一份数据的副本，以便更快地访问。"
    }
    label: {
        en: "RAM cache"
        zh: "内存缓存"
    }
  }

  persistent_session_store_max_retain_undelivered {
    desc {
        en: "The time messages that was not delivered to a persistent session\n"
            "is stored before being garbage collected if the node the previous\n"
            "session was handled on restarts of is stopped.\n"
        zh: "如果重新启动时处理上一个会话的节点已停止，则未传递到持久会话的消息在垃圾收集之前会被存储。"
    }
    label: {
        en: "Max retain undelivered"
        zh: "未投递的消息保留条数"
    }
  }

  persistent_session_store_message_gc_interval {
    desc {
        en: "The starting interval for garbage collection of undelivered messages to\n"
            "a persistent session. This affects how often the \"max_retain_undelivered\"\n"
            "is checked for removal.\n"
        zh: "将未送达的消息垃圾收集到持久会话的开始间隔。\n"
            "这会影响检查 \"max_retain_undelivered\"（最大保留未送达）的删除频率。"
    }
    label: {
        en: "Message GC interval"
        zh: "消息清理间隔"
    }
  }

  persistent_session_store_session_message_gc_interval {
    desc {
        en: "The starting interval for garbage collection of transient data for\n"
            "persistent session messages. This does not affect the lifetime length\n"
            "of persistent session messages.\n"
        zh: "持久会话消息的临时数据垃圾收集的开始间隔。\n"
            "这不会影响持久会话消息的生命周期长度。\n"
    }
    label: {
        en: "Session message GC interval"
        zh: "会话消息清理间隔"
    }
  }

  persistent_session_builtin_session_table {
    desc {
         en: "Performance tuning options for built-in session table."
         zh: "用于内建会话表的性能调优参数。"
    }
    label: {
         en: "Persistent session"
         zh: "持久会话"
    }
  }

  persistent_session_builtin_sess_msg_table {
    desc {
         en: "Performance tuning options for built-in session messages table."
         zh: "优化内置的会话消息表的配置。"
    }
    label: {
         en: "Persistent session messages"
         zh: "用于内建会话管理表的性能调优参数"
    }
  }

  persistent_session_builtin_messages_table {
    desc {
         en: "Performance tuning options for built-in messages table."
         zh: "用于内建消息表的性能调优参数。"
    }
    label: {
         en: "Persistent messages"
         zh: "持久化消息"
    }
  }

  stats_enable {
    desc {
        en: "Enable/disable statistic data collection."
        zh: "启用/禁用统计数据收集功能。"
    }
    label: {
        en: "Enable/disable statistic data collection."
        zh: "启用/禁用统计数据收集功能"
    }
  }

    zones {
        desc {
            en: """A zone is a set of configs grouped by the zone <code>name</code>.
For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.
NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.
"""
            zh: """<code>zone</code> 是按<code>name</code> 分组的一组配置。
对于灵活的配置映射，可以将 <code>name</code> 设置为侦听器的 <code>zone</code> 配置。
注：名为 <code>default</code> 的内置区域是自动创建的，无法删除。"""
        }
    }

    mqtt {
        desc {
            en: """Global MQTT configuration.
The configs here work as default values which can be overridden in <code>zone</code> configs
"""
            zh: """全局的 MQTT 配置项。
mqtt 下所有的配置作为全局的默认值存在，它可以被 <code>zone</code> 中的配置覆盖。"""
        }
    }

    mqtt_idle_timeout {
        desc {
            en: """After the TCP connection is established, if the MQTT CONNECT packet from the client is not received within the time specified by <code>idle_timeout</code>, the connection will be disconnected."""
            zh: """TCP 连接建立后，如果在 <code>idle_timeout</code> 指定的时间内未收到客户端的 MQTT CONNECT 报文，则连接将被断开。"""
        }
        label: {
            en: """Idle Timeout"""
            zh: """空闲超时"""
        }
    }

    mqtt_max_packet_size {
        desc {
            en: """Maximum MQTT packet size allowed."""
            zh: """允许的最大 MQTT 报文大小。"""
        }
        label: {
            en: """Max Packet Size"""
            zh: """最大报文大小"""
        }
    }

    mqtt_max_clientid_len {
        desc {
            en: """Maximum allowed length of MQTT Client ID."""
            zh: """允许的最大 MQTT Client ID 长度。"""
        }
        label: {
            en: """Max Client ID Length"""
            zh: """最大 Client ID 长度"""
        }
    }

    mqtt_max_topic_levels {
        desc {
            en: """Maximum topic levels allowed."""
            zh: """允许的最大主题层级。"""
        }
        label: {
            en: """Max Topic Levels"""
            zh: """最大主题层级"""
        }
    }

    mqtt_max_qos_allowed {
        desc {
            en: """Maximum QoS allowed."""
            zh: """允许的最大 QoS 等级。"""
        }
        label: {
            en: """Max QoS"""
            zh: """最大 QoS"""
        }
    }

    mqtt_max_topic_alias {
        desc {
            en: """Maximum topic alias, 0 means no topic alias supported."""
            zh: """允许的最大主题别名数，0 表示不支持主题别名。"""
        }
        label: {
            en: """Max Topic Alias"""
            zh: """最大主题别名"""
        }
    }

    mqtt_retain_available {
        desc {
            en: """Whether to enable support for MQTT retained message."""
            zh: """是否启用对 MQTT 保留消息的支持。"""
        }
        label: {
            en: """Retain Available"""
            zh: """保留消息可用"""
        }
    }

    mqtt_wildcard_subscription {
        desc {
            en: """Whether to enable support for MQTT wildcard subscription."""
            zh: """是否启用对 MQTT 通配符订阅的支持。"""
        }
        label: {
            en: """Wildcard Subscription Available"""
            zh: """通配符订阅可用"""
        }
    }

    mqtt_shared_subscription {
        desc {
            en: """Whether to enable support for MQTT shared subscription."""
            zh: """是否启用对 MQTT 共享订阅的支持。"""
        }
        label: {
            en: """Shared Subscription Available"""
            zh: """共享订阅可用"""
        }
    }

    mqtt_exclusive_subscription {
        desc {
            en: """Whether to enable support for MQTT exclusive subscription."""
            zh: """是否启用对 MQTT 排它订阅的支持。"""
        }
        label: {
            en: """Exclusive Subscription"""
            zh: """排它订阅"""
        }
    }

    mqtt_ignore_loop_deliver {
        desc {
            en: """Ignore loop delivery of messages for MQTT v3.1.1/v3.1.0, similar to <code>No Local</code> subscription option in MQTT 5.0."""
            zh: """是否为 MQTT v3.1.1/v3.1.0 客户端忽略投递自己发布的消息，类似于 MQTT 5.0 中的 <code>No Local</code> 订阅选项。"""
        }
        label: {
            en: """Ignore Loop Deliver"""
            zh: """忽略循环投递"""
        }
    }

    mqtt_strict_mode {
        desc {
            en: """Parse MQTT messages in strict mode.
When set to true, invalid utf8 strings in for example client ID, topic name, etc. will cause the client to be disconnected"""
            zh: """是否以严格模式解析 MQTT 消息。
当设置为 true 时，例如客户端 ID、主题名称等中的无效 utf8 字符串将导致客户端断开连接。"""
        }
        label: {
            en: """Strict Mode"""
            zh: """严格模式"""
        }
    }

    mqtt_response_information {
        desc {
            en: """Specify the response information returned to the client. This feature is disabled if is set to \"\". Applies only to clients using MQTT 5.0."""
            zh: """指定返回给客户端的响应信息。如果设置为 \"\"，则禁用此功能。仅适用于使用 MQTT 5.0 协议的客户端。"""
        }
        label: {
            en: """Response Information"""
            zh: """响应信息"""
        }
    }

    mqtt_server_keepalive {
        desc {
            en: """The keep alive that EMQX requires the client to use. If configured as <code>disabled</code>, it means that the keep alive specified by the client will be used. Requires <code>Server Keep Alive</code> in MQTT 5.0, so it is only applicable to clients using MQTT 5.0 protocol."""
            zh: """EMQX 要求客户端使用的保活时间，配置为 <code>disabled</code> 表示将使用客户端指定的保活时间。需要用到 MQTT 5.0 中的 <code>Server Keep Alive</code>，因此仅适用于使用 MQTT 5.0 协议的客户端。"""
        }
        label: {
            en: """Server Keep Alive"""
            zh: """服务端保持连接"""
        }
    }

    mqtt_keepalive_backoff {
        desc {
            en: """The backoff multiplier used by the broker to determine the client keep alive timeout. If EMQX doesn't receive any packet in <code>Keep Alive * Backoff * 2</code> seconds, EMQX will close the current connection."""
            zh: """Broker 判定客户端保活超时使用的退避乘数。如果 EMQX 在 <code>Keep Alive * Backoff * 2</code> 秒内未收到任何报文，EMQX 将关闭当前连接。"""
        }
        label: {
            en: """Keep Alive Backoff"""
            zh: """保持连接退避乘数"""
        }
    }

    mqtt_max_subscriptions {
        desc {
            en: """Maximum number of subscriptions allowed per client."""
            zh: """允许每个客户端建立的最大订阅数量。"""
        }
        label: {
            en: """Max Subscriptions"""
            zh: """最大订阅数量"""
        }
    }

    mqtt_upgrade_qos {
        desc {
            en: """Force upgrade of QoS level according to subscription."""
            zh: """投递消息时，是否根据订阅主题时的 QoS 等级来强制提升派发的消息的 QoS 等级。"""
        }
        label: {
            en: """Upgrade QoS"""
            zh: """升级 QoS"""
        }
    }

    mqtt_max_inflight {
        desc {
            en: """Maximum number of QoS 1 and QoS 2 messages that are allowed to be delivered simultaneously before completing the acknowledgment."""
            zh: """允许在完成应答前同时投递的 QoS 1 和 QoS 2 消息的最大数量。"""
        }
        label: {
            en: """Max Inflight"""
            zh: """最大飞行窗口"""
        }

    }

    mqtt_retry_interval {
        desc {
            en: """Retry interval for QoS 1/2 message delivering."""
            zh: """QoS 1/2 消息的重新投递间隔。"""
        }
        label: {
            en: """Retry Interval"""
            zh: """重试间隔"""
        }
    }

    mqtt_max_awaiting_rel {
        desc {
            en: """For each publisher session, the maximum number of outstanding QoS 2 messages pending on the client to send PUBREL. After reaching this limit, new QoS 2 PUBLISH requests will be rejected with `147(0x93)` until either PUBREL is received or timed out."""
            zh: """每个发布者的会话中，都存在一个队列来处理客户端发送的 QoS 2 消息。该队列会存储 QoS 2 消息的报文 ID 直到收到客户端的 PUBREL 或超时，达到队列长度的限制后，新的 QoS 2 消息发布会被拒绝，并返回 `147(0x93)` 错误。"""
        }
        label: {
            en: """Max Awaiting PUBREL"""
            zh: """PUBREL 等待队列长度"""
        }
    }

    mqtt_await_rel_timeout {
        desc {
            en: """For client to broker QoS 2 message, the time limit for the broker to wait before the `PUBREL` message is received. The wait is aborted after timed out, meaning the packet ID is freed for new `PUBLISH` requests. Receiving a stale `PUBREL` causes a warning level log. Note, the message is delivered to subscribers before entering the wait for PUBREL."""
            zh: """客户端发布 QoS 2 消息时，服务器等待 `PUBREL` 的最长时延。超过该时长后服务器会放弃等待，该PACKET ID 会被释放，从而允许后续新的 PUBLISH 消息使用。如果超时后收到 PUBREL，服务器将会产生一条告警日志。注意，向订阅客户端转发消息的动作发生在进入等待之前。"""
        }
        label: {
            en: """Max Awaiting PUBREL TIMEOUT"""
            zh: """PUBREL 最大等待时间"""
        }
    }

    mqtt_session_expiry_interval {
        desc {
            en: """Specifies how long the session will expire after the connection is disconnected, only for non-MQTT 5.0 connections."""
            zh: """指定会话将在连接断开后多久过期，仅适用于非 MQTT 5.0 的连接。"""
        }
        label: {
            en: """Session Expiry Interval"""
            zh: """会话过期间隔"""
        }
    }

    mqtt_max_mqueue_len {
        desc {
            en: """Maximum queue length. Enqueued messages when persistent client disconnected, or inflight window is full."""
            zh: """消息队列最大长度。持久客户端断开连接或飞行窗口已满时排队的消息长度。"""
        }
        label: {
            en: """Max Message Queue Length"""
            zh: """最大消息队列长度"""
        }
    }

    mqtt_mqueue_priorities {
        desc {
            en: """Topic priorities. Priority number [1-255]
There's no priority table by default, hence all messages are treated equal.

**NOTE**: Comma and equal signs are not allowed for priority topic names.
**NOTE**: Messages for topics not in the priority table are treated as either highest or lowest priority depending on the configured value for <code>mqtt.mqueue_default_priority</code>.

**Examples**:
To configure <code>\"topic/1\" > \"topic/2\"</code>:
<code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code>
"""
            zh: """主题优先级。取值范围 [1-255]
默认优先级表为空，即所有的主题优先级相同。

注：优先主题名称中不支持使用逗号和等号。
注：不在此列表中的主题，被视为最高/最低优先级，这取决于<code>mqtt.mqueue_default_priority</code> 的配置

示例：
配置 <code>\"topic/1\" > \"topic/2\"</code>:
<code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code>
"""
        }
        label: {
            en: """Topic Priorities"""
            zh: """主题优先级"""
        }
    }

    mqtt_mqueue_default_priority {
        desc {
            en: """Default topic priority, which will be used by topics not in <code>Topic Priorities</code> (<code>mqueue_priorities</code>)."""
            zh: """默认的主题优先级，不在 <code>主题优先级</code>（<code>mqueue_priorities</code>） 中的主题将会使用该优先级。"""
        }
        label: {
            en: """Default Topic Priorities"""
            zh: """默认主题优先级"""
        }
    }

    mqtt_mqueue_store_qos0 {
        desc {
            en: """Specifies whether to store QoS 0 messages in the message queue while the connection is down but the session remains."""
            zh: """指定在连接断开但会话保持期间，是否需要在消息队列中存储 QoS 0 消息。"""
        }
        label: {
            en: """Store QoS 0 Message"""
            zh: """存储 QoS 0 消息"""
        }
    }

    mqtt_use_username_as_clientid {
        desc {
            en: """Whether to user Client ID as Username.
This setting takes effect later than <code>Use Peer Certificate as Username</code> (<code>peer_cert_as_username</code>) and <code>Use peer certificate as Client ID</code> (<code>peer_cert_as_clientid</code>).
"""
            zh: """是否使用用户名作为客户端 ID。
此设置的作用时间晚于 <code>使用对端证书作为用户名</code>（<code>peer_cert_as_username</code>） 和 <code>使用对端证书作为客户端 ID</code>（<code>peer_cert_as_clientid</code>）。
"""
        }
        label: {
            en: """Use Username as Client ID"""
            zh: """使用用户名作为客户端 ID"""
        }
    }

    mqtt_peer_cert_as_username {
        desc {
            en: """Use the CN, DN field in the peer certificate or the entire certificate content as Username. Only works for the TLS connection.
Supported configurations are the following:
- <code>cn</code>: Take the CN field of the certificate as Username
- <code>dn</code>: Take the DN field of the certificate as Username
- <code>crt</code>: Take the content of the <code>DER</code> or <code>PEM</code> certificate as Username
- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format as Username
- <code>md5</code>: Take the MD5 value of the content of the <code>DER</code> or <code>PEM</code> certificate as Username
"""
            zh: """使用对端证书中的 CN、DN 字段或整个证书内容来作为用户名。仅适用于 TLS 连接。
目前支持配置为以下内容：
- <code>cn</code>: 取证书的 CN 字段作为 Username
- <code>dn</code>: 取证书的 DN 字段作为 Username
- <code>crt</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书的内容作为 Username
- <code>pem</code>: 将 <code>DER</code> 证书内容转换为 <code>PEM</code> 格式后作为 Username
- <code>md5</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书的内容的 MD5 值作为 Username
"""
        }
        label: {
            en: """Use Peer Certificate as Username"""
            zh: """使用对端证书作为用户名"""
        }
    }

    mqtt_peer_cert_as_clientid {
        desc {
            en: """Use the CN, DN field in the peer certificate or the entire certificate content as Client ID. Only works for the TLS connection.
Supported configurations are the following:
- <code>cn</code>: Take the CN field of the certificate as Client ID
- <code>dn</code>: Take the DN field of the certificate as Client ID
- <code>crt</code>: Take the content of the <code>DER</code> or <code>PEM</code> certificate as Client ID
- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format as Client ID
- <code>md5</code>: Take the MD5 value of the content of the <code>DER</code> or <code>PEM</code> certificate as Client ID
"""
            zh: """使用对端证书中的 CN、DN 字段或整个证书内容来作为客户端 ID。仅适用于 TLS 连接。
目前支持配置为以下内容：
- <code>cn</code>: 取证书的 CN 字段作为 Client ID
- <code>dn</code>: 取证书的 DN 字段作为 Client ID
- <code>crt</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书的内容作为 Client ID
- <code>pem</code>: 将 <code>DER</code> 证书内容转换为 <code>PEM</code> 格式后作为 Client ID
- <code>md5</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书的内容的 MD5 值作为 Client ID
"""
        }
        label: {
            en: """Use Peer Certificate as Client ID"""
            zh: """使用对端证书作为客户端 ID"""
        }
    }

    broker {
        desc {
            en: """Message broker options."""
            zh: """Broker 相关配置项。"""
        }
    }

    broker_enable_session_registry {
        desc {
            en: """Enable session registry"""
            zh: """是否启用 Session Registry"""
        }
    }

    broker_session_locking_strategy {
        desc {
            en: """Session locking strategy in a cluster.
  - `local`: only lock the session on the current node
  - `one`: select only one remote node to lock the session
  - `quorum`: select some nodes to lock the session
  - `all`: lock the session on all the nodes in the cluster
"""

            zh: """Session 在集群中的锁策略。
  - `loca`：仅锁本节点的 Session；
  - `one`：任选一个其它节点加锁；
  - `quorum`：选择集群中半数以上的节点加锁；
  - `all`：选择所有节点加锁。
"""
        }
    }

    broker_shared_subscription_strategy {
        desc {
            en: """Dispatch strategy for shared subscription.
  - `random`: dispatch the message to a random selected subscriber
  - `round_robin`: select the subscribers in a round-robin manner
  - `sticky`: always use the last selected subscriber to dispatch, until the subscriber disconnects.
  - `hash`: select the subscribers by the hash of `clientIds`
"""

            zh: """共享订阅消息派发策略。
  - `random`：随机挑选一个共享订阅者派发；
  - `round_robin`：使用 round-robin 策略派发；
  - `sticky`：总是使用上次选中的订阅者派发，直到它断开连接；
  - `hash`：使用发送者的 Client ID 进行 Hash 来选择订阅者。
"""
        }
    }

    broker_shared_dispatch_ack_enabled {
        desc {
            en: """Enable/disable shared dispatch acknowledgement for QoS 1 and QoS 2 messages.
This should allow messages to be dispatched to a different subscriber in the group in case the picked (based on `shared_subscription_strategy`) subscriber is offline.
"""

            zh: """启用/禁用 QoS 1 和 QoS 2 消息的共享派发确认。
开启后，允许将消息从未及时回复 ACK 的订阅者 （例如，客户端离线）重新派发给另外一个订阅者。
"""
        }
    }

    broker_route_batch_clean {
        desc {
            en: """Enable batch clean for deleted routes."""
            zh: """是否开启批量清除路由。"""
        }
    }

    shared_subscription_group_strategy {
        desc {
            en: """Per group dispatch strategy for shared subscription.
This config is a map from shared subscription group name to the strategy
name. The group name should be of format `[A-Za-z0-9]`. i.e. no
special characters are allowed.
"""
            cn: """设置共享订阅组为单位的分发策略。该配置是一个从组名到
策略名的一个map，组名不得包含 `[A-Za-z0-9]` 之外的特殊字符。
"""
          }

    }

    shared_subscription_strategy_enum {
        desc {
            en: """Dispatch strategy for shared subscription.
- `random`: dispatch the message to a random selected subscriber
- `round_robin`: select the subscribers in a round-robin manner
- `round_robin_per_group`: select the subscribers in round-robin fashion within each shared subscriber group
- `sticky`: always use the last selected subscriber to dispatch,
until the subscriber disconnects.
- `hash`: select the subscribers by the hash of `clientIds`
- `local`: send to a random local subscriber. If local
subscriber was not found, send to a random subscriber cluster-wide
"""
            cn: """共享订阅的分发策略名称。
- `random`：随机选择一个组内成员；
- `round_robin`：循环选择下一个成员；
- `round_robin_per_group`：在共享组内循环选择下一个成员；
- `sticky`：使用上一次选中的成员；
- `hash`：根据 ClientID 哈希映射到一个成员；
- `local`：随机分发到节点本地成成员，如果本地成员不存在，则随机分发到任意一个成员。
"""

          }
      }

    broker_perf_route_lock_type {
        desc {
            en: """Performance tuning for subscribing/unsubscribing a wildcard topic.
Change this parameter only when there are many wildcard topics.

NOTE: when changing from/to `global` lock, it requires all nodes in the cluster to be stopped before the change.
  - `key`: mnesia transactional updates with per-key locks. Recommended for a single-node setup.
  - `tab`: mnesia transactional updates with table lock. Recommended for a cluster setup.
  - `global`: updates are protected with a global lock. Recommended for large clusters.
"""
            zh: """通配主题订阅/取消订阅性能调优。
建议仅当通配符主题较多时才更改此参数。

注：当从/更改为 `global` 锁时，它要求集群中的所有节点在更改之前停止。
  - `key`：为 Mnesia 事务涉及到的每个 key 上锁，建议单节点时使用。
  - `tab`：为 Mnesia 事务涉及到的表上锁，建议在集群中使用。
  - `global`：所以更新操作都被全局的锁保护，仅建议在超大规模集群中使用。
"""
        }
    }

    broker_perf_trie_compaction {
        desc {
            en: """Enable trie path compaction.
Enabling it significantly improves wildcard topic subscribe rate, if wildcard topics have unique prefixes like: 'sensor/{{id}}/+/', where ID is unique per subscriber.
Topic match performance (when publishing) may degrade if messages are mostly published to topics with large number of levels.

NOTE: This is a cluster-wide configuration. It requires all nodes to be stopped before changing it.
"""
            zh: """是否开启主题表压缩存储。
启用它会显着提高通配符主题订阅率，如果通配符主题具有唯一前缀，例如：'sensor/{{id}}/+/'，其中每个订阅者的 ID 是唯一的。
如果消息主要发布到具有大量级别的主题，则主题匹配性能（发布时）可能会降低。

注意：这是一个集群范围的配置。 它要求在更改之前停止所有节点。
"""
        }
    }

    sys_topics {
        desc {
            en: """System topics configuration."""
            zh: """系统主题配置。"""
        }
    }

    sys_msg_interval {
        desc {
            en: """Time interval of publishing `$SYS` messages."""
            zh: """发送 `$SYS` 主题的间隔时间。"""
        }
    }

    sys_heartbeat_interval {
        desc {
            en: """Time interval for publishing following heartbeat messages:
  - `$SYS/brokers/<node>/uptime`
  - `$SYS/brokers/<node>/datetime`
"""
            zh: """发送心跳系统消息的间隔时间，它包括：
  - `$SYS/brokers/<node>/uptime`
  - `$SYS/brokers/<node>/datetime`
"""
        }
    }

    sys_event_messages {
        desc {
            en: """Client events messages."""
            zh: """客户端事件消息。"""
        }
    }

    sys_event_client_connected {
        desc {
            en: """Enable to publish client connected event messages"""
            zh: """是否开启客户端已连接事件消息。"""
        }
    }

    sys_event_client_disconnected {
        desc {
            en: """Enable to publish client disconnected event messages."""
            zh: """是否开启客户端已断开连接事件消息。"""
        }
    }

    sys_event_client_subscribed {
        desc {
            en: """Enable to publish event message that client subscribed a topic successfully."""
            zh: """是否开启客户端已成功订阅主题事件消息。"""
        }
    }

    sys_event_client_unsubscribed {
        desc {
            en: """Enable to publish event message that client unsubscribed a topic successfully."""
            zh: """是否开启客户端已成功取消订阅主题事件消息。"""
        }
    }


fields_authorization_no_match {
    desc {
        en: """
Default access control action if the user or client matches no ACL rules,
or if no such user or client is found by the configurable authorization
sources such as built_in_database, an HTTP API, or a query against PostgreSQL.
Find more details in 'authorization.sources' config.
"""
        zh: """
如果用户或客户端不匹配ACL规则，或者从可配置授权源(比如内置数据库、HTTP API 或 PostgreSQL 等。)内未找
到此类用户或客户端时，模式的认访问控制操作。
在“授权”中查找更多详细信息。
"""
    }
    label: {
        en: "Authorization no match"
        zh: "未匹时的默认授权动作"
    }
}

fields_authorization_deny_action {
    desc {
        en: """The action when the authorization check rejects an operation."""
        zh: """授权检查拒绝操作时的操作。"""
    }
    label: {
        en: "Authorization deny action"
        zh: "授权检查拒绝操作时的操作"
    }
}

fields_cache_enable {
    desc {
        en: """Enable or disable the authorization cache."""
        zh: """启用或禁用授权缓存。"""
    }
    label: {
        en: "Enable or disable the authorization cache."
        zh: "启用或禁用授权缓存"
    }
}

fields_cache_max_size {
    desc {
        en: """Maximum number of cached items."""
        zh: """缓存项的最大数量。"""
    }
    label: {
        en: "Maximum number of cached items."
        zh: "缓存项的最大数量"
    }
}

fields_cache_ttl {
    desc {
        en: """Time to live for the cached data.  """
        zh: """缓存数据的生存时间。"""
    }
    label: {
        en: "Time to live for the cached data."
        zh: "缓存数据的生存时间。"
    }
}

fields_deflate_opts_level {
    desc {
        en: """Compression level. """
        zh: """压缩级别"""
    }
    label: {
        en: "Compression level"
        zh: "压缩级别"
    }
}

fields_deflate_opts_mem_level {
    desc {
        en: """
Specifies the size of the compression state.<br/>
Lower values decrease memory usage per connection.
"""
        zh: """
指定压缩状态的大小<br/>
较低的值会减少每个连接的内存使用。
"""
    }
    label: {
        en: "Size of the compression state"
        zh: "压缩状态大小"
    }
}

fields_deflate_opts_strategy {
    desc {
        en: """Specifies the compression strategy."""
        zh: """指定压缩策略。"""
    }
    label: {
        en: "compression strategy"
        zh: "指定压缩策略"
    }
}

fields_deflate_opts_server_context_takeover {
    desc {
        en: """Takeover means the compression state is retained between server messages. """
        zh: """接管意味着在服务器消息之间保留压缩状态。"""
    }
    label: {
        en: "Server context takeover"
        zh: "服务上下文接管"
    }
}

fields_deflate_opts_client_context_takeover {
    desc {
        en: """Takeover means the compression state is retained between client messages. """
        zh: """接管意味着在客户端消息之间保留压缩状态。"""
    }
    label: {
        en: "Client context takeover"
        zh: "客户端上下文接管"
    }
}

fields_deflate_opts_server_max_window_bits {
    desc {
        en: """Specifies the size of the compression context for the server."""
        zh: """指定服务器压缩上下文的大小。"""
    }
    label: {
        en: "Server compression max window size"
        zh: "服务器压缩窗口大小"
    }
}

fields_deflate_opts_client_max_window_bits {
    desc {
        en: """Specifies the size of the compression context for the client."""
        zh: """指定客户端压缩上下文的大小。"""
    }
    label: {
        en: "Client compression max window size"
        zh: "压缩窗口大小"
    }
}

client_ssl_opts_schema_enable {
    desc {
        en: """Enable TLS. """
        zh: """启用 TLS。"""
    }
    label: {
        en: "Enable TLS."
        zh: "启用 TLS"
    }
}

common_ssl_opts_schema_cacertfile {
    desc {
        en: """
Trusted PEM format CA certificates bundle file.<br/>
The certificates in this file are used to verify the TLS peer's certificates.
Append new certificates to the file if new CAs are to be trusted.
There is no need to restart EMQX to have the updated file loaded, because
the system regularly checks if file has been updated (and reload).<br/>
NOTE: invalidating (deleting) a certificate from the file will not affect
already established connections.
"""
        zh: """
受信任的PEM格式 CA  证书捆绑文件<br/>
此文件中的证书用于验证TLS对等方的证书。
如果要信任新 CA，请将新证书附加到文件中。
无需重启EMQX即可加载更新的文件，因为系统会定期检查文件是否已更新（并重新加载）<br/>
注意：从文件中失效（删除）证书不会影响已建立的连接。
"""
    }
    label: {
        en: "CACertfile"
        zh: "CA 证书文件"
    }
}

common_ssl_opts_schema_certfile {
    desc {
        en: """
PEM format certificates chain file.<br/>
The certificates in this file should be in reversed order of the certificate
issue chain. That is, the host's certificate should be placed in the beginning
of the file, followed by the immediate issuer certificate and so on.
Although the root CA certificate is optional, it should be placed at the end of
the file if it is to be added.
"""
        zh: """
PEM格式证书链文件<br/>
此文件中的证书应与证书颁发链的顺序相反。也就是说，主机的证书应该放在文件的开头，
然后是直接颁发者 CA 证书，依此类推，一直到根 CA 证书。
根 CA 证书是可选的，如果想要添加，应加到文件到最末端。
"""
    }
    label: {
        en: "Certfile"
        zh: "证书文件"
    }
}

common_ssl_opts_schema_keyfile {
    desc {
        en: """PEM format private key file. """
        zh: """PEM格式的私钥文件。"""
    }
    label: {
        en: "Keyfile"
        zh: "私钥文件"
    }
}

common_ssl_opts_schema_verify {
    desc {
        en: """Enable or disable peer verification. """
        zh: """启用或禁用对等验证。"""
    }
    label: {
        en: "Verify peer"
        zh: "对等验证"
    }
}

common_ssl_opts_schema_reuse_sessions {
    desc {
        en: """Enable TLS session reuse. """
        zh: """启用 TLS 会话重用。"""
    }
    label: {
        en: "TLS session reuse"
        zh: "TLS 会话重用"
    }
}

common_ssl_opts_schema_depth {
    desc {
        en: """
Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.
So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/>
if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/>
if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.<br/>
"""
        zh: """
在有效的证书路径中，可以跟随对等证书的非自颁发中间证书的最大数量。
因此，如果深度为0，则对等方必须由受信任的根 CA 直接签名；<br/>
如果是1，路径可以是 PEER、中间 CA、ROOT-CA；<br/>
如果是2，则路径可以是PEER、中间 CA1、中间 CA2、ROOT-CA。
"""
    }
    label: {
        en: "CACert Depth"
        zh: "CA 证书深度"
    }
}

common_ssl_opts_schema_password {
    desc {
        en: """
String containing the user's password.
Only used if the private key file is password-protected.
"""
        zh: """
包含用户密码的字符串。
仅在私钥文件受密码保护时使用。
"""
    }
    label: {
        en: "Keyfile passphrase"
        zh: "秘钥文件密码"
    }
}

common_ssl_opts_schema_versions {
    desc {
        en: """
All TLS/DTLS versions to be supported.<br/>
NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/>
In case PSK cipher suites are intended, make sure to configure
<code>['tlsv1.2', 'tlsv1.1']</code> here.
"""
        zh: """
支持所有TLS/DTLS版本<br/>

注：PSK 的 Ciphers 无法在 <code>tlsv1.3</code> 中使用，如果打算使用 PSK 密码套件，请确保这里配置为 <code>["tlsv1.2","tlsv1.1"]</code>。
"""
    }
    label: {
        en: "SSL versions"
        zh: "SSL 版本"
    }
}

ciphers_schema_common {
    desc {
        en: """
This config holds TLS cipher suite names separated by comma,
or as an array of strings. e.g.
<code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
<code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
<br/>
Ciphers (and their ordering) define the way in which the
client and server encrypts information over the network connection.
Selecting a good cipher suite is critical for the
application's data security, confidentiality and performance.

The names should be in OpenSSL string format (not RFC format).
All default values and examples provided by EMQX config
documentation are all in OpenSSL format.<br/>

NOTE: Certain cipher suites are only compatible with
specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
incompatible cipher suites will be silently dropped.
For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
configuring cipher suites for other versions will have no effect.
<br/>

NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/>
If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/>
PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code><br/>
"""
        zh: """
此配置保存由逗号分隔的 TLS 密码套件名称，或作为字符串数组。例如
<code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code>或
<code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>。
<br/>
密码（及其顺序）定义了客户端和服务器通过网络连接加密信息的方式。
选择一个好的密码套件对于应用程序的数据安全性、机密性和性能至关重要。

名称应为 OpenSSL 字符串格式（而不是 RFC 格式）。
EMQX 配置文档提供的所有默认值和示例都是 OpenSSL 格式<br/>
注意：某些密码套件仅与特定的 TLS <code>版本</code>兼容（'tlsv1.1'、'tlsv1.2'或'tlsv1.3'）。
不兼容的密码套件将被自动删除。

例如，如果只有 <code>versions</code> 仅配置为 <code>tlsv1.3</code>。为其他版本配置密码套件将无效。

<br/>
注：PSK 的 Ciphers 不支持 tlsv1.3<br/>
如果打算使用PSK密码套件 <code>tlsv1.3</code>。应在<code>ssl.versions</code>中禁用。

<br/>
PSK 密码套件：
<code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code><br/>
"""
    }
    label: {
        en: ""
        zh: ""
    }
}

ciphers_schema_quic {
    desc {
        en: """
This config holds TLS cipher suite names separated by comma,
or as an array of strings. e.g.
<code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
<code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
<br/>
Ciphers (and their ordering) define the way in which the
client and server encrypts information over the network connection.
Selecting a good cipher suite is critical for the
application's data security, confidentiality and performance.

The names should be in OpenSSL string format (not RFC format).
All default values and examples provided by EMQX config
documentation are all in OpenSSL format.<br/>

NOTE: Certain cipher suites are only compatible with
specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
incompatible cipher suites will be silently dropped.
For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
configuring cipher suites for other versions will have no effect.
<br/>

NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/>
If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/>
PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code><br/>

NOTE: QUIC listener supports only 'tlsv1.3' ciphers<br/>
"""
        zh: """
此配置保存由逗号分隔的 TLS 密码套件名称，或作为字符串数组。例如
<code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code>或
<code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>。
<br/>
密码（及其顺序）定义了客户端和服务器通过网络连接加密信息的方式。
选择一个好的密码套件对于应用程序的数据安全性、机密性和性能至关重要。

名称应为 OpenSSL 字符串格式（而不是 RFC 格式）。
EMQX 配置文档提供的所有默认值和示例都是 OpenSSL 格式<br/>
注意：某些密码套件仅与特定的 TLS <code>版本</code>兼容（'tlsv1.1'、'tlsv1.2'或'tlsv1.3'）。
不兼容的密码套件将被自动删除。

例如，如果只有 <code>versions</code> 仅配置为 <code>tlsv1.3</code>。为其他版本配置密码套件将无效。

<br/>
注：PSK 的 Ciphers 不支持 tlsv1.3<br/>
如果打算使用PSK密码套件，<code>tlsv1.3</code>。应在<code>ssl.versions</code>中禁用。

<br/>
PSK 密码套件：
<code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code><br/>

注：QUIC 监听器不支持 tlsv1.3 的 ciphers
"""
    }
    label: {
        en: ""
        zh: ""
    }
}

common_ssl_opts_schema_user_lookup_fun {
    desc {
        en: """EMQX-internal callback that is used to lookup pre-shared key (PSK) identity. """
        zh: """用于查找预共享密钥（PSK）标识的 EMQX 内部回调。"""
    }
    label: {
        en: "SSL PSK user lookup fun"
        zh: "SSL PSK 用户回调"
    }
}

common_ssl_opts_schema_secure_renegotiate {
    desc {
        en: """
SSL parameter renegotiation is a feature that allows a client and a server
to renegotiate the parameters of the SSL connection on the fly.
RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
you drop support for the insecure renegotiation, prone to MitM attacks.
"""
        zh: """
SSL 参数重新协商是一种允许客户端和服务器动态重新协商 SSL 连接参数的功能。
RFC 5746 定义了一种更安全的方法。通过启用安全的重新协商，您就失去了对不安全的重新协商的支持，从而容易受到 MitM 攻击。
"""
    }
    label: {
        en: "SSL renegotiate"
        zh: "SSL 重新协商"
    }
}

server_ssl_opts_schema_dhfile {
    desc {
        en: """
Path to a file containing PEM-encoded Diffie-Hellman parameters
to be used by the server if a cipher suite using Diffie-Hellman
key exchange is negotiated. If not specified, default parameters
are used.<br/>
NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.
"""
        zh: """
如果协商使用Diffie-Hellman密钥交换的密码套件，则服务器将使用包含PEM编码的Diffie-Hellman参数的文件的路径。如果未指定，则使用默认参数。<br/>

注意：TLS 1.3不支持<code>dhfile</code>选项。
"""
    }
    label: {
        en: "SSL dhfile"
        zh: "SSL dhfile"
    }
}

server_ssl_opts_schema_fail_if_no_peer_cert {
    desc {
        en: """
Used together with {verify, verify_peer} by an TLS/DTLS server.
If set to true, the server fails if the client does not have a
certificate to send, that is, sends an empty certificate.
If set to false, it fails only if the client sends an invalid
certificate (an empty certificate is considered valid).
"""
        zh: """
TLS/DTLS 服务器与 {verify，verify_peer} 一起使用。
如果设置为true，则如果客户端没有要发送的证书，即发送空证书，服务器将失败。
如果设置为false，则仅当客户端发送无效证书（空证书被视为有效证书）时才会失败。
"""
    }
    label: {
        en: "SSL fail if no peer cert"
        zh: "没有证书则 SSL 失败"
    }
}

server_ssl_opts_schema_honor_cipher_order {
    desc {
        en: """
An important security setting, it forces the cipher to be set based
 on the server-specified order instead of the client-specified order,
 hence enforcing the (usually more properly configured) security
 ordering of the server administrator.
"""
        zh: """
一个重要的安全设置，它强制根据服务器指定的顺序而不是客户机指定的顺序设置密码，从而强制服务器管理员执行（通常配置得更正确）安全顺序。
"""
    }
    label: {
        en: "SSL honor cipher order"
        zh: "SSL honor cipher order"
    }
}

server_ssl_opts_schema_client_renegotiation {
    desc {
        en: """
In protocols that support client-initiated renegotiation,
the cost of resources of such an operation is higher for the server than the client.
This can act as a vector for denial of service attacks.
The SSL application already takes measures to counter-act such attempts,
but client-initiated renegotiation can be strictly disabled by setting this option to false.
The default value is true. Note that disabling renegotiation can result in
long-lived connections becoming unusable due to limits on
the number of messages the underlying cipher suite can encipher.
"""
        zh: """
在支持客户机发起的重新协商的协议中，这种操作的资源成本对于服务器来说高于客户机。
这可能会成为拒绝服务攻击的载体。
SSL 应用程序已经采取措施来反击此类尝试，但通过将此选项设置为 false，可以严格禁用客户端发起的重新协商。
默认值为 true。请注意，由于基础密码套件可以加密的消息数量有限，禁用重新协商可能会导致长期连接变得不可用。
"""
    }
    label: {
        en: "SSL client renegotiation"
        zh: "SSL 客户端冲协商"
    }
}

server_ssl_opts_schema_handshake_timeout {
    desc {
        en: """
Maximum time duration allowed for the handshake to complete
"""
        zh: """
握手完成所允许的最长时间
"""
    }
    label: {
        en: "Handshake timeout"
        zh: "握手超时时间"
    }
}

server_ssl_opts_schema_gc_after_handshake {
    desc {
        en: """
Memory usage tuning. If enabled, will immediately perform a garbage collection after
the TLS/SSL handshake.
"""
        zh: """
内存使用调优。如果启用，将在TLS/SSL握手完成后立即执行垃圾回收。
TLS/SSL握手建立后立即进行GC。
"""
    }
    label: {
        en: "Perform GC after handshake"
        zh: "握手后执行GC"
    }
}

fields_listeners_tcp {
    desc {
        en: """TCP listeners."""
        zh: """TCP 监听器。"""
    }
    label: {
        en: "TCP listeners"
        zh: "TCP 监听器"
    }
}

fields_listeners_ssl {
    desc {
        en: """SSL listeners."""
        zh: """SSL 监听器。"""
    }
    label: {
        en: "SSL listeners"
        zh: "SSL 监听器"
    }
}

fields_listeners_ws {
    desc {
        en: """HTTP websocket listeners."""
        zh: """HTTP websocket 监听器。"""
    }
    label: {
        en: "HTTP websocket listeners"
        zh: "HTTP websocket 监听器"
    }
}

fields_listeners_wss {
    desc {
        en: """HTTPS websocket listeners."""
        zh: """HTTPS websocket 监听器。"""
    }
    label: {
        en: "HTTPS websocket listeners"
        zh: "HTTPS websocket 监听器"
    }
}

fields_listeners_quic {
    desc {
        en: """QUIC listeners."""
        zh: """QUIC 监听器。"""
    }
    label: {
        en: "QUIC listeners"
        zh: "QUIC 监听器"
    }
}

fields_listener_enabled {
    desc {
        en: """Enable listener. """
        zh: """启停监听器。"""
    }
    label: {
        en: "Enable listener"
        zh: "启停监听器"
    }
}

fields_mqtt_quic_listener_certfile {
    desc {
        en: """Path to the certificate file."""
        zh: """证书文件。"""
    }
    label: {
        en: "Certificate file"
        zh: "证书文件"
    }
}

fields_mqtt_quic_listener_keyfile {
    desc {
        en: """Path to the secret key file. """
        zh: """私钥文件。"""
    }
    label: {
        en: "Key file"
        zh: "私钥文件"
    }
}

fields_mqtt_quic_listener_idle_timeout {
    desc {
        en: """How long a connection can go idle before it is gracefully shut down. 0 to disable"""
        zh: """一个连接在被关闭之前可以空闲多长时间。0表示禁用。"""
    }
    label: {
        en: "Idle Timeout"
        zh: "空闲超时时间"
    }
}

fields_mqtt_quic_listener_handshake_idle_timeout {
    desc {
        en: """How long a handshake can idle before it is discarded. """
        zh: """一个握手在被丢弃之前可以空闲多长时间。"""
    }
    label: {
        en: "Handshake Idle Timeout"
        zh: "握手空闲超时时间"
    }
}

fields_mqtt_quic_listener_keep_alive_interval {
    desc {
        en: """
How often to send PING frames to keep a connection alive. 0 means disabled.
"""
        zh: """
发送 PING 帧的频率，以保活连接. 设为 0 表示禁用。
"""
    }
    label: {
        en: "Keep Alive Interval"
        zh: "PING 保活频率"
    }
}

base_listener_bind {
    desc {
        en: """
IP address and port for the listening socket.
"""
        zh: """
监听套接字的 IP 地址和端口。
"""
    }
    label: {
        en: "IP address and port"
        zh: "IP 地址和端口"
    }
}

base_listener_acceptors {
    desc {
        en: """The size of the listener's receiving pool."""
        zh: """监听器接收池的大小。"""
    }
    label: {
        en: "Acceptors Num"
        zh: "接收器数量"
    }
}

base_listener_max_connections {
    desc {
        en: """The maximum number of concurrent connections allowed by the listener. """
        zh: """监听器允许的最大并发连接数。"""
    }
    label: {
        en: "Max connections"
        zh: "最大并发连接数"
    }
}

base_listener_mountpoint {
    desc {
        en: """
When publishing or subscribing, prefix all topics with a mountpoint string.
The prefixed string will be removed from the topic name when the message
is delivered to the subscriber. The mountpoint is a way that users can use
to implement isolation of message routing between different listeners.
For example if a client A subscribes to `t` with `listeners.tcp.\<name>.mountpoint`
set to `some_tenant`, then the client actually subscribes to the topic
`some_tenant/t`. Similarly, if another client B (connected to the same listener
as the client A) sends a message to topic `t`, the message is routed
to all the clients subscribed `some_tenant/t`, so client A will receive the
message, with topic name `t`.<br/>
Set to `""` to disable the feature.<br/>

Variables in mountpoint string:
  - <code>${clientid}</code>: clientid
  - <code>${username}</code>: username
"""
        zh: """
发布或订阅时，请在所有主题前面加上 mountpoint 字符串。

将消息传递给订阅者时，将从主题名称中删除带前缀的字符串。挂载点是一种用户可以用来实现不同侦听器之间消息路由隔离的方法。

例如，如果客户机 A 使用 <code>listeners.tcp.\<name>.mountpoint</code> 设置为'some_tenant'，那么客户端实际上订阅了主题'some_tenant/t'。<br/>
类似地，如果另一个客户端B（与客户端A连接到同一个侦听器）向主题 't' 发送消息，该消息将路由到所有订阅了'some_租户/t'的客户端，因此客户端 A 将接收主题名为't'的消息<br/>

设置为<code>""</code> 以禁用该功能<br/>

mountpoint 字符串中的变量：
- <code>${clientid}</code>: clientid
- <code>${username}</code>: username
"""
    }
    label: {
        en: "mountpoint"
        zh: "mountpoint"
    }
}

base_listener_zone {
    desc {
        en: """
The configuration zone to which the listener belongs.
"""
        zh: """
监听器所属的配置组。
"""
    }
    label: {
        en: "Zone"
        zh: "配置组"
    }
}

base_listener_limiter {
    desc {
        en: """
Type of the rate limit.
"""
        zh: """
速率限制类型
"""
    }
    label: {
        en: "Type of the rate limit."
        zh: "速率限制类型"
    }
}

base_listener_enable_authn {
    desc {
        en: """
Set <code>true</code> (default) to enable client authentication on this listener, the authentication
process goes through the configured authentication chain.
When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.
When set to <code>quick_deny_anonymous<code>, it behaves like when set to <code>true</code> but clients will be
denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off
anonymous clients early.
"""
        zh: """
配置 <code>true</code> （默认值）启用客户端进行身份认证，通过检查认配置的认认证器链来决定是否允许接入。
配置 <code>false</code> 时，将不对客户端做任何认证，任何客户端，不论是不是携带用户名等认证信息，都可以接入。
配置 <code>quick_deny_anonymous</code> 时，行为跟 <code>true</code> 类似，但是会对匿名
客户直接拒绝，不做使用任何认证器对客户端进行身份检查。
"""
    }
    label: {
        en: "Enable authentication"
        zh: "启用身份认证"
    }
}

mqtt_listener_access_rules {
    desc {
        en: """
The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny
"""
        zh: """此监听器的访问控制规则。"""
    }
    label: {
        en: "Access rules"
        zh: "访问控制规则"
    }
}

mqtt_listener_proxy_protocol {
    desc {
        en: """
Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/>
See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
"""
        zh: """
如果EMQX集群部署在 HAProxy 或 Nginx 之后，请启用代理协议 V1/2 <br/>
详情见: https://www.haproxy.com/blog/haproxy/proxy-protocol/
"""
    }
    label: {
        en: "Proxy protocol"
        zh: "Proxy protocol"
    }
}

mqtt_listener_proxy_protocol_timeout {
    desc {
        en: """
Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.
"""
        zh: """
代理协议超时。如果在超时时间内未收到代理协议数据包，EMQX将关闭TCP连接。
"""
    }
    label: {
        en: "Proxy protocol timeout"
        zh: "Proxy protocol 超时时间"
    }
}

global_authentication {
    desc {
        en: """Default authentication configs for all MQTT listeners.

For per-listener overrides see <code>authentication</code> in listener configs

This option can be configured with:
<ul>
  <li><code>[]</code>: The default value, it allows *ALL* logins</li>
  <li>one: For example <code>{enable:true,backend:\"built_in_database\",mechanism=\"password_based\"}</code></li>
  <li>chain: An array of structs.</li>
</ul>

When a chain is configured, the login credentials are checked against the backends per the configured order, until an 'allow' or 'deny' decision can be made.

If there is no decision after a full chain exhaustion, the login is rejected.
"""
        zh: """全局 MQTT 监听器的默认认证配置。 为每个监听器配置认证参考监听器器配置中的<code>authentication</code> 配置。

该配置可以被配置为：
<ul>
  <li><code>[]</code>: 默认值，允许所有的登录请求
  <li>配置为单认证器，例如 <code>{enable:true,backend:\"built_in_database\",mechanism=\"password_based\"}</code></li>
  <li>配置为认证器数组</li>
</ul>

当配置为认证链后，登录凭证会按照配置的顺序进行检查，直到做出<code>allow</code> 或 <code>deny</code>的结果。

如果在所有的认证器都执行完后，还是没有结果，登录将被拒绝。
"""
    }
}

listener_authentication {
    desc {
        en: """
Per-listener authentication override.
Authentication can be one single authenticator instance or a chain of authenticators as an array.
When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.<br/>

"""
        zh: """
监听器认证重载。

认证配置可以是单个认证器实例，也可以是一个认证器数组组成的认证链。
执行登录验证时（用户名、客户端 ID 等），将按配置的顺序执行。
"""
    }
    label: {
        en: "Per-listener authentication override"
        zh: "每个监听器的认证覆盖"
    }
}

fields_rate_limit_max_conn_rate {
    desc {
        en: """Maximum connections per second."""
        zh: """每秒最大连接数。"""
    }
    label: {
        en: "Max connection rate"
        zh: "每秒最大连接数"
    }
}

fields_rate_limit_conn_messages_in {
    desc {
        en: """Message limit for the external MQTT connections."""
        zh: """外部 MQTT 连接的消息限制。"""
    }
    label: {
        en: "connecting messages in"
        zh: "外部 MQTT 连接的消息限制"
    }
}

fields_rate_limit_conn_bytes_in {
    desc {
        en: """
Limit the rate of receiving packets for a MQTT connection.
The rate is counted by bytes of packets per second.
"""
        zh: """
限制 MQTT 连接接收数据包的速率。
速率以每秒的数据包字节数计算。
"""
    }
    label: {
        en: "Connection bytes in"
        zh: "数据包速率"
    }
}

client_ssl_opts_schema_server_name_indication {
    desc {
        en: """
Specify the host name to be used in TLS Server Name Indication extension.<br/>
For instance, when connecting to "server.example.net", the genuine server
which accepts the connection and performs TLS handshake may differ from the
host the TLS client initially connects to, e.g. when connecting to an IP address
or when the host has multiple resolvable DNS records <br/>
If not specified, it will default to the host name string which is used
to establish the connection, unless it is IP addressed used.<br/>
The host name is then also used in the host name verification of the peer
certificate.<br/> The special value 'disable' prevents the Server Name
Indication extension from being sent and disables the hostname
verification check.
"""
        zh: """
指定要在 TLS 服务器名称指示扩展中使用的主机名。<br/>
例如，当连接到 "server.example.net" 时，接受连接并执行 TLS 握手的真正服务器可能与 TLS 客户端最初连接到的主机不同，
例如，当连接到 IP 地址时，或者当主机具有多个可解析的 DNS 记录时<br/>
如果未指定，它将默认为使用的主机名字符串
建立连接，除非使用 IP 地址<br/>
然后，主机名也用于对等机的主机名验证证书<br/>
特殊值 <code>disable</code> 阻止发送服务器名称指示扩展，并禁用主机名验证检查。
"""
    }
    label: {
        en: "Server Name Indication"
        zh: "服务器名称指示"
    }
}

fields_tcp_opts_active_n {
    desc {
        en: """
Specify the {active, N} option for this Socket.<br/>
See: https://erlang.org/doc/man/inet.html#setopts-2
"""
        zh: """
为此套接字指定{active，N}选项<br/>
See: https://erlang.org/doc/man/inet.html#setopts-2
"""
    }
    label: {
        en: "active_n"
        zh: "active_n"
    }
}

fields_tcp_opts_backlog {
    desc {
        en: """
TCP backlog defines the maximum length that the queue of
 pending connections can grow to.
"""
        zh: """
TCP backlog 定义了挂起连接队列可以增长到的最大长度。
"""
    }
    label: {
        en: "TCP backlog length"
        zh: "TCP 连接队列长度"
    }
}

fields_tcp_opts_send_timeout {
    desc {
        en: """The TCP send timeout for the connections. """
        zh: """连接的 TCP 发送超时。"""
    }
    label: {
        en: "TCP send timeout"
        zh: "TCP 发送超时"
    }
}

fields_tcp_opts_send_timeout_close {
    desc {
        en: """
Close the connection if send timeout.
"""
        zh: """
如果发送超时，则关闭连接。
"""
    }
    label: {
        en: "TCP send timeout close"
        zh: "TCP 发送超时关闭连接"
    }
}

fields_tcp_opts_recbuf {
    desc {
        en: """
The TCP receive buffer (OS kernel) for the connections.
"""
        zh: """
连接的 TCP 接收缓冲区（OS 内核）。
"""
    }
    label: {
        en: "TCP receive buffer"
        zh: "TCP 接收缓冲区"
    }
}

fields_tcp_opts_sndbuf {
    desc {
        en: """
The TCP send buffer (OS kernel) for the connections.
"""
        zh: """
连接的 TCP 发送缓冲区（OS 内核）。
"""
    }
    label: {
        en: "TCP send buffer"
        zh: "TCP 发送缓冲区"
    }
}

fields_tcp_opts_buffer {
    desc {
        en: """
The size of the user-space buffer used by the driver.
"""
        zh: """
驱动程序使用的用户空间缓冲区的大小。
"""
    }
    label: {
        en: "TCP user-space buffer"
        zh: "TCP 用户态缓冲区"
    }
}

fields_tcp_opts_high_watermark {
    desc {
        en: """
The socket is set to a busy state when the amount of data queued internally
  by the VM socket implementation reaches this limit.
"""
        zh: """
当 VM 套接字实现内部排队的数据量达到此限制时，套接字将设置为忙碌状态。
"""
    }
    label: {
        en: "TCP 高水位线"
        zh: ""
    }
}

fields_tcp_opts_nodelay {
    desc {
        en: """
The TCP_NODELAY flag for the connections.
"""
        zh: """
连接的 TCP_NODELAY 标识
"""
    }
    label: {
        en: "TCP_NODELAY"
        zh: "TCP_NODELAY"
    }
}

fields_tcp_opts_reuseaddr {
    desc {
        en: """
The SO_REUSEADDR flag for the connections.
"""
        zh: """
连接的 SO_REUSEADDR 标识
"""
    }
    label: {
        en: "SO_REUSEADDR"
        zh: "SO_REUSEADDR"
    }
}

fields_trace_payload_encode {
    desc {
        en: """
Determine the format of the payload format in the trace file.<br/>
`text`: Text-based protocol or plain text protocol.
 It is recommended when payload is JSON encoded.<br/>
`hex`: Binary hexadecimal encode. It is recommended when payload is a custom binary protocol.<br/>
`hidden`: payload is obfuscated as `******`

"""
        zh: """
确定跟踪文件中有效负载格式的格式。<br/>
`text`：基于文本的协议或纯文本协议。
建议在有效负载为JSON编码时使用<br/>
`hex`：二进制十六进制编码。当有效负载是自定义二进制协议时，建议使用此选项<br/>
`hidden`：有效负载被模糊化为 `******`
"""
    }
    label: {
        en: "Payload encode"
        zh: "有效负载编码"
    }
}

fields_ws_opts_mqtt_path {
    desc {
        en: """
WebSocket's MQTT protocol path. So the address of EMQX Broker's WebSocket is:
<code>ws://{ip}:{port}/mqtt</code>
"""
        zh: """
WebSocket 的 MQTT 协议路径。因此，EMQX Broker的WebSocket地址为：
<code>ws://{ip}:{port}/mqtt</code>
"""
    }
    label: {
        en: "WS MQTT Path"
        zh: "WS MQTT 路径"
    }
}

fields_ws_opts_mqtt_piggyback {
    desc {
        en: """
Whether a WebSocket message is allowed to contain multiple MQTT packets.
"""
        zh: """
WebSocket消息是否允许包含多个 MQTT 数据包。
"""
    }
    label: {
        en: "MQTT Piggyback"
        zh: "MQTT Piggyback"
    }
}

fields_ws_opts_compress {
    desc {
        en: """
If <code>true</code>, compress WebSocket messages using <code>zlib</code>.<br/>
The configuration items under <code>deflate_opts</code> belong to the compression-related parameter configuration.
"""
        zh: """
如果 <code>true</code>，则使用<code>zlib</code> 压缩 WebSocket 消息<br/>
<code>deflate_opts</code> 下的配置项属于压缩相关参数配置。
"""
    }
    label: {
        en: "Ws compress"
        zh: "Ws 压缩"
    }
}

fields_ws_opts_idle_timeout {
    desc {
        en: """
Close transport-layer connections from the clients that have not sent MQTT CONNECT
message within this interval.
"""
        zh: """
关闭在此间隔内未发送 MQTT CONNECT 消息的客户端的传输层连接。
"""
    }
    label: {
        en: "WS idle timeout"
        zh: "WS 空闲时间"
    }
}

fields_ws_opts_max_frame_size {
    desc {
        en: """
The maximum length of a single MQTT packet.
"""
        zh: """
单个 MQTT 数据包的最大长度。
"""
    }
    label: {
        en: "Max frame size"
        zh: "最大数据包长度"
    }
}

fields_ws_opts_fail_if_no_subprotocol {
    desc {
        en: """
If <code>true</code>, the server will return an error when
 the client does not carry the <code>Sec-WebSocket-Protocol</code> field.
 <br/>Note: WeChat applet needs to disable this verification.
"""
        zh: """
如果<code>true</code>，当客户端未携带<code>Sec WebSocket Protocol</code>字段时，服务器将返回一个错误。
<br/>注意：微信小程序需要禁用此验证。
"""
    }
    label: {
        en: "Fail if no subprotocol"
        zh: "无 subprotocol 则失败"
    }
}

fields_ws_opts_supported_subprotocols {
    desc {
        en: """
Comma-separated list of supported subprotocols.
"""
        zh: """
逗号分隔的 subprotocols 支持列表。
"""
    }
    label: {
        en: "Supported subprotocols"
        zh: "Subprotocols 支持列表"
    }
}

fields_ws_opts_check_origin_enable {
    desc {
        en: """
If <code>true</code>, <code>origin</code> HTTP header will be
 validated against the list of allowed origins configured in <code>check_origins</code>
 parameter.
"""
        zh: """
如果<code>true</code>，<code>origin</code>HTTP 头将根据<code>check_origins</code>参数中配置的允许来源列表进行验证。
"""
    }
    label: {
        en: "Check origin"
        zh: "检查 origin"
    }
}

fields_ws_opts_allow_origin_absence {
    desc {
        en: """
If <code>false</code> and <code>check_origin_enable</code> is
 <code>true</code>, the server will reject requests that don't have <code>origin</code>
 HTTP header.
"""
        zh: """
If <code>false</code> and <code>check_origin_enable</code> is <code>true</code>, the server will reject requests that don't have <code>origin</code> HTTP header.
"""
    }
    label: {
        en: "Allow origin absence"
        zh: "允许 origin 缺失"
    }
}

fields_ws_opts_check_origins {
    desc {
        en: """
List of allowed origins.<br/>See <code>check_origin_enable</code>.
"""
        zh: """
允许的 origins 列表
"""
    }
    label: {
        en: "Allowed origins"
        zh: "允许的 origins"
    }
}

fields_ws_opts_proxy_address_header {
    desc {
        en: """
HTTP header used to pass information about the client IP address.
Relevant when the EMQX cluster is deployed behind a load-balancer.
"""
        zh: """
HTTP 头，用于传递有关客户端 IP 地址的信息。
当 EMQX 集群部署在负载平衡器后面时，这一点非常重要。
"""
    }
    label: {
        en: "Proxy address header"
        zh: "客户端地址头"
    }
}

fields_ws_opts_proxy_port_header {
    desc {
        en: """
HTTP header used to pass information about the client port.
Relevant when the EMQX cluster is deployed behind a load-balancer.
"""
        zh: """
HTTP 头，用于传递有关客户端端口的信息。
当 EMQX 集群部署在负载平衡器后面时，这一点非常重要。
"""
    }
    label: {
        en: "Proxy port header"
        zh: "客户端端口头"
    }
}

}

emqx_license_http_api {
  desc_license_info_api {
    desc {
      en: "Get license info"
      zh: "获取许可证信息"
    }
    label: {
      en: "License info"
      zh: "许可证信息"
    }
  }

  desc_license_key_api {
    desc {
      en: "Update a license key"
      zh: "更新一个许可证密钥"
    }
    label: {
      en: "Update license"
      zh: "更新许可证"
    }
  }
}

emqx_license_schema {
  license_root {
    desc {
      en: "Defines the EMQX Enterprise license. \n\n"
          "\n"
          "The default license has 1000 connections limit, it is "
          "issued on 2022-04-19 and valid for 5 years (1825 days).\n"
          "\n"
          "EMQX comes with a default trial license.  For production use, please \n"
          "visit https://www.emqx.com/apply-licenses/emqx to apply."
      zh: "EMQX企业许可证。\n"
          "EMQX 自带一个默认的试用许可证，"
          "默认试用许可允许最多接入 1000 个连接，签发时间是 2022年4月19日，有效期是 5 年（1825 天）。"
          "若需要在生产环境部署，\n"
          "请访问 https://www.emqx.com/apply-licenses/emqx 来申请。\n"
    }
    label {
      en: "License"
      zh: "许可证"
    }
  }

  key_field {
    desc {
      en: "License string"
      zh: "许可证字符串"
    }
    label {
      en: "License string"
      zh: "许可证字符串"
    }
  }

  connection_low_watermark_field {
    desc {
      en: "Low watermark limit below which license connection quota usage alarms are deactivated"
      zh: "低水位限制，低于此水位线时系统会清除连接配额使用告警"
    }
    label {
      en: "Connection low watermark"
      zh: "连接低水位线"
    }
  }

  connection_high_watermark_field {
    desc {
      en: "High watermark limit above which license connection quota usage alarms are activated"
      zh: "高水位线，连接数超过这个水位线时，系统会触发许可证连接配额使用告警"
    }
    label {
      en: "Connection high watermark"
      zh: "连接高水位"
    }
  }
}


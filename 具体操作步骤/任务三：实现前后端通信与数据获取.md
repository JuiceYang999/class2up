# **任务三：实现前后端通信与数据获取**

此任务分为两个部分：

1.  **前端 (VUE)**：修改 `CoreSource.vue` 文件，创建一个表单，让用户能输入MQTT服务器信息，并通过 `axios` 将这些信息发送到后端。
2.  **后端 (Python)**：创建 `pyt/backend.py` 文件，使用 `Flask` 框架搭建一个Web服务，该服务会接收前端发来的数据，并使用 `flask-mqtt` 库尝试连接到MQTT服务器。

-----

### 3.1 前端 (VUE) 代码编写

请在 `src/components/` 文件夹中，**修改 `CoreSource.vue` 文件**。
将 `CoreSource.vue` 的**全部内容**替换为以下代码。

**文件路径：** `juiceyang999/class2up/class2up-9730b2fcdf474be54786a1f787cc6b005a26d2fc/src/components/CoreSource.vue`

```vue
<template>
  <el-container>
    <el-header>
      <h2>数据采集与服务器连接</h2>
    </el-header>
    <el-main>
      <el-row :gutter="20">
        <el-col :span="12">
          <el-card class="box-card">
            <div slot="header" class="clearfix">
              <span>MQTT 服务器连接配置</span>
            </div>
            <el-form ref="form" :model="connection" label-width="120px">
              <el-form-item label="服务器地址">
                <el-input v-model="connection.host"></el-input>
              </el-form-item>
              <el-form-item label="端口号">
                <el-input v-model.number="connection.port" type="number"></el-input>
              </el-form-item>
              <el-form-item label="Client ID">
                <el-input v-model="connection.clientid"></el-input>
              </el-form-item>
              <el-form-item>
                <el-button type="primary" @click="onConnect">连接</el-button>
                <el-button @click="onDisconnect">断开</el-button>
              </el-form-item>
              <el-form-item label="连接状态">
                <el-tag :type="connectStatus ? 'success' : 'danger'">
                  {{ connectStatus ? '已连接' : '未连接' }}
                </el-tag>
              </el-form-item>
            </el-form>
          </el-card>
        </el-col>
        
        <el-col :span="12">
          <el-card class="box-card">
            <div slot="header" class="clearfix">
              <span>订阅与发布</span>
            </div>
            <el-form label-width="120px">
              <el-form-item label="订阅主题">
                <el-input placeholder="例如: Probe/Query/Response/STRESS_TEST_00000"></el-input>
              </el-form-item>
              <el-form-item>
                <el-button type="success">订阅</el-button>
              </el-form-item>
              <el-form-item label="收到的消息">
                <el-input
                  type="textarea"
                  :rows="5"
                  placeholder="等待消息..."
                  readonly>
                </el-input>
              </el-form-item>
            </el-form>
          </el-card>
        </el-col>
      </el-row>
    </el-main>
  </el-container>
</template>

<script>
// 1. 引入 axios 用于前后端通信
import axios from "axios";

// 2. 设置 axios 的基础URL，所有请求都会自动加上 /api 前缀
// 这对应《实验步骤.pdf》P9的 "axios.defaults.baseURL = "/api";"
// 我们在 vue.config.js 中配置了 /api 代理
axios.defaults.baseURL = "/api";

export default {
  name: "CoreSource",
  data() {
    return {
      // 对应《实验步骤.pdf》P10 "前端定义输入变量: connection"
      connection: {
        host: "127.0.0.1",
        port: 1883,
        clientid: "vue_client_" + Math.random().toString(16).substr(2, 8),
      },
      connectStatus: false, // 用于显示连接状态
    };
  },
  methods: {
    // 3. onConnect 函数，对应《实验步骤.pdf》P10
    onConnect() {
      console.log("正在连接到MQTT服务器...");
      // 使用 axios.post 发送数据到后端
      // '/connect/' 对应后端 Flask 的路由
      // {data: this.connection} 对应后端 request.get_json()['data']
      axios
        .post("/connect/", { data: this.connection })
        .then((res) => {
          // 这里的 res.data 对应后端 `return {'rc_status': ...}`
          console.log("后端返回的数据:", res.data);
          // 我们用 rc_status 的内容来判断是否成功
          if (res.data && res.data.rc_status === "success") {
            this.connectStatus = true;
            console.log("连接成功！");
            this.$message({
              message: 'MQTT服务器连接成功！',
              type: 'success'
            });
          } else {
            this.connectStatus = false;
            this.$message.error('连接失败: ' + res.data.rc_status);
          }
        })
        .catch((err) => {
          // 如果后端服务没启动或出错，会在这里捕获
          console.error("连接请求失败:", err);
          this.connectStatus = false;
          this.$message.error('后端服务连接失败，请检查Python后端是否已运行。');
        });
    },
    onDisconnect() {
      // (功能待定，目前仅用于前端演示)
      console.log("断开连接");
      this.connectStatus = false;
      this.$message({
        message: '已断开连接（前端模拟）',
        type: 'info'
      });
      // 实际开发中，这里也应该向后端发送一个 /disconnect/ 请求
    }
  },
};
</script>

<style scoped>
.el-header {
  background-color: #b3c0d1;
  color: #333;
  line-height: 60px;
}
.box-card {
  text-align: left;
}
</style>
```

-----

### 3.2 后端 (Python) 代码编写

现在，我们在项目**根目录**（`juiceyang999/class2up/class2up-9730b2fcdf474be54786a1f787cc6b005a26d2fc/`）下，**新建**一个名为 `pyt` 的文件夹。

然后，在 `pyt` 文件夹中**新建**一个 `backend.py` 文件。

#### 3.2.1 安装 Python 依赖

当您回到主机时，需要先为您的Python环境安装 `Flask`（Web框架）、`flask-cors`（解决跨域）、`flask-mqtt`（连接MQTT）和 `pymysql`（后续连接MySQL时使用）。

**安装命令：**

```bash
pip install Flask flask-cors flask-mqtt pymysql
```

#### 3.2.2 编写 `backend.py` 代码

请将以下代码**复制**到 `backend.py` 文件中。

**文件路径：** `juiceyang999/class2up/class2up-9730b2fcdf474be54786a1f787cc6b005a26d2fc/pyt/backend.py`

```python
from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_mqtt import Mqtt
import time

# 1. 初始化 Flask 应用
app = Flask(__name__)
# 允许所有域名的跨域请求（在开发中很有用）
CORS(app)

# 2. 配置 Flask-MQTT
# 我们先设置默认值，稍后会用前端传来的数据覆盖它们
app.config['MQTT_BROKER_URL'] = '127.0.0.1'  # 默认服务器地址
app.config['MQTT_BROKER_PORT'] = 1883       # 默认端口
app.config['MQTT_CLIENT_ID'] = 'flask_mqtt_client'
app.config['MQTT_KEEPALIVE'] = 60
app.config['MQTT_TLS_ENABLED'] = False

# 3. 初始化 MQTT 客户端
mqtt = Mqtt(app)

# --- MQTT 事件回调 ---
# 当连接成功时
@mqtt.on_connect()
def handle_connect(client, userdata, flags, rc):
    if rc == 0:
        print("MQTT 连接成功 (rc=0)")
    else:
        print(f"MQTT 连接失败，返回码: {rc}")

# 当收到消息时 (我们将在下一步任务中用到)
@mqtt.on_message()
def handle_message(client, userdata, message):
    data = dict(
        topic=message.topic,
        payload=message.payload.decode()
    )
    print(f"收到消息: {data}")

# --- Flask API 路由 ---

# 4. 创建 /connect/ 接口，对应《实验步骤.pdf》P10
@app.route('/connect/', methods=['POST', 'GET'])
def make_connect():
    try:
        # 5. 接收前端发来的JSON数据
        # 对应 axios.post 中的 {data: this.connection}
        data_connect = request.get_json()['data']
        
        # 6. 在后端控制台打印收到的数据
        print(f"收到来自前端的连接请求: {data_connect}")

        # 7. 更新 MQTT 配置并尝试连接
        app.config['MQTT_BROKER_URL'] = data_connect['host']
        app.config['MQTT_BROKER_PORT'] = data_connect['port']
        app.config['MQTT_CLIENT_ID'] = data_connect['clientid']
        
        # 重新配置并连接
        mqtt.client.disconnect() # 先断开旧连接
        mqtt.client._client_id = data_connect['clientid'].encode()
        mqtt.client.reinitialise()
        mqtt.client.connect(data_connect['host'], data_connect['port'])

        print(f"正在尝试连接到 {data_connect['host']}:{data_connect['port']}...")
        
        # 8. 向前端返回成功响应
        # 对应 axios.then(res => ...)
        # 我们返回 'success' 字符串，前端会据此更新 "连接状态"
        return jsonify({'rc_status': 'success'})

    except Exception as e:
        print(f"连接失败: {e}")
        # 如果出错，返回错误信息
        return jsonify({'rc_status': str(e)})

# (我们将在任务4中添加 /subscribe/ 接口)

# 9. 启动 Flask 服务
if __name__ == '__main__':
    # 确保端口为 5000，以匹配 vue.config.js 中的代理设置
    app.run(debug=True, host='127.0.0.1', port=5000)
```

-----

### 3.3 运行与调试（当您回到主机时）

1.  **启动环境（共4个）：**

      * **终端 1：** 运行 `emqx start` (任务 2.1)。
      * **终端 2：** 运行 `StressTest-INC-Cloud -n 1 -b 0` (任务 2.2)，并保持窗口开启。
      * **终端 3：** `cd` 到 VUE 项目目录 (…`/class2up-9730b2fcdf474be54786a1f787cc6b005a26d2fc`)，运行 `yarn serve`。
      * **终端 4：** `cd` 到 VUE 项目目录 (…`/class2up-9730b2fcdf474be54786a1f787cc6b005a26d2fc`)，运行 `python pyt/backend.py`。

2.  **测试：**

      * 打开浏览器访问 VUE 页面（如 `http://localhost:8080`）。
      * 点击导航栏的 “数据采集”。
      * 表单中应已填好 `127.0.0.1` 和 `1883`。
      * 点击 “连接” 按钮。
      * **预期结果：**
        1.  VUE 页面右上角弹出 “MQTT服务器连接成功！” 提示，“连接状态” 变为 “已连接”。
        2.  在 **终端 4** (Python 后端) 的输出中，您会看到 `收到来自前端的连接请求: ...` 和 `MQTT 连接成功 (rc=0)` 的打印信息。

**任务三完成**。我们成功打通了 VUE -\> Flask -\> MQTT Broker 的整条链路。

接下来，我们将开始**任务四：实现数据可视化 (Echarts)**。我们将修改后端以订阅数据，并修改前端 `ShowData.vue` 页面以接收并显示数据。
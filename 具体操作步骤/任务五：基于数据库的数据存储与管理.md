## **任务五：基于数据库的数据存储与管理**

此任务的目标是将我们在任务四中获取到的实时数据，同步写入到 **MySQL**（关系型数据库）和 **InfluxDB**（时序数据库）中。所有操作都在后端 `backend.py` 文件中完成，前端 VUE 页面无需修改。

这是一个纯后端的任务，我们将分三步进行：

1.  **数据库环境准备**。
2.  **安装 Python 依赖库**。
3.  **修改 `backend.py` 代码** 以实现双数据库写入。

-----

### 5.1 数据库环境准备（主机操作步骤）

当您回到主机后，在启动 `backend.py` 之前，必须先配置好两个数据库。

#### 5.1.1 MySQL 数据库配置

根据《实验步骤.pdf》P19-P20，您需要使用 Navicat 等工具完成以下操作：

1.  **确保服务运行：** 确保您的 MySQL 服务正在运行。
2.  **创建连接：** 在 Navicat 中，创建一个到 `localhost` (主机)、端口 `3306`、用户名为 `root`、并输入您密码的连接。
3.  **新建数据库：** 右键点击连接，选择“新建数据库”。
      * 数据库名：`mqtt_data`
      * 字符集：`utf8`
      * 排序规则：`utf8_general_ci`
4.  **新建数据表：**
      * 双击进入 `mqtt_data` 数据库，右键点击“表”，选择“新建表”。
      * 根据《实验步骤.pdf》P21的案例，我们创建一个表（我建议添加一个 `id` 主键和 `data_id` 字段以便区分数据）：
          * `id`：类型 `INT`，勾选 `自动递增` (Auto Increment)，设为 `主键`。
          * `data_id`：类型 `VARCHAR(50)` (例如 '0103502202')。
          * `payload`：类型 `VARCHAR(255)` (用于存储数据值)。
          * `time`：类型 `DATETIME` (用于存储时间戳)。
      * 点击“保存”，表名填写：`mac_data`。

#### 5.1.2 InfluxDB (边缘端) 配置

根据《实验步骤.pdf》P14-P15，您需要完成以下操作：
**安装Influxdb**：
https://docs.influxdata.com/influxdb/v2/install/?t=Windows#download-and-install-influxdb-v2

1.  **启动服务：**
      * 打开 `cmd`，`cd` 到您的 InfluxDB 配置文件夹（例如 `E:\MQTT-test\Influxdb配置文件`）。
      * 运行命令：`influxd`
      * **保持此 `cmd` 窗口开启**。
2.  **Web端配置：**
      * 打开浏览器，访问 `http://localhost:8086`。
      * 您将看到 InfluxDB 的**首次设置界面**。
      * 设置您的**用户名**、**密码**、**组织名称** (Organization, 例如 `my-org`) 和**存储桶名称** (Bucket, 例如 `mqtt_bucket`)。
3.  **获取 Token：**
      * 设置完成后，您会进入 InfluxDB 的主界面。
      * 在左侧菜单栏找到 `Data` -\> `API Tokens`。
      * 您会看到一个为您自动生成的 `<username>'s Token`。
      * 点击它，然后点击 “Copy to Clipboard” **复制这个 Token**。
      * **将这个 Token 字符串**、您的\*\*组织名称(Org)**和**存储桶名称(Bucket)\*\*保存好，我们马上要在 `backend.py` 中使用它们。

-----

### 5.2 安装 Python 依赖库

您需要安装用于连接 InfluxDB v2 的 Python 客户端（`pymysql` 我们在任务三已安装）。

当您回到主机后，请在**终端 4** (运行后端的终端) 中，`cd` 到 VUE 项目根目录，并执行：

```bash
pip install influxdb-client
```

-----

### 5.3 后端 (Python) 代码更新

现在，我们将修改 `backend.py`，在 `handle_message` 函数中（即每次收到MQTT消息时）添加将数据写入这两个数据库的逻辑。

请**替换** `pyt/backend.py` 文件的**全部内容**为以下代码：

**文件路径：** `juiceyang999/class2up/class2up-9730b2fcdf474be54786a1f787cc6b005a26d2fc/pyt/backend.py`

```python
from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_mqtt import Mqtt
import json
import pymysql       # (新增) 引入 MySQL 库
import datetime      # (新增) 引入时间库
from influxdb_client import InfluxDBClient, Point, WritePrecision # (新增) 引入 InfluxDB 库
from influxdb_client.client.write_api import SYNCHRONOUS

# --- (新增) 数据库配置 ---
# 1. MySQL 配置 (请根据您的设置修改)
MYSQL_HOST = 'localhost'
MYSQL_USER = 'root'
MYSQL_PASSWORD = 'xjtu2025'  # ！！！请修改为您的MySQL密码！！！
MYSQL_DB = 'mqtt_data'
MYSQL_PORT = 3306

# 2. InfluxDB v2 配置 (请根据您在 5.1.2 中设置和复制的值修改)
INFLUX_URL = "http://localhost:8086"
INFLUX_TOKEN = "YOUR_API_TOKEN_HERE"  # ！！！请修改为您复制的 Token！！！
INFLUX_ORG = "my-org"                 # ！！！请修改为您的组织名称！！！
INFLUX_BUCKET = "mqtt_bucket"         # ！！！请修改为您的存储桶名称！！！

# 3. (新增) 初始化 InfluxDB 客户端
try:
    influx_client = InfluxDBClient(url=INFLUX_URL, token=INFLUX_TOKEN, org=INFLUX_ORG)
    # 使用同步写入模式
    write_api = influx_client.write_api(write_options=SYNCHRONOUS)
    print("InfluxDB 客户端初始化成功。")
except Exception as e:
    print(f"InfluxDB 客户端初始化失败: {e}")
# -------------------------

# 初始化 Flask 应用
app = Flask(__name__)
CORS(app)

# 配置 Flask-MQTT
app.config['MQTT_BROKER_URL'] = '127.0.0.1'
app.config['MQTT_BROKER_PORT'] = 1883
app.config['MQTT_CLIENT_ID'] = 'flask_mqtt_client'
app.config['MQTT_KEEPALIVE'] = 60
app.config['MQTT_TLS_ENABLED'] = False

mqtt = Mqtt(app)

# 暂存最新数据
latest_data_store = {}

# --- (新增) 数据库写入函数 ---

def save_to_mysql(data_id, value):
    """
    将数据保存到 MySQL 数据库
    """
    conn = None
    cur = None
    try:
        # 获取当前时间
        time_str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # 建立连接
        conn = pymysql.connect(
            host=MYSQL_HOST,
            user=MYSQL_USER,
            password=MYSQL_PASSWORD,
            database=MYSQL_DB,
            port=MYSQL_PORT,
            charset='utf8'
        )
        # 创建游标
        cur = conn.cursor()
        
        # SQL 插入语句 (使用参数化查询防止SQL注入)
        sql = "INSERT INTO mac_data (data_id, payload, time) VALUES (%s, %s, %s)"
        
        # 执行 SQL
        cur.execute(sql, (data_id, str(value), time_str))
        
        # 提交事务
        conn.commit()
        print(f"MySQL 写入成功: ID={data_id}, Value={value}")
        
    except Exception as e:
        print(f"MySQL 写入失败: {e}")
        if conn:
            conn.rollback() # 出错时回滚
    finally:
        # 关闭游标和连接
        if cur:
            cur.close()
        if conn:
            conn.close()

def save_to_influxdb(data_id, value):
    """
    将数据保存到 InfluxDB
    """
    try:
        # 转换为 float，InfluxDB 推荐使用数值类型
        value_float = float(value)
        
        # 创建一个数据点 (Point)
        p = Point("machine_data") \
            .tag("device_id", "STRESS_TEST_00000") \
            .tag("data_id", data_id) \
            .field("value", value_float) \
            .time(datetime.datetime.utcnow(), WritePrecision.NS)
            
        # 写入数据
        write_api.write(bucket=INFLUX_BUCKET, org=INFLUX_ORG, record=p)
        print(f"InfluxDB 写入成功: ID={data_id}, Value={value_float}")
        
    except Exception as e:
        print(f"InfluxDB 写入失败: {e}")

# --- MQTT 事件回调 ---

@mqtt.on_connect()
def handle_connect(client, userdata, flags, rc):
    if rc == 0:
        print("MQTT 连接成功 (rc=0)")
        response_topic = "Query/Response/STRESS_TEST_00000"
        mqtt.subscribe(response_topic)
        print(f"已自动订阅主题: {response_topic}")
    else:
        print(f"MQTT 连接失败，返回码: {rc}")

@mqtt.on_message()
def handle_message(client, userdata, message):
    # 4. (更新) 当收到消息时，解析、存储、并写入数据库
    try:
        payload_str = message.payload.decode()
        print(f"收到消息 (Topic: {message.topic}): {payload_str}")
        
        data = json.loads(payload_str)
        
        if 'values' in data and isinstance(data['values'], list):
            for item in data['values']:
                if 'id' in item and 'values' in item:
                    data_id = item['id']
                    value = item['values'][0] # 假设我们只关心第一个值
                    
                    # 4.1. 暂存数据 (供前端Echarts使用)
                    latest_data_store[data_id] = value
                    print(f"已更新数据存储: {latest_data_store}")

                    # 4.2. (新增) 写入 MySQL
                    save_to_mysql(data_id, value)
                    
                    # 4.3. (新增) 写入 InfluxDB
                    save_to_influxdb(data_id, value)
            
    except Exception as e:
        print(f"处理消息失败: {e}")

# --- Flask API 路由 (保持不变) ---

@app.route('/connect/', methods=['POST', 'GET'])
def make_connect():
    try:
        data_connect = request.get_json()['data']
        print(f"收到来自前端的连接请求: {data_connect}")
        app.config['MQTT_BROKER_URL'] = data_connect['host']
        app.config['MQTT_BROKER_PORT'] = data_connect['port']
        app.config['MQTT_CLIENT_ID'] = data_connect['clientid']
        if mqtt.client.is_connected():
            mqtt.client.disconnect()
        mqtt.client.username_pw_set(None, None)
        mqtt.client._client_id = data_connect['clientid'].encode()
        mqtt.client.reinitialise()
        mqtt.client.connect(data_connect['host'], data_connect['port'])
        print(f"正在尝试连接到 {data_connect['host']}:{data_connect['port']}...")
        return jsonify({'rc_status': 'success'})
    except Exception as e:
        print(f"连接失败: {e}")
        return jsonify({'rc_status': str(e)})

@app.route('/publish/', methods=['POST'])
def do_publish():
    try:
        data = request.get_json()
        topic = data.get('topic')
        payload = data.get('payload', "{}")
        if not topic:
            return jsonify({'status': 'error', 'message': 'Topic is required'}), 400
        print(f"正在发布消息到 (Topic: {topic}): {payload}")
        mqtt.publish(topic, payload)
        return jsonify({'status': 'published', 'topic': topic})
    except Exception as e:
        print(f"发布失败: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500

@app.route('/get_data/', methods=['POST'])
def get_data():
    try:
        data = request.get_json()
        data_id = data.get('id')
        if not data_id:
            return jsonify({'status': 'error', 'message': 'ID is required'}), 400
        value = latest_data_store.get(data_id)
        if value is not None:
            return jsonify({'status': 'ok', 'id': data_id, 'value': value})
        else:
            return jsonify({'status': 'not_found', 'id': data_id, 'value': None})
    except Exception as e:
        print(f"获取数据失败: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500

# 启动 Flask 服务
if __name__ == '__main__':
    app.run(debug=True, host='127.0.0.1', port=5000)
```

-----

### 5.4 运行与调试（当您回到主机时）

1.  **启动环境（共 5 个）：**

      * **终端 1：** 运行 `emqx start` (MQTT Broker)。
      * **终端 2：** 运行 `StressTest-INC-Cloud -n 1 -b 0` (数据源)。
      * **终端 3：** 运行 `influxd` (InfluxDB 数据库)。
      * **终端 4：** 运行 `yarn serve` (VUE 前端)。
      * **终端 5：** **(重要\!)** 确保您已将 `backend.py` 中的 `MYSQL_PASSWORD` 和 `INFLUX_TOKEN` 修改为您自己的配置。然后运行 `python pyt/backend.py` (Python 后端)。

2.  **测试：**

      * 打开浏览器访问 VUE 页面（如 `http://localhost:8080`）。
      * 点击 “**数据采集**” 页面，点击 “**连接**”，确保连接成功。
      * 点击 “**数据显示**” 页面，您会看到 Echarts 图表开始实时显示数据。

3.  **验证存储：**

      * **MySQL 验证：**
          * 打开 **Navicat**。
          * 刷新 `mqtt_data` 数据库下的 `mac_data` 表。
          * **预期结果：** 您会看到表中**每隔几秒就新增一行数据**，包含 `data_id` ('0103502202')、`payload` (速度值) 和 `time` (时间戳)。
      * **InfluxDB 验证：**
          * 打开浏览器访问 `http://localhost:8086`。
          * 点击左侧菜单的 `Explore` (Data Explorer)。
          * 在查询构建器 (Query Builder) 中：
              * **FROM:** 选择您的存储桶 `mqtt_bucket`。
              * **Filter (Measurement):** 选择 `machine_data`。
              * **Filter (Field):** 选择 `value`。
              * **Filter (Tag):** 选择 `data_id` = `0103502202`。
          * 点击 “**Submit**”。
          * **预期结果：** 您会看到一个与 VUE 页面中 Echarts 几乎一样的实时图表，证明时序数据已成功写入。
### 补充：云端 Influxdb 时序数据库存储
**总述：**
打开云端 Influxdb 时序数据库服务网页 https://us-east-1-1.aws.cloud2.influxdata.com，注册账号登录。点击 buckets 可以设置数据存储桶，与边缘端相同。点击 source-node 进入配置界面。根据指引可以进行编程，也可参考本地数据库配置代码，功能相同。在 Dataexplorer中可以查看上传的数据。

***见“任务六：搭建云端inflexdb.md”***

**任务五完成**。我们现在已经具备了数据采集、前后端通信、实时可视化和双数据库存储的能力。

接下来，我们将进行**任务六：大数据分布式存储**，这需要我们将 MySQL 中的数据对接到工业大数据平台（Hadoop）。